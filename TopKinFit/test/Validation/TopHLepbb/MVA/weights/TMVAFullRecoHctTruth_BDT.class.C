// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.06/01       [394753]
Creator        : kskovpen
Date           : Tue Jan 10 22:34:55 2017
Host           : Linux vocms0315.cern.ch 2.6.32-573.26.1.el6.x86_64 #1 SMP Wed May 4 09:23:05 CEST 2016 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /storage_mnt/storage/user/kskovpen/analysis/tHFCNC/CMSSW_8_0_12/src/TopKinFit/test/Validation/TopHLepbb/MVA
Training events: 66941
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
SeparationType: "giniindex" [Separation criterion for node splitting]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
MinNodeSize: "5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "2" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 4
HiggsRecMTruth                HiggsRecMTruth                HiggsRecMTruth                HiggsRecMTruth                                                  'F'    [18.7024154663,1766.10412598]
TopLepRecMTruth               TopLepRecMTruth               TopLepRecMTruth               TopLepRecMTruth                                                 'F'    [82.8747940063,2164.33300781]
HiggsTopLepRecDrTruth         HiggsTopLepRecDrTruth         HiggsTopLepRecDrTruth         HiggsTopLepRecDrTruth                                           'F'    [0.0285255406052,8.53481197357]
TopLepRecPtTruth              TopLepRecPtTruth              TopLepRecPtTruth              TopLepRecPtTruth                                                'F'    [0.179126471281,1348.68603516]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTNode
   
#ifndef BDTNode__def
#define BDTNode__def
   
class BDTNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 4 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "HiggsRecMTruth", "TopLepRecMTruth", "HiggsTopLepRecDrTruth", "TopLepRecPtTruth" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[4];
   double fVmax[4];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[4];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadBDT::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(0.666442566022134);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.728501,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.204666,-99) , 
0, 153.417, 1, 0, 0.68675,-99) , 
NN(
0, 
0, 
-1, 119.64, 0, -1, 0.168498,-99) , 
1, 264.179, 1, 0, 0.613517,-99) , 
NN(
0, 
0, 
-1, 181.992, 1, -1, 0.0264275,-99) , 
0, 185.122, 1, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.323084);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.49797, 0, 1, 0.765648,-99) , 
NN(
0, 
0, 
-1, 82.0847, 0, -1, 0.452065,-99) , 
3, 193.231, 0, 0, 0.524056,-99) , 
NN(
0, 
0, 
-1, 260.409, 1, -1, 0.0502053,-99) , 
0, 185.122, 1, 0, 0.445642,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.463119);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.68742,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.382077,-99) , 
1, 222.215, 1, 0, 0.617415,-99) , 
NN(
0, 
0, 
-1, 67.0004, 0, -1, 0.2787,-99) , 
0, 82.0974, 0, 0, 0.569546,-99) , 
NN(
0, 
0, 
-1, 260.409, 1, -1, 0.0680497,-99) , 
0, 185.122, 1, 0, 0.494774,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.355016);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.629019,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.402629,-99) , 
0, 91.1528, 0, 0, 0.576169,-99) , 
NN(
0, 
0, 
-1, 160.587, 1, -1, 0.271693,-99) , 
0, 145.492, 1, 0, 0.535627,-99) , 
NN(
0, 
0, 
-1, 260.409, 1, -1, 0.103965,-99) , 
0, 185.122, 1, 0, 0.478271,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.308386);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 108.51, 0, 1, 0.693905,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.558225,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.364204,-99) , 
3, 129.039, 0, 0, 0.454152,-99) , 
2, 3.27479, 0, 0, 0.50707,-99) , 
NN(
0, 
0, 
-1, 260.409, 1, -1, 0.141984,-99) , 
0, 185.122, 1, 0, 0.462651,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.215549);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 216.165, 0, 1, 0.571846,-99) , 
NN(
0, 
0, 
-1, 137.722, 1, -1, 0.413011,-99) , 
2, 2.87017, 0, 0, 0.494317,-99) , 
NN(
0, 
0, 
-1, 2.74185, 0, -1, 0.183844,-99) , 
0, 185.122, 1, 0, 0.459068,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.192676);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544235,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.333872,-99) , 
0, 63.9842, 0, 0, 0.528034,-99) , 
NN(
0, 
0, 
-1, 160.21, 1, -1, 0.3512,-99) , 
0, 137.568, 1, 0, 0.49292,-99) , 
NN(
0, 
0, 
-1, 2.74185, 0, -1, 0.218407,-99) , 
0, 185.122, 1, 0, 0.463192,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.208937);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.703193,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.612775,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.436049,-99) , 
2, 3.67941, 0, 0, 0.453523,-99) , 
3, 257.038, 0, 0, 0.475772,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.230705,-99) , 
1, 281.109, 1, 0, 0.446893,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.147379);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.712793,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494782,-99) , 
3, 192.709, 0, 0, 0.53125,-99) , 
NN(
0, 
0, 
-1, 129.854, 1, -1, 0.354707,-99) , 
2, 1.65146, 0, 0, 0.509323,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.269847,-99) , 
1, 281.109, 1, 0, 0.482101,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.15733);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 256.886, 0, 1, 0.556054,-99) , 
NN(
0, 
0, 
-1, 129.854, 1, -1, 0.389115,-99) , 
2, 1.65146, 0, 0, 0.535603,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.299848,-99) , 
1, 281.109, 1, 0, 0.50943,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.10765);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 3.22374, 0, 1, 0.528399,-99) , 
NN(
0, 
0, 
-1, 182.354, 1, -1, 0.430836,-99) , 
3, 64.8473, 0, 0, 0.50867,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.288821,-99) , 
0, 185.122, 1, 0, 0.487287,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.119552);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541664,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470045,-99) , 
0, 103.606, 0, 0, 0.510942,-99) , 
NN(
0, 
0, 
-1, 157.946, 1, -1, 0.415258,-99) , 
0, 137.568, 1, 0, 0.492628,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.311424,-99) , 
0, 185.122, 1, 0, 0.475305,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.143592);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549129,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44578,-99) , 
1, 194.802, 1, 0, 0.511961,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.344161,-99) , 
1, 130.071, 0, 0, 0.497726,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.333688,-99) , 
1, 281.109, 1, 0, 0.480083,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.0845183);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.60404,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503613,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.427325,-99) , 
0, 129.644, 1, 0, 0.48207,-99) , 
3, 257.423, 0, 0, 0.492449,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.338867,-99) , 
0, 185.122, 1, 0, 0.478211,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.0874865);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510117,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.36993,-99) , 
2, 1.24656, 0, 0, 0.499453,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.385621,-99) , 
1, 139.51, 0, 0, 0.483889,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.359723,-99) , 
1, 281.109, 1, 0, 0.470806,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.108975);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.57929,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504566,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.445863,-99) , 
3, 147.154, 0, 0, 0.462313,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.330957,-99) , 
0, 185.122, 1, 0, 0.450375,-99) , 
3, 257.038, 0, 0, 0.461322,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.114595);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.676148,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.428869,-99) , 
3, 108.51, 0, 0, 0.533449,-99) , 
NN(
0, 
0, 
-1, 1.42511, 0, -1, 0.467094,-99) , 
2, 3.27479, 0, 0, 0.480857,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.372664,-99) , 
0, 185.122, 1, 0, 0.471057,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.0497982);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.674216,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499574,-99) , 
3, 257.271, 0, 0, 0.511476,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.420288,-99) , 
2, 1.25171, 0, 0, 0.504479,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.399821,-99) , 
0, 185.122, 1, 0, 0.495076,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.0881473);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540048,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471258,-99) , 
2, 2.05636, 0, 0, 0.526619,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44995,-99) , 
1, 139.51, 0, 0, 0.516285,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4168,-99) , 
1, 281.109, 1, 0, 0.506105,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.0428864);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.575862,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.563246,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49689,-99) , 
2, 3.67941, 0, 0, 0.503589,-99) , 
3, 257.423, 0, 0, 0.509527,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.409394,-99) , 
0, 185.122, 1, 0, 0.500599,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.0765519);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529077,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.407245,-99) , 
0, 156.813, 1, 0, 0.520981,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454957,-99) , 
0, 66.2486, 0, 0, 0.516509,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.419802,-99) , 
0, 185.122, 1, 0, 0.507913,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.0487172);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.571093,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511039,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477207,-99) , 
1, 186.706, 1, 0, 0.497811,-99) , 
3, 257.038, 0, 0, 0.503477,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.436385,-99) , 
1, 281.109, 1, 0, 0.496695,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.0444643);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.636611,-99) , 
NN(
0, 
0, 
-1, 154.805, 1, -1, 0.490628,-99) , 
3, 256.886, 0, 0, 0.500524,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.427432,-99) , 
2, 1.24371, 0, 0, 0.494872,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.053317);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.626263,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510575,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45066,-99) , 
0, 154.805, 1, 0, 0.501743,-99) , 
3, 256.886, 0, 0, 0.51014,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438348,-99) , 
2, 1.24371, 0, 0, 0.5046,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.044708);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543859,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508294,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458408,-99) , 
1, 148.949, 0, 0, 0.497898,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.435025,-99) , 
1, 281.109, 1, 0, 0.491767,-99) , 
2, 3.67408, 0, 0, 0.496707,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.0949457);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.635973,-99) , 
NN(
0, 
0, 
-1, 3.77058, 0, -1, 0.42863,-99) , 
3, 107.899, 0, 0, 0.518224,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.567455,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482342,-99) , 
2, 2.03809, 1, 0, 0.502182,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501227,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.388166,-99) , 
2, 2.34314, 0, 0, 0.462585,-99) , 
3, 129.039, 1, 0, 0.484233,-99) , 
2, 3.26902, 0, 0, 0.491301,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.0489734);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5414,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.59081,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486421,-99) , 
3, 257.271, 0, 0, 0.494145,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.427655,-99) , 
2, 1.07011, 0, 0, 0.489872,-99) , 
2, 3.67408, 0, 0, 0.494736,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.0310823);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.592072,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504691,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453603,-99) , 
3, 36.8484, 0, 0, 0.500685,-99) , 
3, 256.886, 0, 0, 0.506708,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459882,-99) , 
2, 1.24371, 0, 0, 0.503135,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.0457116);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 106.15, 1, 1, 0.547714,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510421,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472808,-99) , 
3, 129.039, 1, 0, 0.494924,-99) , 
1, 264.179, 0, 0, 0.501354,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458154,-99) , 
0, 185.122, 1, 0, 0.497601,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.0423833);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514636,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479542,-99) , 
1, 201.993, 1, 0, 0.504065,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457483,-99) , 
1, 130.071, 0, 0, 0.50018,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455182,-99) , 
1, 281.109, 1, 0, 0.495706,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.087957);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530889,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533376,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460205,-99) , 
3, 134.946, 1, 0, 0.508696,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.581928,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451976,-99) , 
3, 171.373, 0, 0, 0.474205,-99) , 
2, 2.87017, 1, 0, 0.490845,-99) , 
3, 257.038, 0, 0, 0.494073,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.0738601);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.617624,-99) , 
NN(
0, 
0, 
-1, 3.77058, 0, -1, 0.455947,-99) , 
3, 107.899, 0, 0, 0.525379,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544426,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485824,-99) , 
0, 102.506, 1, 0, 0.503955,-99) , 
NN(
0, 
0, 
-1, 1.41729, 0, -1, 0.469376,-99) , 
3, 129.039, 1, 0, 0.488324,-99) , 
2, 3.26902, 0, 0, 0.495993,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.0657212);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 3.0354, 0, 1, 0.593656,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.560518,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489008,-99) , 
3, 154.612, 0, 0, 0.499729,-99) , 
3, 190.955, 0, 0, 0.514199,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.552041,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499383,-99) , 
0, 106.426, 1, 0, 0.517678,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.399175,-99) , 
3, 193.231, 1, 0, 0.487661,-99) , 
2, 2.45889, 0, 0, 0.506223,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.0509761);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.552806,-99) , 
NN(
NN(
0, 
0, 
-1, 108.847, 0, 1, 0.541069,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51822,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482075,-99) , 
3, 129.039, 1, 0, 0.501851,-99) , 
2, 3.15328, 0, 0, 0.509584,-99) , 
2, 3.67408, 0, 0, 0.513662,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.0459406);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 128.608, 0, 1, 0.521844,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514157,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45442,-99) , 
0, 90.0223, 1, 0, 0.490918,-99) , 
0, 101.912, 0, 0, 0.512626,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479248,-99) , 
1, 281.109, 1, 0, 0.509323,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.0263055);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533764,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.575055,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496405,-99) , 
3, 257.271, 0, 0, 0.502146,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456449,-99) , 
2, 1.07011, 0, 0, 0.499262,-99) , 
2, 3.67408, 0, 0, 0.502515,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.0422708);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 115.204, 0, 1, 0.552299,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507651,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456881,-99) , 
2, 1.39504, 0, 0, 0.501578,-99) , 
2, 3.21711, 0, 0, 0.512218,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514557,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499091,-99) , 
3, 43.1466, 0, 0, 0.507512,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.439217,-99) , 
2, 3.27479, 1, 0, 0.487087,-99) , 
3, 64.3937, 0, 0, 0.507039,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.0278697);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525511,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.552735,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483499,-99) , 
3, 108.847, 0, 0, 0.519941,-99) , 
NN(
0, 
0, 
-1, 185.734, 1, -1, 0.492859,-99) , 
2, 3.15328, 0, 0, 0.498182,-99) , 
2, 3.67408, 0, 0, 0.500752,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.034362);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 106.15, 1, 1, 0.568316,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505447,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470224,-99) , 
1, 146.795, 0, 0, 0.498687,-99) , 
1, 264.179, 0, 0, 0.507168,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483156,-99) , 
0, 185.122, 1, 0, 0.505105,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.0572593);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531556,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497658,-99) , 
1, 153.672, 0, 0, 0.517304,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483597,-99) , 
0, 101.912, 0, 0, 0.507594,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.580664,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488237,-99) , 
1, 265.562, 0, 0, 0.510271,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.403493,-99) , 
0, 155.37, 1, 0, 0.493621,-99) , 
1, 181.992, 1, 0, 0.500638,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0329719);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.551245,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518637,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492771,-99) , 
2, 2.87017, 1, 0, 0.505603,-99) , 
0, 185.122, 0, 0, 0.509198,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478286,-99) , 
1, 281.109, 1, 0, 0.506162,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0529124);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 3.0354, 0, 1, 0.575004,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538584,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492321,-99) , 
3, 145.528, 0, 0, 0.501702,-99) , 
3, 190.955, 0, 0, 0.51287,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545293,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495526,-99) , 
2, 1.65184, 1, 0, 0.514116,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.424156,-99) , 
3, 193.231, 1, 0, 0.491497,-99) , 
2, 2.45889, 0, 0, 0.506443,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.0430419);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.63241,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494827,-99) , 
2, 3.0354, 0, 0, 0.562025,-99) , 
NN(
0, 
0, 
-1, 3.90554, 0, 1, 0.509571,-99) , 
3, 190.955, 0, 0, 0.517541,-99) , 
NN(
NN(
0, 
0, 
-1, 101.517, 0, 1, 0.517479,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437128,-99) , 
3, 193.231, 1, 0, 0.497321,-99) , 
2, 2.45889, 0, 0, 0.511463,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.0293808);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531284,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537143,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510061,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487418,-99) , 
2, 2.87017, 1, 0, 0.498268,-99) , 
3, 208.105, 0, 0, 0.501121,-99) , 
3, 257.038, 0, 0, 0.5035,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.041444);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.619113,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499832,-99) , 
2, 3.0354, 0, 0, 0.557839,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.560063,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495551,-99) , 
2, 3.90554, 0, 0, 0.502008,-99) , 
3, 190.955, 0, 0, 0.510459,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520079,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482989,-99) , 
3, 101.517, 0, 0, 0.49938,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440492,-99) , 
3, 193.231, 1, 0, 0.484609,-99) , 
2, 2.45889, 0, 0, 0.502686,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.0381367);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 190.955, 0, 1, 0.517546,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52053,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489991,-99) , 
0, 106.426, 1, 0, 0.500584,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45073,-99) , 
3, 193.231, 1, 0, 0.488095,-99) , 
2, 2.45889, 0, 0, 0.508693,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.016146);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53083,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531063,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501566,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467395,-99) , 
0, 185.122, 1, 0, 0.498702,-99) , 
3, 208.105, 0, 0, 0.50107,-99) , 
3, 257.038, 0, 0, 0.503404,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0158074);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526807,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52704,-99) , 
NN(
0, 
0, 
-1, 281.109, 1, -1, 0.495342,-99) , 
3, 208.105, 0, 0, 0.49766,-99) , 
3, 257.038, 0, 0, 0.499945,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0299723);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.594734,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494827,-99) , 
2, 3.0354, 0, 0, 0.543127,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540812,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496945,-99) , 
2, 3.90554, 0, 0, 0.501319,-99) , 
3, 190.955, 0, 0, 0.507617,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531449,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496121,-99) , 
2, 1.30598, 1, 0, 0.504202,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453139,-99) , 
3, 193.231, 1, 0, 0.491411,-99) , 
2, 2.45889, 0, 0, 0.502745,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0373736);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 3.0354, 0, 1, 0.543438,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517335,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489016,-99) , 
3, 81.938, 0, 0, 0.507319,-99) , 
3, 190.955, 0, 0, 0.512754,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518562,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498662,-99) , 
1, 182.715, 1, 0, 0.508269,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460576,-99) , 
3, 193.231, 1, 0, 0.496333,-99) , 
2, 2.45889, 0, 0, 0.507818,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.0268075);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548294,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5128,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493105,-99) , 
3, 129.039, 1, 0, 0.504734,-99) , 
0, 185.122, 0, 0, 0.508146,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48615,-99) , 
1, 281.109, 1, 0, 0.50599,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.0177288);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533915,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529061,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503076,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474111,-99) , 
0, 185.122, 1, 0, 0.500657,-99) , 
3, 208.105, 0, 0, 0.502731,-99) , 
3, 257.038, 0, 0, 0.505167,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.02174);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529501,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524642,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505266,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48933,-99) , 
2, 2.87017, 1, 0, 0.496965,-99) , 
3, 208.105, 0, 0, 0.498985,-99) , 
3, 257.038, 0, 0, 0.501368,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.0268561);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.577191,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490371,-99) , 
2, 3.0354, 0, 0, 0.532173,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535616,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496977,-99) , 
3, 163.697, 0, 0, 0.501047,-99) , 
3, 190.955, 0, 0, 0.505721,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509697,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486976,-99) , 
3, 101.517, 0, 0, 0.49702,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466019,-99) , 
3, 193.231, 1, 0, 0.489263,-99) , 
2, 2.45889, 0, 0, 0.500772,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.0231038);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.570623,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497084,-99) , 
2, 3.0354, 0, 0, 0.532459,-99) , 
NN(
0, 
0, 
-1, 3.90554, 0, 1, 0.506347,-99) , 
3, 190.955, 0, 0, 0.510265,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505883,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488699,-99) , 
1, 182.715, 0, 0, 0.497699,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464815,-99) , 
2, 1.07008, 0, 0, 0.491522,-99) , 
2, 2.45889, 0, 0, 0.50463,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.0189409);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528771,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522259,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506622,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493258,-99) , 
0, 101.912, 1, 0, 0.497359,-99) , 
3, 208.105, 0, 0, 0.499174,-99) , 
3, 257.038, 0, 0, 0.50148,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.0125529);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524049,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537471,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499296,-99) , 
0, 185.122, 0, 0, 0.502268,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483274,-99) , 
1, 281.109, 1, 0, 0.500525,-99) , 
3, 257.038, 0, 0, 0.502356,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.0204007);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 3.90554, 0, 1, 0.50887,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523198,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497245,-99) , 
2, 1.30598, 1, 0, 0.503175,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469111,-99) , 
3, 193.231, 1, 0, 0.49466,-99) , 
2, 2.45889, 0, 0, 0.504597,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.0108614);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521489,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531681,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499577,-99) , 
0, 185.122, 0, 0, 0.502074,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48383,-99) , 
1, 281.109, 1, 0, 0.500399,-99) , 
3, 257.038, 0, 0, 0.502039,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.0281765);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 128.608, 0, 1, 0.512577,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505971,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454996,-99) , 
3, 144.576, 1, 0, 0.489054,-99) , 
0, 101.912, 0, 0, 0.505549,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489502,-99) , 
1, 281.109, 1, 0, 0.503978,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.0115596);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517361,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51978,-99) , 
NN(
0, 
0, 
-1, 185.122, 1, -1, 0.496371,-99) , 
3, 208.105, 0, 0, 0.498075,-99) , 
3, 257.038, 0, 0, 0.499573,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.0131883);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54596,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523668,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498165,-99) , 
3, 207.972, 0, 0, 0.499938,-99) , 
3, 256.886, 0, 0, 0.502843,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486598,-99) , 
2, 1.24371, 0, 0, 0.501626,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.0339911);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550232,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508848,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461432,-99) , 
3, 61.7331, 0, 0, 0.485487,-99) , 
3, 107.899, 0, 0, 0.512683,-99) , 
NN(
NN(
0, 
0, 
-1, 3.11514, 0, 1, 0.513028,-99) , 
NN(
0, 
0, 
-1, 1.41729, 0, -1, 0.488319,-99) , 
3, 129.039, 1, 0, 0.501942,-99) , 
2, 3.26902, 0, 0, 0.504141,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.0166079);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519789,-99) , 
NN(
NN(
0, 
0, 
-1, 3.21218, 0, 1, 0.509718,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500747,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479258,-99) , 
2, 3.27479, 1, 0, 0.495432,-99) , 
3, 122.488, 0, 0, 0.501266,-99) , 
3, 257.038, 0, 0, 0.502704,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.0263766);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539361,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504399,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474005,-99) , 
3, 61.7331, 0, 0, 0.489435,-99) , 
3, 107.899, 0, 0, 0.510385,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528037,-99) , 
NN(
0, 
0, 
-1, 185.734, 1, -1, 0.492476,-99) , 
2, 3.1147, 0, 0, 0.496918,-99) , 
2, 3.26902, 0, 0, 0.499672,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.0267904);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52009,-99) , 
NN(
NN(
0, 
0, 
-1, 102.557, 1, 1, 0.508542,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.55053,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487645,-99) , 
2, 3.94916, 0, 0, 0.495065,-99) , 
2, 2.87017, 1, 0, 0.501596,-99) , 
3, 257.038, 0, 0, 0.50303,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.0166595);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531966,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522269,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498952,-99) , 
3, 191.801, 0, 0, 0.502602,-99) , 
2, 3.90554, 0, 0, 0.505218,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509107,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494027,-99) , 
3, 128.963, 0, 0, 0.500327,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468568,-99) , 
2, 1.07008, 0, 0, 0.494367,-99) , 
2, 2.45889, 0, 0, 0.501951,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.02407);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 3.16976, 0, 1, 0.515845,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507648,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487752,-99) , 
2, 3.32697, 1, 0, 0.501428,-99) , 
3, 127.363, 0, 0, 0.507454,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516681,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497222,-99) , 
3, 119.856, 0, 0, 0.503455,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47241,-99) , 
3, 193.231, 1, 0, 0.495704,-99) , 
2, 2.45889, 0, 0, 0.503916,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.0200394);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534136,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507259,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486402,-99) , 
3, 61.7331, 0, 0, 0.496995,-99) , 
3, 107.899, 0, 0, 0.512564,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524113,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500539,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.445519,-99) , 
0, 185.734, 1, 0, 0.496008,-99) , 
2, 3.1147, 0, 0, 0.499518,-99) , 
2, 3.26902, 0, 0, 0.502183,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.0223361);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529146,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506355,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488459,-99) , 
2, 3.77058, 0, 0, 0.496915,-99) , 
3, 107.899, 0, 0, 0.510422,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519113,-99) , 
NN(
0, 
0, 
-1, 185.734, 1, -1, 0.491823,-99) , 
2, 3.1147, 0, 0, 0.49523,-99) , 
2, 3.26902, 0, 0, 0.498332,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.0226492);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 182.354, 1, 1, 0.518917,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480694,-99) , 
3, 30.7568, 0, 0, 0.509154,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526635,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51857,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493725,-99) , 
3, 247.865, 0, 0, 0.496564,-99) , 
2, 3.5714, 0, 0, 0.499153,-99) , 
3, 64.3937, 1, 0, 0.501225,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.0291831);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532377,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504983,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471023,-99) , 
0, 185.122, 1, 0, 0.502158,-99) , 
3, 165.296, 0, 0, 0.505206,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.556464,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473505,-99) , 
3, 247.841, 0, 0, 0.507719,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463901,-99) , 
2, 1.87523, 0, 0, 0.495169,-99) , 
3, 192.823, 1, 0, 0.50343,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.0509159);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 108.51, 0, 1, 0.518416,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52654,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484008,-99) , 
3, 65.6269, 1, 0, 0.492891,-99) , 
2, 3.12508, 0, 0, 0.500562,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.574393,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491682,-99) , 
1, 265.562, 0, 0, 0.511285,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.419501,-99) , 
0, 155.37, 1, 0, 0.497126,-99) , 
1, 181.992, 1, 0, 0.498855,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.0262113);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.553053,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510435,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49073,-99) , 
0, 113.795, 0, 0, 0.500904,-99) , 
0, 185.122, 0, 0, 0.504968,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488145,-99) , 
1, 281.109, 1, 0, 0.503331,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.0250695);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 82.7459, 1, 1, 0.525596,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52554,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494507,-99) , 
2, 2.72891, 0, 0, 0.499446,-99) , 
0, 102.557, 1, 0, 0.507699,-99) , 
NN(
NN(
0, 
0, 
-1, 207.925, 0, 1, 0.520948,-99) , 
NN(
0, 
0, 
-1, 54.0389, 0, -1, 0.492069,-99) , 
3, 161.759, 0, 0, 0.499003,-99) , 
2, 2.86395, 1, 0, 0.503332,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.0242895);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 102.557, 1, 1, 0.511315,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486535,-99) , 
3, 257.423, 1, 0, 0.508648,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530941,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530383,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493068,-99) , 
0, 154.805, 0, 0, 0.498559,-99) , 
2, 3.94417, 0, 0, 0.502261,-99) , 
2, 2.86395, 1, 0, 0.50544,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.0172768);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515926,-99) , 
NN(
NN(
0, 
0, 
-1, 213.347, 0, 1, 0.508136,-99) , 
NN(
0, 
0, 
-1, 59.5858, 1, -1, 0.492249,-99) , 
3, 73.5647, 0, 0, 0.503683,-99) , 
3, 257.038, 0, 0, 0.504627,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.0185585);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542914,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52342,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496319,-99) , 
1, 225.956, 0, 0, 0.500349,-99) , 
0, 185.122, 0, 0, 0.503658,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492204,-99) , 
1, 281.109, 1, 0, 0.502543,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.0189595);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538305,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506348,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479559,-99) , 
1, 134.055, 0, 0, 0.503609,-99) , 
0, 185.122, 0, 0, 0.506305,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496843,-99) , 
1, 281.109, 1, 0, 0.505384,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.0142354);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511863,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521596,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50907,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496002,-99) , 
0, 101.912, 1, 0, 0.500013,-99) , 
3, 208.105, 0, 0, 0.501581,-99) , 
3, 257.038, 0, 0, 0.502374,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.0187217);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525043,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504147,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474623,-99) , 
0, 185.122, 1, 0, 0.501702,-99) , 
3, 165.296, 0, 0, 0.504052,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51522,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482302,-99) , 
3, 247.875, 0, 0, 0.498305,-99) , 
3, 192.823, 1, 0, 0.503037,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.00940638);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 3.42608, 0, 1, 0.512628,-99) , 
NN(
0, 
0, 
-1, 185.734, 1, -1, 0.49726,-99) , 
2, 3.15328, 0, 0, 0.500269,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495029,-99) , 
2, 3.67408, 1, 0, 0.49978,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.0400148);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510743,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471923,-99) , 
2, 3.67598, 1, 0, 0.507029,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452746,-99) , 
1, 281.109, 1, 0, 0.5022,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5321,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477729,-99) , 
0, 90.5905, 1, 0, 0.507738,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457212,-99) , 
0, 62.2868, 0, 0, 0.49924,-99) , 
0, 101.912, 0, 0, 0.501297,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.0199084);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506894,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532409,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501802,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487669,-99) , 
1, 189.196, 0, 0, 0.492917,-99) , 
0, 185.122, 0, 0, 0.495981,-99) , 
1, 281.109, 0, 0, 0.497042,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.0134973);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504828,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526086,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495777,-99) , 
3, 257.271, 0, 0, 0.497911,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475261,-99) , 
2, 1.07011, 0, 0, 0.496499,-99) , 
2, 3.67408, 0, 0, 0.497275,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.0408331);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513367,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509322,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488654,-99) , 
1, 158.392, 0, 0, 0.498426,-99) , 
3, 65.0367, 1, 0, 0.501785,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.568256,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49374,-99) , 
1, 265.562, 0, 0, 0.511342,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.420792,-99) , 
0, 155.37, 1, 0, 0.497421,-99) , 
1, 181.992, 1, 0, 0.499617,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.030152);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527027,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491907,-99) , 
0, 90.5905, 1, 0, 0.511298,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472627,-99) , 
0, 62.2868, 0, 0, 0.5048,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517877,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495627,-99) , 
3, 128.608, 0, 0, 0.504689,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456029,-99) , 
1, 281.109, 1, 0, 0.500375,-99) , 
0, 101.912, 1, 0, 0.501724,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.0224787);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536613,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505245,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486783,-99) , 
0, 154.805, 1, 0, 0.502483,-99) , 
3, 116.376, 0, 0, 0.506511,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538782,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497381,-99) , 
3, 244.743, 0, 0, 0.504532,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458449,-99) , 
2, 1.43927, 0, 0, 0.498773,-99) , 
3, 128.608, 1, 0, 0.503262,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.0200049);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 129.915, 1, 1, 0.513576,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501362,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487637,-99) , 
2, 3.27479, 1, 0, 0.497936,-99) , 
3, 119.43, 0, 0, 0.503538,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533192,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487404,-99) , 
3, 247.841, 0, 0, 0.506203,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476666,-99) , 
2, 1.87523, 0, 0, 0.497698,-99) , 
3, 192.823, 1, 0, 0.502509,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.0153505);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516376,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518187,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476433,-99) , 
2, 3.43616, 0, 0, 0.498617,-99) , 
2, 3.77055, 0, 0, 0.505454,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523884,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497832,-99) , 
2, 3.16614, 0, 0, 0.499873,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48435,-99) , 
2, 1.10869, 0, 0, 0.498697,-99) , 
2, 3.26902, 0, 0, 0.500075,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.0352824);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 265.562, 0, 1, 0.516877,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437163,-99) , 
0, 155.37, 1, 0, 0.504666,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509439,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489897,-99) , 
1, 127.376, 0, 0, 0.50598,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502315,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475523,-99) , 
3, 129.219, 0, 0, 0.485796,-99) , 
1, 167.832, 1, 0, 0.500077,-99) , 
1, 181.992, 0, 0, 0.502356,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.0246082);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507529,-99) , 
NN(
NN(
0, 
0, 
-1, 106.15, 1, 1, 0.539397,-99) , 
NN(
0, 
0, 
-1, 230.64, 1, -1, 0.490882,-99) , 
1, 264.179, 0, 0, 0.496682,-99) , 
0, 185.122, 0, 0, 0.49759,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.0126138);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5344,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522816,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497806,-99) , 
0, 153.417, 0, 0, 0.49969,-99) , 
0, 185.122, 0, 0, 0.502374,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491932,-99) , 
1, 281.109, 1, 0, 0.501365,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.0174919);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 185.122, 0, 1, 0.507591,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503601,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464438,-99) , 
1, 254.132, 0, 0, 0.482847,-99) , 
1, 233.902, 1, 0, 0.504602,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495085,-99) , 
1, 281.109, 1, 0, 0.503682,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.00656543);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529464,-99) , 
NN(
0, 
0, 
-1, 29.8827, 0, -1, 0.498884,-99) , 
3, 208.105, 0, 0, 0.5011,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495372,-99) , 
3, 257.038, 1, 0, 0.50066,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.00842483);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527828,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501595,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483391,-99) , 
3, 29.8827, 0, 0, 0.500525,-99) , 
3, 208.105, 0, 0, 0.502504,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497013,-99) , 
3, 257.038, 1, 0, 0.502082,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.0259104);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532823,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489738,-99) , 
0, 91.3455, 1, 0, 0.511147,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482179,-99) , 
0, 74.1734, 0, 0, 0.502332,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505631,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477922,-99) , 
1, 243.341, 1, 0, 0.50333,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46238,-99) , 
1, 281.109, 1, 0, 0.499713,-99) , 
0, 101.912, 1, 0, 0.500511,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.0164237);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531209,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494819,-99) , 
1, 190.707, 0, 0, 0.511194,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488651,-99) , 
0, 74.1734, 0, 0, 0.504333,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500305,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475464,-99) , 
2, 3.67598, 1, 0, 0.497928,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468827,-99) , 
1, 281.109, 1, 0, 0.495359,-99) , 
0, 101.912, 1, 0, 0.498095,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.0250227);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521693,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515848,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466645,-99) , 
2, 2.83665, 1, 0, 0.499753,-99) , 
2, 3.13025, 0, 0, 0.50587,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501313,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487731,-99) , 
2, 2.86617, 0, 0, 0.494608,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472919,-99) , 
1, 281.109, 1, 0, 0.492694,-99) , 
0, 101.912, 1, 0, 0.496711,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.0256813);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523252,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493315,-99) , 
0, 91.3455, 1, 0, 0.508179,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48974,-99) , 
0, 74.1734, 0, 0, 0.502567,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533366,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483677,-99) , 
2, 2.72771, 0, 0, 0.507619,-99) , 
NN(
0, 
0, 
-1, 181.161, 1, -1, 0.490045,-99) , 
3, 192.823, 0, 0, 0.493172,-99) , 
0, 101.912, 1, 0, 0.496036,-99)    );
   return;
};
 
// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
