// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.06/01       [394753]
Creator        : kskovpen
Date           : Tue Jan 10 22:31:06 2017
Host           : Linux vocms0315.cern.ch 2.6.32-573.26.1.el6.x86_64 #1 SMP Wed May 4 09:23:05 CEST 2016 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /storage_mnt/storage/user/kskovpen/analysis/tHFCNC/CMSSW_8_0_12/src/TopKinFit/test/Validation/TopHLepbb/MVA
Training events: 58285
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
SeparationType: "giniindex" [Separation criterion for node splitting]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
MinNodeSize: "5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "2" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 4
HiggsRecMTruth                HiggsRecMTruth                HiggsRecMTruth                HiggsRecMTruth                                                  'F'    [19.1486473083,1543.15856934]
TopLepRecMTruth               TopLepRecMTruth               TopLepRecMTruth               TopLepRecMTruth                                                 'F'    [81.3647842407,2632.6171875]
HiggsTopLepRecDrTruth         HiggsTopLepRecDrTruth         HiggsTopLepRecDrTruth         HiggsTopLepRecDrTruth                                           'F'    [0.0102342702448,9.00871086121]
TopLepRecPtTruth              TopLepRecPtTruth              TopLepRecPtTruth              TopLepRecPtTruth                                                'F'    [1.07737672329,2310.08178711]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTNode
   
#ifndef BDTNode__def
#define BDTNode__def
   
class BDTNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 4 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "HiggsRecMTruth", "TopLepRecMTruth", "HiggsTopLepRecDrTruth", "TopLepRecPtTruth" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[4];
   double fVmax[4];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[4];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadBDT::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(0.733233618214797);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 130.322, 0, 1, 0.770477,-99) , 
NN(
0, 
0, 
-1, 301.464, 1, -1, 0.288874,-99) , 
1, 232.973, 1, 0, 0.668442,-99) , 
NN(
0, 
0, 
-1, 202.853, 1, -1, 0.0375206,-99) , 
0, 164.292, 1, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.437281);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.99535, 0, 1, 0.815519,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548901,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.252762,-99) , 
0, 81.3499, 0, 0, 0.502581,-99) , 
3, 220.983, 0, 0, 0.582177,-99) , 
NN(
0, 
0, 
-1, 202.853, 1, -1, 0.0750637,-99) , 
0, 164.292, 1, 0, 0.46505,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.372926);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.894176,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.432347,-99) , 
2, 1.99535, 0, 0, 0.740582,-99) , 
NN(
0, 
0, 
-1, 143.551, 1, -1, 0.426091,-99) , 
3, 220.983, 0, 0, 0.499646,-99) , 
NN(
0, 
0, 
-1, 202.853, 1, -1, 0.111639,-99) , 
0, 164.292, 1, 0, 0.419307,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.376811);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.719879,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474949,-99) , 
3, 130.322, 0, 0, 0.600973,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.187269,-99) , 
1, 308.668, 1, 0, 0.566042,-99) , 
NN(
0, 
0, 
-1, 202.853, 1, -1, 0.154311,-99) , 
0, 164.292, 1, 0, 0.487859,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.307904);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 183.495, 0, 1, 0.710284,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524917,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.218473,-99) , 
0, 143.557, 1, 0, 0.485393,-99) , 
2, 3.01627, 0, 0, 0.575388,-99) , 
NN(
0, 
0, 
-1, 202.853, 1, -1, 0.210092,-99) , 
0, 164.292, 1, 0, 0.510611,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.266518);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 183.495, 0, 1, 0.641313,-99) , 
NN(
0, 
0, 
-1, 200.352, 1, -1, 0.424518,-99) , 
2, 3.00973, 0, 0, 0.509648,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.110851,-99) , 
1, 324.341, 1, 0, 0.469662,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.193718);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 194.945, 0, 1, 0.549745,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.216377,-99) , 
1, 310.075, 1, 0, 0.520245,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0673132,-99) , 
0, 236.864, 1, 0, 0.488706,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.250389);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.666461,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.602621,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.410715,-99) , 
3, 221.397, 0, 0, 0.451738,-99) , 
2, 3.44364, 0, 0, 0.480242,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0805428,-99) , 
0, 236.864, 1, 0, 0.454255,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.232577);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.603442,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.403234,-99) , 
0, 92.1837, 0, 0, 0.565156,-99) , 
NN(
0, 
0, 
-1, 143.554, 1, -1, 0.412815,-99) , 
1, 195.828, 1, 0, 0.502968,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.101141,-99) , 
0, 236.864, 1, 0, 0.478835,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.220432);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.56914,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.347817,-99) , 
2, 1.30414, 0, 0, 0.545743,-99) , 
NN(
0, 
0, 
-1, 137.817, 0, -1, 0.35075,-99) , 
0, 143.554, 1, 0, 0.505567,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.124332,-99) , 
0, 236.864, 1, 0, 0.484221,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.185931);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.72032,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.424419,-99) , 
2, 2.27146, 0, 0, 0.591717,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500845,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.337717,-99) , 
0, 136.392, 1, 0, 0.453771,-99) , 
3, 194.945, 0, 0, 0.487363,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.206974,-99) , 
1, 324.341, 1, 0, 0.464689,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.179649);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.663715,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539064,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.421546,-99) , 
3, 173.818, 0, 0, 0.450666,-99) , 
3, 330.935, 0, 0, 0.46751,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.171966,-99) , 
0, 236.864, 1, 0, 0.452646,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.142964);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.649075,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.590652,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458223,-99) , 
2, 3.44364, 0, 0, 0.475728,-99) , 
3, 324.19, 0, 0, 0.489213,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.248831,-99) , 
1, 324.341, 1, 0, 0.470832,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.137676);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543294,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.417425,-99) , 
0, 81.4365, 0, 0, 0.527591,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.387628,-99) , 
1, 139.21, 0, 0, 0.510728,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.2765,-99) , 
1, 324.341, 1, 0, 0.493284,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.11653);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529197,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.435237,-99) , 
0, 99.2287, 0, 0, 0.5027,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.330684,-99) , 
0, 206.012, 1, 0, 0.492125,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.30487,-99) , 
1, 324.341, 1, 0, 0.478479,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.122882);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534117,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.420742,-99) , 
2, 1.5249, 0, 0, 0.51898,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.386647,-99) , 
1, 133.429, 0, 0, 0.50137,-99) , 
NN(
0, 
0, 
-1, 164.292, 1, -1, 0.419931,-99) , 
1, 202.853, 1, 0, 0.471023,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.114644);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.615322,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499247,-99) , 
2, 3.13567, 0, 0, 0.53317,-99) , 
NN(
0, 
0, 
-1, 0.964959, 0, -1, 0.391382,-99) , 
2, 1.83314, 0, 0, 0.500103,-99) , 
NN(
0, 
0, 
-1, 3.01556, 1, -1, 0.435539,-99) , 
3, 111.03, 0, 0, 0.47258,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.0880358);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 185.557, 1, 1, 0.597717,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512139,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.414414,-99) , 
0, 141.621, 1, 0, 0.489169,-99) , 
3, 259.567, 0, 0, 0.502657,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.3761,-99) , 
1, 324.341, 1, 0, 0.493808,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.080861);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.590848,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.591629,-99) , 
NN(
0, 
0, 
-1, 216.769, 1, -1, 0.46721,-99) , 
2, 3.87173, 0, 0, 0.474678,-99) , 
3, 330.935, 0, 0, 0.483246,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.0857055);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.669142,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517312,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.439825,-99) , 
3, 79.5957, 0, 0, 0.495733,-99) , 
3, 330.935, 0, 0, 0.505928,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.368514,-99) , 
2, 0.867232, 0, 0, 0.498218,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.0483934);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 185.557, 1, 1, 0.561279,-99) , 
NN(
0, 
0, 
-1, 202.858, 1, -1, 0.487461,-99) , 
3, 259.567, 0, 0, 0.496484,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.399534,-99) , 
1, 324.341, 1, 0, 0.489765,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.0442961);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.641562,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50348,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.403905,-99) , 
1, 324.341, 1, 0, 0.497117,-99) , 
3, 330.935, 0, 0, 0.505464,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.391744,-99) , 
2, 0.867232, 0, 0, 0.499108,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.0450833);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.582001,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502343,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.399005,-99) , 
0, 66.1927, 0, 0, 0.494827,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.329887,-99) , 
0, 216.769, 1, 0, 0.485092,-99) , 
2, 3.86672, 0, 0, 0.490523,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.0520234);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.570994,-99) , 
NN(
0, 
0, 
-1, 216.769, 1, -1, 0.476676,-99) , 
2, 3.86672, 0, 0, 0.481947,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.0424968);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.635469,-99) , 
NN(
0, 
0, 
-1, 32.4847, 0, -1, 0.490268,-99) , 
3, 330.935, 0, 0, 0.498623,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.406197,-99) , 
2, 0.867232, 0, 0, 0.493488,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.0433288);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.625569,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506564,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.406535,-99) , 
3, 32.4847, 0, 0, 0.500891,-99) , 
3, 330.935, 0, 0, 0.508029,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.416487,-99) , 
2, 0.867232, 0, 0, 0.502959,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.040379);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.574865,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497208,-99) , 
1, 231.205, 0, 0, 0.506029,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.422718,-99) , 
1, 266.468, 1, 0, 0.499476,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.425709,-99) , 
1, 324.341, 1, 0, 0.494417,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.0689817);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.663462,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.568682,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4908,-99) , 
2, 3.80552, 0, 0, 0.496966,-99) , 
3, 255.507, 0, 0, 0.51106,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.55591,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483507,-99) , 
3, 107.481, 1, 0, 0.519946,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.37683,-99) , 
3, 222.625, 1, 0, 0.463283,-99) , 
2, 1.72423, 0, 0, 0.502544,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.0753326);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.64789,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518015,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.433172,-99) , 
3, 37.4239, 0, 0, 0.511486,-99) , 
3, 255.507, 0, 0, 0.522924,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550679,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486851,-99) , 
2, 1.23659, 1, 0, 0.519883,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.393161,-99) , 
3, 222.625, 1, 0, 0.469893,-99) , 
2, 1.72423, 0, 0, 0.513495,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.0605164);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520525,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.444491,-99) , 
1, 134.25, 0, 0, 0.512823,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.431129,-99) , 
1, 266.468, 1, 0, 0.506421,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.433816,-99) , 
1, 324.341, 1, 0, 0.501454,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.0810516);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548108,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514816,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.418919,-99) , 
3, 221.081, 1, 0, 0.501897,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.563356,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.432156,-99) , 
3, 158.111, 0, 0, 0.467856,-99) , 
2, 3.01556, 1, 0, 0.489102,-99) , 
3, 330.935, 0, 0, 0.493226,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.0675181);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.637332,-99) , 
NN(
0, 
0, 
-1, 85.8827, 0, -1, 0.485147,-99) , 
3, 255.507, 0, 0, 0.496421,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536595,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.445349,-99) , 
3, 131.964, 1, 0, 0.485761,-99) , 
NN(
0, 
0, 
-1, 1.33644, 0, -1, 0.417149,-99) , 
1, 202.853, 1, 0, 0.458321,-99) , 
2, 2.15273, 0, 0, 0.486404,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.0591398);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.621586,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516477,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47186,-99) , 
3, 85.8827, 0, 0, 0.502022,-99) , 
3, 255.507, 0, 0, 0.510811,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500929,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45875,-99) , 
1, 202.853, 1, 0, 0.484838,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.428521,-99) , 
2, 1.13248, 0, 0, 0.466086,-99) , 
2, 2.15273, 0, 0, 0.499075,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.0414566);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.571069,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504982,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.428116,-99) , 
0, 66.1927, 0, 0, 0.499403,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.353148,-99) , 
0, 216.769, 1, 0, 0.490946,-99) , 
2, 3.86672, 0, 0, 0.495388,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.0454416);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.560886,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502753,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461437,-99) , 
0, 132.054, 1, 0, 0.490541,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.362675,-99) , 
0, 216.769, 1, 0, 0.483186,-99) , 
2, 3.86672, 0, 0, 0.487485,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.0595703);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549665,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.563928,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480319,-99) , 
0, 169.69, 0, 0, 0.485889,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.373242,-99) , 
0, 216.769, 1, 0, 0.479444,-99) , 
2, 3.86672, 0, 0, 0.483322,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.0473691);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.60951,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525518,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488108,-99) , 
3, 170.688, 0, 0, 0.495222,-99) , 
3, 255.507, 0, 0, 0.503584,-99) , 
NN(
0, 
0, 
-1, 112.759, 1, -1, 0.470059,-99) , 
2, 2.15273, 0, 0, 0.49479,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.031777);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.59818,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548836,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498024,-99) , 
2, 3.78514, 0, 0, 0.502561,-99) , 
3, 255.507, 0, 0, 0.509528,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508578,-99) , 
NN(
0, 
0, 
-1, 1.03046, 0, -1, 0.466569,-99) , 
3, 112.759, 1, 0, 0.481873,-99) , 
2, 2.15273, 0, 0, 0.502275,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0349489);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 255.507, 0, 1, 0.515005,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51062,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475836,-99) , 
2, 1.72519, 1, 0, 0.49501,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455926,-99) , 
2, 1.03046, 0, 0, 0.484017,-99) , 
2, 2.15273, 0, 0, 0.506881,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.0266712);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544333,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.555306,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497782,-99) , 
3, 189.518, 0, 0, 0.502575,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505722,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.422372,-99) , 
3, 262.812, 0, 0, 0.460961,-99) , 
3, 220.929, 1, 0, 0.49771,-99) , 
3, 330.935, 0, 0, 0.500911,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0306392);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 231.209, 0, 1, 0.511589,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.446592,-99) , 
1, 278.037, 1, 0, 0.507943,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465705,-99) , 
1, 324.341, 1, 0, 0.505079,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0412943);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.571808,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518738,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49133,-99) , 
2, 2.80572, 1, 0, 0.50004,-99) , 
3, 255.507, 0, 0, 0.505222,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536403,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476591,-99) , 
2, 1.23826, 1, 0, 0.495855,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455887,-99) , 
3, 222.625, 1, 0, 0.482483,-99) , 
2, 2.15273, 0, 0, 0.499259,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.0433293);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 3.06191, 0, 1, 0.548207,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509085,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454486,-99) , 
3, 44.5074, 0, 0, 0.502704,-99) , 
3, 183.495, 0, 0, 0.512029,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525847,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499277,-99) , 
3, 74.8208, 1, 0, 0.514722,-99) , 
NN(
0, 
0, 
-1, 1.11202, 0, -1, 0.471096,-99) , 
3, 111.466, 1, 0, 0.488636,-99) , 
2, 2.58123, 0, 0, 0.502833,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.0364415);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543109,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511945,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485397,-99) , 
2, 3.01556, 1, 0, 0.501702,-99) , 
NN(
0, 
0, 
-1, 262.812, 0, -1, 0.457737,-99) , 
3, 220.929, 1, 0, 0.496572,-99) , 
3, 330.935, 0, 0, 0.499749,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.044049);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543468,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511601,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47279,-99) , 
0, 94.4192, 0, 0, 0.502107,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.390457,-99) , 
0, 216.769, 1, 0, 0.495774,-99) , 
2, 3.86672, 0, 0, 0.498404,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.0314881);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529556,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537156,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490745,-99) , 
3, 189.518, 0, 0, 0.494602,-99) , 
NN(
0, 
0, 
-1, 262.812, 0, -1, 0.461309,-99) , 
3, 220.929, 1, 0, 0.490727,-99) , 
3, 330.935, 0, 0, 0.493368,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.06744);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53995,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.567613,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49076,-99) , 
1, 232.973, 0, 0, 0.507499,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527085,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.330557,-99) , 
1, 202.853, 1, 0, 0.448453,-99) , 
0, 150.895, 1, 0, 0.496706,-99) , 
2, 3.86672, 0, 0, 0.499091,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0880072);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.602011,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516789,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.432045,-99) , 
0, 136.044, 1, 0, 0.500931,-99) , 
0, 163.388, 0, 0, 0.513409,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537546,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454166,-99) , 
0, 129.729, 1, 0, 0.517279,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.336468,-99) , 
0, 164.292, 1, 0, 0.490207,-99) , 
1, 202.853, 1, 0, 0.504936,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0402379);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.569067,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498157,-99) , 
2, 3.06191, 0, 0, 0.533745,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504393,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476487,-99) , 
3, 96.6233, 0, 0, 0.491831,-99) , 
3, 183.495, 0, 0, 0.500362,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506664,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467726,-99) , 
3, 127.16, 1, 0, 0.492571,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454302,-99) , 
3, 221.397, 1, 0, 0.482224,-99) , 
2, 2.58123, 0, 0, 0.493225,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0359949);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525178,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.559378,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49075,-99) , 
3, 114.739, 0, 0, 0.49927,-99) , 
NN(
0, 
0, 
-1, 146.155, 0, -1, 0.480093,-99) , 
3, 126.707, 1, 0, 0.490655,-99) , 
3, 330.935, 0, 0, 0.493003,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.0329997);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 3.06191, 0, 1, 0.540555,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506563,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476643,-99) , 
3, 131.367, 1, 0, 0.498159,-99) , 
3, 183.495, 0, 0, 0.506784,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508126,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491341,-99) , 
2, 1.74167, 1, 0, 0.496535,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459514,-99) , 
2, 1.11204, 0, 0, 0.488602,-99) , 
2, 2.58123, 0, 0, 0.49963,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.0352257);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511187,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471447,-99) , 
1, 146.922, 0, 0, 0.503978,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443451,-99) , 
1, 278.037, 1, 0, 0.500602,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469639,-99) , 
1, 324.341, 1, 0, 0.498532,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.0533373);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.581616,-99) , 
NN(
0, 
0, 
-1, 129.209, 1, -1, 0.488161,-99) , 
0, 163.388, 0, 0, 0.499653,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516444,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465507,-99) , 
0, 136.64, 1, 0, 0.507975,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.358229,-99) , 
0, 164.292, 1, 0, 0.485882,-99) , 
1, 202.853, 1, 0, 0.494632,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.048925);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.568583,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512701,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472629,-99) , 
0, 129.209, 1, 0, 0.501493,-99) , 
0, 163.388, 0, 0, 0.509716,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505116,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475937,-99) , 
3, 221.397, 1, 0, 0.499076,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.370582,-99) , 
0, 164.292, 1, 0, 0.480224,-99) , 
1, 202.853, 1, 0, 0.49897,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.0489361);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.556544,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513693,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470286,-99) , 
0, 108.704, 0, 0, 0.496102,-99) , 
0, 163.388, 0, 0, 0.503493,-99) , 
NN(
0, 
0, 
-1, 164.292, 1, -1, 0.475872,-99) , 
1, 202.853, 1, 0, 0.49343,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.0303317);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522923,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505153,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443507,-99) , 
0, 156.614, 1, 0, 0.495787,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457821,-99) , 
3, 32.4847, 0, 0, 0.493652,-99) , 
3, 330.935, 0, 0, 0.495637,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.0345781);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515352,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509559,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475397,-99) , 
3, 126.99, 1, 0, 0.49396,-99) , 
NN(
0, 
0, 
-1, 95.2975, 0, -1, 0.480905,-99) , 
2, 3.01556, 1, 0, 0.489092,-99) , 
3, 330.935, 0, 0, 0.490872,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.0370443);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.563785,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506676,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483582,-99) , 
3, 146.464, 0, 0, 0.490493,-99) , 
3, 255.507, 0, 0, 0.496317,-99) , 
NN(
0, 
0, 
-1, 211.07, 1, -1, 0.476784,-99) , 
2, 1.72423, 0, 0, 0.492848,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.0341346);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525474,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509294,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481057,-99) , 
0, 103.828, 0, 0, 0.499708,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.413293,-99) , 
0, 216.769, 1, 0, 0.495039,-99) , 
2, 3.86672, 0, 0, 0.4967,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.0410707);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.557639,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491527,-99) , 
3, 117.226, 0, 0, 0.519608,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504036,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459614,-99) , 
2, 3.01848, 1, 0, 0.488021,-99) , 
2, 3.19338, 0, 0, 0.49904,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521044,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487727,-99) , 
2, 1.23905, 1, 0, 0.494194,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466714,-99) , 
3, 221.397, 1, 0, 0.486797,-99) , 
2, 2.58123, 0, 0, 0.494216,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.0371435);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522537,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536913,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494246,-99) , 
1, 232.973, 0, 0, 0.503478,-99) , 
NN(
0, 
0, 
-1, 202.853, 1, -1, 0.454737,-99) , 
0, 150.895, 1, 0, 0.494794,-99) , 
2, 3.86672, 0, 0, 0.496307,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.0440239);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.564836,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51121,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474251,-99) , 
0, 129.209, 1, 0, 0.500883,-99) , 
0, 163.388, 0, 0, 0.508713,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510411,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483987,-99) , 
0, 122.817, 1, 0, 0.501634,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.412329,-99) , 
0, 164.292, 1, 0, 0.488753,-99) , 
1, 202.853, 1, 0, 0.501458,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.0367832);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.553986,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510894,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478153,-99) , 
3, 130.322, 1, 0, 0.496026,-99) , 
0, 163.388, 0, 0, 0.503109,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501319,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484768,-99) , 
2, 1.73218, 0, 0, 0.497939,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.423036,-99) , 
0, 164.292, 1, 0, 0.487166,-99) , 
1, 202.853, 1, 0, 0.497314,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.0269464);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54488,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501535,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466033,-99) , 
1, 139.328, 0, 0, 0.495179,-99) , 
0, 163.388, 0, 0, 0.501245,-99) , 
NN(
0, 
0, 
-1, 164.292, 1, -1, 0.483823,-99) , 
1, 202.853, 1, 0, 0.494912,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.0174071);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521124,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50018,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460433,-99) , 
0, 156.614, 1, 0, 0.494194,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463766,-99) , 
3, 32.4847, 0, 0, 0.492486,-99) , 
3, 330.935, 0, 0, 0.494419,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.0276123);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516778,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510325,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505084,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484207,-99) , 
3, 189.521, 0, 0, 0.487898,-99) , 
2, 1.30323, 1, 0, 0.489859,-99) , 
3, 330.935, 0, 0, 0.491675,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.0376665);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530241,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438962,-99) , 
3, 61.8832, 0, 0, 0.510483,-99) , 
NN(
0, 
0, 
-1, 3.04476, 1, -1, 0.491513,-99) , 
2, 3.13221, 0, 0, 0.49692,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510685,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.43401,-99) , 
3, 207.421, 1, 0, 0.474639,-99) , 
2, 1.29573, 0, 0, 0.494442,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.0280828);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545961,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488785,-99) , 
3, 114.908, 0, 0, 0.517659,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505622,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452544,-99) , 
0, 143.557, 1, 0, 0.499959,-99) , 
0, 164.292, 0, 0, 0.502131,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50127,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443284,-99) , 
3, 207.421, 1, 0, 0.47404,-99) , 
2, 1.29573, 0, 0, 0.499008,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.019296);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538992,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495804,-99) , 
3, 114.908, 0, 0, 0.517603,-99) , 
NN(
0, 
0, 
-1, 143.557, 1, -1, 0.494435,-99) , 
0, 164.292, 0, 0, 0.497277,-99) , 
NN(
0, 
0, 
-1, 207.421, 1, -1, 0.473593,-99) , 
2, 1.29573, 0, 0, 0.494645,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.0193344);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 114.908, 0, 1, 0.517564,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503426,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464306,-99) , 
0, 143.557, 1, 0, 0.499259,-99) , 
0, 164.292, 0, 0, 0.501504,-99) , 
NN(
0, 
0, 
-1, 207.421, 1, -1, 0.478406,-99) , 
2, 1.29573, 0, 0, 0.498938,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.0288489);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522514,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521243,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491295,-99) , 
0, 139.676, 0, 0, 0.498939,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503159,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470819,-99) , 
2, 3.30095, 0, 0, 0.485826,-99) , 
2, 3.01556, 1, 0, 0.494068,-99) , 
3, 330.935, 0, 0, 0.495981,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.0371441);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 139.676, 0, 1, 0.50737,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469844,-99) , 
2, 1.15288, 0, 0, 0.502116,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529441,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471247,-99) , 
2, 3.24247, 0, 0, 0.498833,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450535,-99) , 
3, 61.8832, 0, 0, 0.489954,-99) , 
2, 3.00973, 1, 0, 0.497744,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.0198307);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51487,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513054,-99) , 
NN(
0, 
0, 
-1, 220.929, 1, -1, 0.490778,-99) , 
2, 1.30323, 1, 0, 0.492728,-99) , 
3, 330.935, 0, 0, 0.494213,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.0294155);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54565,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494193,-99) , 
3, 221.148, 0, 0, 0.501539,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511189,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462756,-99) , 
0, 70.9856, 0, 0, 0.491541,-99) , 
0, 91.7206, 0, 0, 0.499436,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506471,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458065,-99) , 
3, 207.421, 1, 0, 0.483784,-99) , 
2, 1.29573, 0, 0, 0.497695,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.0294658);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519527,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491525,-99) , 
3, 111.204, 0, 0, 0.506796,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503837,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470076,-99) , 
0, 70.9856, 0, 0, 0.490147,-99) , 
0, 91.7206, 0, 0, 0.503294,-99) , 
NN(
0, 
0, 
-1, 207.421, 1, -1, 0.483312,-99) , 
2, 1.29573, 0, 0, 0.501072,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.0338063);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 91.7206, 1, 1, 0.509996,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515289,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449598,-99) , 
3, 149.155, 0, 0, 0.493858,-99) , 
3, 126.716, 1, 0, 0.503937,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512987,-99) , 
NN(
0, 
0, 
-1, 1.62529, 1, -1, 0.477264,-99) , 
2, 2.83676, 0, 0, 0.488053,-99) , 
3, 220.983, 1, 0, 0.501163,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.0320952);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550237,-99) , 
NN(
0, 
0, 
-1, 3.44364, 1, -1, 0.495802,-99) , 
3, 331.092, 0, 0, 0.499418,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533417,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.432339,-99) , 
3, 130.651, 1, 0, 0.485204,-99) , 
0, 91.7206, 0, 0, 0.496479,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.0472815);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518265,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47926,-99) , 
0, 152.887, 1, 0, 0.510044,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480351,-99) , 
2, 3.43823, 1, 0, 0.506376,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525421,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440232,-99) , 
3, 130.651, 1, 0, 0.48481,-99) , 
0, 91.7206, 0, 0, 0.501922,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.0438441);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.569508,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45582,-99) , 
1, 202.853, 1, 0, 0.523377,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536299,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496649,-99) , 
0, 123.474, 1, 0, 0.524124,-99) , 
NN(
0, 
0, 
-1, 211.345, 1, -1, 0.4863,-99) , 
1, 232.973, 0, 0, 0.4945,-99) , 
0, 164.292, 0, 0, 0.498211,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.0264283);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 331.092, 0, 1, 0.508606,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519332,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45629,-99) , 
3, 130.651, 1, 0, 0.489332,-99) , 
0, 91.7206, 0, 0, 0.504631,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.0305995);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54457,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51174,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491097,-99) , 
2, 3.0242, 0, 0, 0.498482,-99) , 
0, 163.388, 0, 0, 0.504091,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509635,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482125,-99) , 
2, 1.86703, 0, 0, 0.500185,-99) , 
NN(
0, 
0, 
-1, 3.29541, 0, -1, 0.473442,-99) , 
2, 3.00973, 1, 0, 0.490959,-99) , 
1, 202.853, 1, 0, 0.499321,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.025151);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536971,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506172,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485868,-99) , 
1, 179.749, 1, 0, 0.500658,-99) , 
0, 163.388, 0, 0, 0.505074,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508037,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489152,-99) , 
0, 115.906, 0, 0, 0.497278,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460618,-99) , 
0, 164.292, 1, 0, 0.492025,-99) , 
1, 202.853, 1, 0, 0.500334,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.0251985);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538379,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466873,-99) , 
1, 202.853, 1, 0, 0.509317,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530536,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497275,-99) , 
2, 3.4443, 0, 0, 0.501197,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46483,-99) , 
0, 143.557, 1, 0, 0.497303,-99) , 
0, 164.292, 0, 0, 0.49884,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.0153263);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519079,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520258,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503165,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47351,-99) , 
3, 220.929, 1, 0, 0.500119,-99) , 
2, 1.30323, 1, 0, 0.501884,-99) , 
3, 330.935, 0, 0, 0.503027,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.0102477);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515252,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524026,-99) , 
NN(
0, 
0, 
-1, 216.438, 1, -1, 0.496985,-99) , 
3, 252.336, 0, 0, 0.49877,-99) , 
3, 330.935, 0, 0, 0.499866,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.0263814);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.566459,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499578,-99) , 
0, 136.081, 0, 0, 0.507614,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500327,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451925,-99) , 
0, 206.863, 1, 0, 0.484099,-99) , 
0, 148.394, 1, 0, 0.503205,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529113,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454476,-99) , 
3, 93.4518, 0, 0, 0.491363,-99) , 
2, 3.43823, 1, 0, 0.501772,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.0314698);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 136.081, 0, 1, 0.512627,-99) , 
NN(
0, 
0, 
-1, 2.78505, 1, -1, 0.481918,-99) , 
0, 148.394, 1, 0, 0.50687,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522535,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461024,-99) , 
3, 93.4518, 0, 0, 0.491431,-99) , 
2, 3.43823, 1, 0, 0.505003,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.0185359);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536861,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478624,-99) , 
1, 202.853, 1, 0, 0.513218,-99) , 
NN(
NN(
0, 
0, 
-1, 308.668, 0, 1, 0.5028,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465876,-99) , 
0, 143.557, 1, 0, 0.498856,-99) , 
0, 164.292, 0, 0, 0.500691,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.0276459);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53225,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483251,-99) , 
1, 202.853, 1, 0, 0.512354,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527753,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495996,-99) , 
0, 116.672, 1, 0, 0.515142,-99) , 
NN(
0, 
0, 
-1, 211.345, 1, -1, 0.489696,-99) , 
1, 232.973, 0, 0, 0.495212,-99) , 
0, 164.292, 0, 0, 0.497401,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.0203077);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538191,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532156,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498577,-99) , 
3, 236.824, 0, 0, 0.501565,-99) , 
3, 331.092, 0, 0, 0.503993,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516557,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466646,-99) , 
3, 130.651, 1, 0, 0.49282,-99) , 
0, 91.7206, 0, 0, 0.501689,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.0325266);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515461,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489967,-99) , 
0, 152.887, 1, 0, 0.510126,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489252,-99) , 
2, 3.43823, 1, 0, 0.507554,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526146,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474998,-99) , 
2, 2.48049, 1, 0, 0.492568,-99) , 
0, 91.7206, 0, 0, 0.504464,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.0273421);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 137.817, 0, 1, 0.522742,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51862,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50398,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.405589,-99) , 
0, 148.495, 1, 0, 0.49611,-99) , 
0, 81.3531, 1, 0, 0.499527,-99) , 
0, 164.292, 0, 0, 0.502495,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.0384708);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53994,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498835,-99) , 
3, 137.817, 0, 0, 0.515917,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51319,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.412197,-99) , 
0, 148.495, 1, 0, 0.501098,-99) , 
NN(
0, 
0, 
-1, 220.983, 1, -1, 0.483887,-99) , 
0, 108.999, 0, 0, 0.493618,-99) , 
0, 164.292, 0, 0, 0.496467,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.0277641);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532455,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495867,-99) , 
1, 202.853, 1, 0, 0.517553,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521398,-99) , 
NN(
0, 
0, 
-1, 148.495, 1, -1, 0.488686,-99) , 
0, 81.3531, 1, 0, 0.493658,-99) , 
0, 164.292, 0, 0, 0.496712,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.0152146);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533007,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498813,-99) , 
2, 2.73864, 1, 0, 0.516275,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52551,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499579,-99) , 
2, 3.4443, 0, 0, 0.502714,-99) , 
NN(
0, 
0, 
-1, 124.43, 1, -1, 0.485495,-99) , 
1, 157.277, 0, 0, 0.498488,-99) , 
0, 164.292, 0, 0, 0.500761,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.026822);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 3.09578, 0, 1, 0.518996,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506526,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450445,-99) , 
3, 133.694, 1, 0, 0.501031,-99) , 
3, 147.656, 0, 0, 0.505708,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509227,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478292,-99) , 
2, 1.9888, 1, 0, 0.492762,-99) , 
3, 220.983, 1, 0, 0.503463,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.0175199);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 137.817, 0, 1, 0.511343,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520445,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495436,-99) , 
0, 116.672, 1, 0, 0.510506,-99) , 
NN(
0, 
0, 
-1, 211.345, 1, -1, 0.493212,-99) , 
1, 232.973, 0, 0, 0.496961,-99) , 
0, 164.292, 0, 0, 0.498799,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.0141677);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 221.148, 0, 1, 0.504883,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504079,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479848,-99) , 
0, 70.9856, 0, 0, 0.494256,-99) , 
0, 91.7206, 0, 0, 0.502656,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503213,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471441,-99) , 
3, 207.421, 1, 0, 0.488302,-99) , 
2, 1.29573, 0, 0, 0.501061,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.0300241);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530422,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493769,-99) , 
3, 130.322, 0, 0, 0.51035,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50261,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482382,-99) , 
3, 106.955, 1, 0, 0.490982,-99) , 
1, 162.353, 0, 0, 0.501633,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525633,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488616,-99) , 
0, 139.951, 0, 0, 0.498176,-99) , 
NN(
0, 
0, 
-1, 3.29541, 0, -1, 0.482522,-99) , 
2, 3.00973, 1, 0, 0.492796,-99) , 
1, 202.853, 1, 0, 0.498424,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.0211237);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507255,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452516,-99) , 
1, 266.468, 1, 0, 0.503168,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488011,-99) , 
1, 324.341, 1, 0, 0.502219,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501449,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47583,-99) , 
3, 207.421, 1, 0, 0.489432,-99) , 
2, 1.29573, 0, 0, 0.500798,-99)    );
   return;
};
 
// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
