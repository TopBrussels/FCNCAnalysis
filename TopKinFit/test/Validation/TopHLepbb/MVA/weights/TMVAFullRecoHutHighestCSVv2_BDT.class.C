// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.06/01       [394753]
Creator        : kskovpen
Date           : Thu Feb  2 15:30:17 2017
Host           : Linux vocms0301.cern.ch 2.6.32-642.11.1.el6.x86_64 #1 SMP Wed Nov 16 09:40:09 CET 2016 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /storage_mnt/storage/user/kskovpen/analysis/tHFCNC/CMSSW_8_0_25/src/TopKinFit/test/Validation/TopHLepbb/MVA
Training events: 198179
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
SeparationType: "giniindex" [Separation criterion for node splitting]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
MinNodeSize: "5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "2" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 4
HiggsRecMHighestCSVv2         HiggsRecMHighestCSVv2         HiggsRecMHighestCSVv2         HiggsRecMHighestCSVv2                                           'F'    [17.7511386871,3243.60961914]
TopLepRecMHighestCSVv2        TopLepRecMHighestCSVv2        TopLepRecMHighestCSVv2        TopLepRecMHighestCSVv2                                          'F'    [84.2207565308,2370.04174805]
HiggsTopLepRecDrHighestCSVv2  HiggsTopLepRecDrHighestCSVv2  HiggsTopLepRecDrHighestCSVv2  HiggsTopLepRecDrHighestCSVv2                                    'F'    [0.0100916922092,10.1237249374]
TopLepRecPtHighestCSVv2       TopLepRecPtHighestCSVv2       TopLepRecPtHighestCSVv2       TopLepRecPtHighestCSVv2                                         'F'    [0.270443707705,990.26751709]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTNode
   
#ifndef BDTNode__def
#define BDTNode__def
   
class BDTNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 4 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "HiggsRecMHighestCSVv2", "TopLepRecMHighestCSVv2", "HiggsTopLepRecDrHighestCSVv2", "TopLepRecPtHighestCSVv2" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[4];
   double fVmax[4];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[4];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadBDT::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(0.588482039876325);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 141.815, 0, 1, 0.691568,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.125254,-99) , 
1, 282.274, 1, 0, 0.632831,-99) , 
NN(
0, 
0, 
-1, 195.807, 1, -1, 0.0554164,-99) , 
0, 171.363, 1, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.466058);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 182.221, 0, 1, 0.75668,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529746,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.25419,-99) , 
1, 183.889, 1, 0, 0.405539,-99) , 
3, 141.815, 0, 0, 0.522149,-99) , 
NN(
0, 
0, 
-1, 195.807, 1, -1, 0.0955751,-99) , 
0, 171.363, 1, 0, 0.435936,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.328268);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 184.462, 1, 1, 0.729082,-99) , 
NN(
0, 
0, 
-1, 171.363, 1, -1, 0.354827,-99) , 
3, 188.841, 0, 0, 0.414189,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.428088);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.638656,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.282025,-99) , 
0, 76.9667, 0, 0, 0.581059,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.147845,-99) , 
0, 142.104, 1, 0, 0.530734,-99) , 
NN(
0, 
0, 
-1, 195.807, 1, -1, 0.168775,-99) , 
0, 171.363, 1, 0, 0.468078,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.360827);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 222.517, 0, 1, 0.717386,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.651736,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.389444,-99) , 
2, 3.38378, 0, 0, 0.442617,-99) , 
3, 141.699, 0, 0, 0.526189,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538554,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.307302,-99) , 
2, 3.28883, 0, 0, 0.364036,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.108224,-99) , 
0, 173.17, 1, 0, 0.304141,-99) , 
1, 193.069, 1, 0, 0.439112,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.307168);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.619746,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.427927,-99) , 
0, 90.1227, 0, 0, 0.565211,-99) , 
NN(
0, 
0, 
-1, 219.991, 1, -1, 0.311955,-99) , 
0, 134.66, 1, 0, 0.498125,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.157276,-99) , 
1, 301.918, 1, 0, 0.464722,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.154977);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 235.984, 0, 1, 0.528428,-99) , 
NN(
0, 
0, 
-1, 115.459, 0, -1, 0.295412,-99) , 
1, 229.338, 1, 0, 0.493908,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.202382,-99) , 
1, 301.918, 1, 0, 0.467107,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.175775);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.719825,-99) , 
NN(
0, 
0, 
-1, 301.918, 1, -1, 0.423538,-99) , 
3, 235.984, 0, 0, 0.445302,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.203198);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.62966,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460993,-99) , 
3, 94.5559, 0, 0, 0.564378,-99) , 
NN(
0, 
0, 
-1, 218.973, 1, -1, 0.424425,-99) , 
2, 2.90236, 0, 0, 0.504062,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.253119,-99) , 
1, 301.918, 1, 0, 0.482426,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.184427);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.580995,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.447466,-99) , 
1, 218.972, 1, 0, 0.558565,-99) , 
NN(
0, 
0, 
-1, 209.754, 1, -1, 0.406396,-99) , 
0, 134.66, 1, 0, 0.519718,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.293417,-99) , 
1, 301.918, 1, 0, 0.500797,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.109144);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.677871,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.634934,-99) , 
NN(
0, 
0, 
-1, 301.918, 1, -1, 0.464417,-99) , 
2, 3.8629, 0, 0, 0.480554,-99) , 
3, 235.984, 0, 0, 0.494469,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.12274);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 188.841, 0, 1, 0.550144,-99) , 
NN(
0, 
0, 
-1, 1.96242, 0, -1, 0.436225,-99) , 
2, 2.42093, 0, 0, 0.527969,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.345064,-99) , 
1, 301.918, 1, 0, 0.513166,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.0792757);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.63859,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512628,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.397399,-99) , 
1, 136.048, 0, 0, 0.498232,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.365939,-99) , 
1, 301.918, 1, 0, 0.488136,-99) , 
3, 235.984, 0, 0, 0.498434,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.0968174);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.6201,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51717,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.391947,-99) , 
1, 130.869, 0, 0, 0.50029,-99) , 
NN(
0, 
0, 
-1, 173.17, 1, -1, 0.433245,-99) , 
1, 193.069, 1, 0, 0.475861,-99) , 
3, 235.984, 0, 0, 0.485656,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.112639);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 3.44067, 0, 1, 0.537834,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510998,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.328459,-99) , 
1, 195.623, 1, 0, 0.431664,-99) , 
0, 135.668, 1, 0, 0.510279,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536112,-99) , 
NN(
0, 
0, 
-1, 54.1465, 0, -1, 0.430146,-99) , 
2, 3.86521, 0, 0, 0.444036,-99) , 
3, 94.5559, 0, 0, 0.481676,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.0888733);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.579505,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550099,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513645,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454725,-99) , 
3, 168.63, 0, 0, 0.462779,-99) , 
2, 3.8629, 0, 0, 0.470853,-99) , 
3, 235.984, 0, 0, 0.478122,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.0709097);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550543,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486742,-99) , 
2, 3.206, 0, 0, 0.50563,-99) , 
NN(
0, 
0, 
-1, 3.10611, 1, -1, 0.427037,-99) , 
3, 47.4132, 0, 0, 0.495968,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.416301,-99) , 
2, 1.9365, 0, 0, 0.488337,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.0820498);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529156,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455058,-99) , 
1, 143.451, 0, 0, 0.514654,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.417091,-99) , 
1, 239.703, 1, 0, 0.504321,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.419761,-99) , 
1, 301.918, 1, 0, 0.497731,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.0944569);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522323,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.413686,-99) , 
0, 61.6401, 0, 0, 0.513773,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.282931,-99) , 
0, 149.419, 1, 0, 0.499713,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531723,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.32414,-99) , 
1, 195.807, 1, 0, 0.438451,-99) , 
0, 171.363, 1, 0, 0.491015,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.0673623);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.565403,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483631,-99) , 
3, 227.005, 0, 0, 0.491056,-99) , 
NN(
0, 
0, 
-1, 3.10611, 1, -1, 0.42053,-99) , 
3, 47.4132, 0, 0, 0.482348,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.414024,-99) , 
2, 1.9365, 0, 0, 0.475781,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.0434642);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550449,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49688,-99) , 
2, 3.52336, 0, 0, 0.50484,-99) , 
NN(
0, 
0, 
-1, 3.10611, 1, -1, 0.437027,-99) , 
3, 47.4132, 0, 0, 0.496495,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.430456,-99) , 
2, 1.9365, 0, 0, 0.49017,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.0574121);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519806,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466008,-99) , 
0, 171.363, 1, 0, 0.512481,-99) , 
NN(
0, 
0, 
-1, 3.10611, 1, -1, 0.447748,-99) , 
3, 47.4132, 0, 0, 0.504532,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.441142,-99) , 
2, 1.9365, 0, 0, 0.498473,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.0280784);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546097,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500995,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459278,-99) , 
3, 56.3923, 0, 0, 0.493466,-99) , 
3, 235.984, 0, 0, 0.49713,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455341,-99) , 
2, 1.9365, 0, 0, 0.493143,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.0327064);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.557052,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494308,-99) , 
3, 235.984, 0, 0, 0.498149,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.431751,-99) , 
1, 250.069, 1, 0, 0.492871,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449948,-99) , 
1, 301.918, 1, 0, 0.489591,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.0577486);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521966,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.445982,-99) , 
0, 123.525, 1, 0, 0.510504,-99) , 
NN(
0, 
0, 
-1, 209.754, 1, -1, 0.4694,-99) , 
0, 134.66, 1, 0, 0.500125,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458055,-99) , 
1, 301.918, 1, 0, 0.496915,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.0200723);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535336,-99) , 
NN(
0, 
0, 
-1, 56.3923, 0, -1, 0.494192,-99) , 
3, 235.984, 0, 0, 0.497055,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469301,-99) , 
2, 1.9365, 0, 0, 0.494414,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.0185352);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 3.84072, 0, 1, 0.504425,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509183,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448498,-99) , 
2, 3.10611, 1, 0, 0.479457,-99) , 
3, 47.4132, 0, 0, 0.501375,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474303,-99) , 
2, 1.9365, 0, 0, 0.4988,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.0189327);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516625,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501324,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.429929,-99) , 
1, 250.069, 1, 0, 0.495846,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463176,-99) , 
1, 301.918, 1, 0, 0.493501,-99) , 
2, 3.8629, 0, 0, 0.495549,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.0306567);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511896,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508269,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.445511,-99) , 
2, 3.31293, 1, 0, 0.498763,-99) , 
NN(
0, 
0, 
-1, 2.21167, 0, -1, 0.484073,-99) , 
3, 94.5559, 1, 0, 0.49012,-99) , 
2, 3.8629, 0, 0, 0.492048,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.0230742);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534874,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495515,-99) , 
3, 227.005, 0, 0, 0.499072,-99) , 
NN(
0, 
0, 
-1, 3.10611, 1, -1, 0.47013,-99) , 
3, 47.4132, 0, 0, 0.495535,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473812,-99) , 
2, 1.9365, 0, 0, 0.493472,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.0172682);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52998,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499255,-99) , 
2, 3.52336, 0, 0, 0.503798,-99) , 
NN(
0, 
0, 
-1, 3.10611, 1, -1, 0.475882,-99) , 
3, 47.4132, 0, 0, 0.500389,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479568,-99) , 
2, 1.9365, 0, 0, 0.498412,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.0190631);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 182.108, 0, 1, 0.506839,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503339,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456034,-99) , 
2, 3.10611, 1, 0, 0.480191,-99) , 
3, 47.4132, 0, 0, 0.503585,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483879,-99) , 
2, 1.9365, 0, 0, 0.501714,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.0567194);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 102.995, 0, 1, 0.517376,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454522,-99) , 
3, 153.814, 1, 0, 0.504699,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532066,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480959,-99) , 
0, 102.64, 0, 0, 0.508189,-99) , 
NN(
0, 
0, 
-1, 197.365, 1, -1, 0.447475,-99) , 
0, 136.026, 1, 0, 0.493481,-99) , 
2, 2.8997, 1, 0, 0.498369,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.0413222);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.554846,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48011,-99) , 
2, 3.04137, 0, 0, 0.519978,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517217,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482209,-99) , 
3, 117.005, 0, 0, 0.494541,-99) , 
3, 188.841, 0, 0, 0.498108,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478177,-99) , 
2, 1.9365, 0, 0, 0.496218,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.0323596);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513589,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545684,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484676,-99) , 
3, 133.117, 0, 0, 0.508087,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504455,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46851,-99) , 
3, 142.121, 1, 0, 0.494134,-99) , 
2, 3.129, 0, 0, 0.498113,-99) , 
2, 3.8629, 0, 0, 0.499484,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.0236233);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517548,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520166,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508156,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488899,-99) , 
2, 2.4181, 1, 0, 0.492965,-99) , 
3, 179.86, 0, 0, 0.495571,-99) , 
3, 235.984, 0, 0, 0.497011,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.0394572);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523667,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476341,-99) , 
0, 136.026, 1, 0, 0.511925,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511806,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480158,-99) , 
1, 182.463, 0, 0, 0.493783,-99) , 
2, 3.10611, 0, 0, 0.501268,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47712,-99) , 
2, 1.9365, 0, 0, 0.498978,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.0375124);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511615,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448172,-99) , 
1, 128.644, 0, 0, 0.506049,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45087,-99) , 
1, 239.703, 1, 0, 0.500271,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480702,-99) , 
1, 301.918, 1, 0, 0.498785,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0206379);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515247,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493563,-99) , 
3, 182.108, 0, 0, 0.497431,-99) , 
NN(
0, 
0, 
-1, 31.6984, 0, -1, 0.479245,-99) , 
3, 47.4132, 0, 0, 0.495204,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482548,-99) , 
2, 1.9365, 0, 0, 0.494004,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.0307054);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 123.738, 0, 1, 0.526642,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500808,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474143,-99) , 
3, 92.9498, 1, 0, 0.494211,-99) , 
3, 114.758, 0, 0, 0.500974,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536295,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495987,-99) , 
3, 222.517, 0, 0, 0.507621,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.439876,-99) , 
2, 2.74278, 0, 0, 0.489732,-99) , 
3, 141.699, 1, 0, 0.4977,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0173202);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518428,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496442,-99) , 
2, 3.52336, 0, 0, 0.499696,-99) , 
NN(
0, 
0, 
-1, 31.6984, 0, -1, 0.476733,-99) , 
3, 47.4132, 0, 0, 0.496883,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484129,-99) , 
2, 1.9365, 0, 0, 0.495674,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0107507);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 182.108, 0, 1, 0.502745,-99) , 
NN(
0, 
0, 
-1, 31.6984, 0, -1, 0.481055,-99) , 
3, 47.4132, 0, 0, 0.500088,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488455,-99) , 
2, 1.9365, 0, 0, 0.498986,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.0532415);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530009,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521075,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.405249,-99) , 
0, 127.473, 1, 0, 0.495755,-99) , 
0, 171.363, 0, 0, 0.501137,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510236,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457869,-99) , 
0, 124.895, 1, 0, 0.502796,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501615,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.41655,-99) , 
1, 197.365, 1, 0, 0.46855,-99) , 
0, 136.026, 1, 0, 0.494515,-99) , 
2, 2.8997, 1, 0, 0.497403,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.0430795);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516728,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507776,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.418143,-99) , 
0, 127.473, 1, 0, 0.488242,-99) , 
0, 171.363, 0, 0, 0.49272,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539066,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487018,-99) , 
1, 255.988, 0, 0, 0.493265,-99) , 
NN(
0, 
0, 
-1, 197.365, 1, -1, 0.465527,-99) , 
0, 136.026, 1, 0, 0.486562,-99) , 
2, 2.8997, 1, 0, 0.489247,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.0328764);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53019,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490324,-99) , 
3, 133.117, 0, 0, 0.503877,-99) , 
NN(
0, 
0, 
-1, 182.463, 0, -1, 0.484996,-99) , 
2, 3.10611, 0, 0, 0.492787,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476407,-99) , 
2, 1.9365, 0, 0, 0.491237,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.0169711);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 4.10863, 0, 1, 0.506511,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502155,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486457,-99) , 
1, 182.463, 0, 0, 0.493211,-99) , 
2, 3.10611, 0, 0, 0.498699,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484613,-99) , 
2, 1.9365, 0, 0, 0.497366,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.033108);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 123.738, 0, 1, 0.519285,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510505,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488094,-99) , 
2, 2.4181, 1, 0, 0.493471,-99) , 
3, 114.758, 0, 0, 0.498849,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519992,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493947,-99) , 
3, 182.109, 0, 0, 0.507675,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44355,-99) , 
2, 2.74278, 0, 0, 0.490774,-99) , 
3, 141.699, 1, 0, 0.496497,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0226707);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538514,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499268,-99) , 
2, 4.14796, 0, 0, 0.506231,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506799,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49008,-99) , 
1, 182.923, 0, 0, 0.497083,-99) , 
2, 3.152, 0, 0, 0.500777,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513843,-99) , 
NN(
0, 
0, 
-1, 1.95937, 0, -1, 0.467481,-99) , 
0, 110.231, 1, 0, 0.487886,-99) , 
2, 2.4181, 0, 0, 0.498228,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0258239);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516121,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491113,-99) , 
0, 136.026, 1, 0, 0.509889,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511577,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495628,-99) , 
3, 189.24, 0, 0, 0.498002,-99) , 
2, 3.152, 0, 0, 0.502803,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527931,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481732,-99) , 
1, 172.418, 1, 0, 0.502864,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459001,-99) , 
3, 113.326, 1, 0, 0.488558,-99) , 
2, 2.4181, 0, 0, 0.499987,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0188405);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537692,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503536,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480626,-99) , 
3, 138.809, 1, 0, 0.500776,-99) , 
3, 161.902, 0, 0, 0.504,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502825,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467793,-99) , 
1, 184.462, 1, 0, 0.485989,-99) , 
3, 188.841, 1, 0, 0.501596,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.0128809);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517354,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499924,-99) , 
2, 3.59586, 0, 0, 0.502433,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490846,-99) , 
3, 47.4132, 0, 0, 0.501085,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507387,-99) , 
NN(
0, 
0, 
-1, 1.95937, 0, -1, 0.471734,-99) , 
0, 110.231, 1, 0, 0.487433,-99) , 
2, 2.4181, 0, 0, 0.498387,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.0247083);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 3.09553, 0, 1, 0.508594,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50782,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483051,-99) , 
3, 60.8817, 0, 0, 0.501148,-99) , 
3, 141.699, 0, 0, 0.503486,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517407,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483701,-99) , 
1, 172.418, 1, 0, 0.499119,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464442,-99) , 
3, 113.326, 1, 0, 0.487814,-99) , 
2, 2.4181, 0, 0, 0.50039,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.013861);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530837,-99) , 
NN(
0, 
0, 
-1, 138.809, 1, -1, 0.496988,-99) , 
3, 161.902, 0, 0, 0.499941,-99) , 
NN(
0, 
0, 
-1, 184.462, 1, -1, 0.483397,-99) , 
3, 188.841, 1, 0, 0.497733,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.0134802);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527384,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502353,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486568,-99) , 
3, 138.809, 1, 0, 0.500453,-99) , 
3, 161.902, 0, 0, 0.502802,-99) , 
NN(
0, 
0, 
-1, 184.462, 1, -1, 0.486859,-99) , 
3, 188.841, 1, 0, 0.500674,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.0409931);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.574525,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.423349,-99) , 
1, 195.807, 1, 0, 0.509478,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.571184,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492486,-99) , 
1, 282.274, 0, 0, 0.498735,-99) , 
0, 171.363, 0, 0, 0.500201,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485838,-99) , 
2, 1.9365, 0, 0, 0.498845,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.0305407);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 186.886, 0, 1, 0.512699,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455186,-99) , 
1, 250.069, 1, 0, 0.508177,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484229,-99) , 
1, 301.918, 1, 0, 0.506382,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.0188176);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 88.877, 1, 1, 0.516231,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500588,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476014,-99) , 
3, 189.24, 1, 0, 0.497659,-99) , 
2, 3.06022, 0, 0, 0.502874,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51156,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471318,-99) , 
3, 83.2284, 0, 0, 0.493361,-99) , 
2, 3.3813, 1, 0, 0.501003,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.0169145);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518103,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499694,-99) , 
3, 222.517, 0, 0, 0.504903,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520628,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494555,-99) , 
3, 128.227, 0, 0, 0.497222,-99) , 
3, 141.699, 0, 0, 0.499633,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507662,-99) , 
NN(
0, 
0, 
-1, 1.95937, 0, -1, 0.476527,-99) , 
0, 110.231, 1, 0, 0.490263,-99) , 
2, 2.4181, 0, 0, 0.497783,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.0256449);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534232,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494575,-99) , 
3, 76.595, 0, 0, 0.506517,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50998,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487019,-99) , 
3, 137.21, 0, 0, 0.499858,-99) , 
3, 94.5559, 1, 0, 0.502517,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50843,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490508,-99) , 
1, 172.418, 1, 0, 0.498709,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474281,-99) , 
3, 113.326, 1, 0, 0.490758,-99) , 
2, 2.4181, 0, 0, 0.500196,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.0147817);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520737,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503872,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48535,-99) , 
3, 138.809, 1, 0, 0.501643,-99) , 
3, 161.902, 0, 0, 0.503308,-99) , 
NN(
0, 
0, 
-1, 184.462, 1, -1, 0.486992,-99) , 
3, 188.841, 1, 0, 0.501132,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.0202408);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52416,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497291,-99) , 
3, 76.595, 0, 0, 0.505376,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510101,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491829,-99) , 
1, 193.069, 0, 0, 0.498449,-99) , 
3, 94.5559, 1, 0, 0.501214,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503631,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503884,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457338,-99) , 
2, 1.95937, 0, 0, 0.480361,-99) , 
0, 110.231, 1, 0, 0.490631,-99) , 
2, 2.4181, 0, 0, 0.499125,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.0106532);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51342,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513855,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499383,-99) , 
2, 3.59586, 0, 0, 0.501464,-99) , 
3, 47.4132, 1, 0, 0.502856,-99) , 
NN(
0, 
0, 
-1, 110.231, 1, -1, 0.488425,-99) , 
2, 2.4181, 0, 0, 0.500008,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.0135871);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.573101,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499579,-99) , 
1, 282.274, 0, 0, 0.505389,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496575,-99) , 
0, 171.363, 1, 0, 0.504223,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501234,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501487,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465015,-99) , 
2, 1.95937, 0, 0, 0.483066,-99) , 
0, 110.231, 1, 0, 0.491087,-99) , 
2, 2.4181, 0, 0, 0.50163,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.0155887);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 94.5559, 1, 1, 0.507154,-99) , 
NN(
0, 
0, 
-1, 76.0041, 1, -1, 0.489605,-99) , 
2, 2.4181, 0, 0, 0.503691,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.0246219);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547769,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499673,-99) , 
1, 184.914, 0, 0, 0.509199,-99) , 
NN(
0, 
0, 
-1, 130.63, 1, -1, 0.479084,-99) , 
1, 208.607, 1, 0, 0.502548,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486299,-99) , 
1, 301.918, 1, 0, 0.501332,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.015617);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 94.5559, 1, 1, 0.50766,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507022,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490467,-99) , 
3, 76.0041, 1, 0, 0.497884,-99) , 
2, 2.4181, 0, 0, 0.505732,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.0191633);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 134.66, 0, 1, 0.50719,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463123,-99) , 
1, 250.069, 1, 0, 0.503727,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489695,-99) , 
1, 301.918, 1, 0, 0.502678,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.0166774);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 88.877, 1, 1, 0.512518,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500122,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484277,-99) , 
2, 2.91497, 1, 0, 0.496532,-99) , 
2, 3.06022, 0, 0, 0.501021,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513516,-99) , 
NN(
0, 
0, 
-1, 3.6259, 0, -1, 0.480625,-99) , 
2, 4.02344, 0, 0, 0.492269,-99) , 
2, 3.3813, 1, 0, 0.4993,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.0151079);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515408,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496509,-99) , 
3, 76.595, 0, 0, 0.502193,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503458,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487987,-99) , 
3, 137.21, 0, 0, 0.49664,-99) , 
3, 94.5559, 1, 0, 0.498857,-99) , 
NN(
0, 
0, 
-1, 110.231, 1, -1, 0.490874,-99) , 
2, 2.4181, 0, 0, 0.497281,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.0166638);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515682,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502438,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486962,-99) , 
2, 3.3813, 1, 0, 0.499063,-99) , 
3, 121.493, 0, 0, 0.501528,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503846,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491364,-99) , 
1, 193.069, 1, 0, 0.499101,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46598,-99) , 
2, 2.74278, 0, 0, 0.490413,-99) , 
3, 141.699, 1, 0, 0.498293,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.0123562);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512528,-99) , 
NN(
0, 
0, 
-1, 138.382, 1, -1, 0.49592,-99) , 
3, 152.923, 0, 0, 0.497999,-99) , 
NN(
0, 
0, 
-1, 184.462, 1, -1, 0.487058,-99) , 
3, 188.841, 1, 0, 0.496539,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.014892);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514606,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502606,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49337,-99) , 
3, 92.6302, 1, 0, 0.499803,-99) , 
3, 121.493, 0, 0, 0.501999,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509187,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49477,-99) , 
3, 222.517, 0, 0, 0.498937,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470774,-99) , 
2, 2.74278, 0, 0, 0.491552,-99) , 
3, 141.699, 1, 0, 0.498958,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.00925957);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513162,-99) , 
NN(
0, 
0, 
-1, 138.382, 1, -1, 0.497569,-99) , 
3, 152.923, 0, 0, 0.49952,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500568,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47936,-99) , 
1, 184.462, 1, 0, 0.490402,-99) , 
3, 188.841, 1, 0, 0.498304,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.0199795);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529856,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489657,-99) , 
1, 170.301, 0, 0, 0.512307,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503767,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489496,-99) , 
1, 194.432, 1, 0, 0.498955,-99) , 
3, 108.024, 0, 0, 0.502515,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504598,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49661,-99) , 
2, 3.16339, 0, 0, 0.499957,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47407,-99) , 
2, 2.74278, 0, 0, 0.493169,-99) , 
3, 141.699, 1, 0, 0.499796,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.00783077);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512962,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500352,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481319,-99) , 
3, 138.382, 1, 0, 0.49874,-99) , 
3, 152.923, 0, 0, 0.50052,-99) , 
NN(
0, 
0, 
-1, 184.462, 1, -1, 0.492012,-99) , 
3, 188.841, 1, 0, 0.499385,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.0423636);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.555166,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.43672,-99) , 
1, 195.807, 1, 0, 0.504106,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.574627,-99) , 
NN(
0, 
0, 
-1, 68.9546, 0, -1, 0.490306,-99) , 
1, 282.274, 0, 0, 0.497234,-99) , 
0, 171.363, 0, 0, 0.498201,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.0199539);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 186.886, 0, 1, 0.509133,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476763,-99) , 
1, 250.069, 1, 0, 0.506597,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493278,-99) , 
1, 301.918, 1, 0, 0.505604,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.0467698);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543985,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454815,-99) , 
0, 121.994, 1, 0, 0.51905,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44466,-99) , 
0, 173.17, 1, 0, 0.506453,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50713,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486351,-99) , 
2, 3.38378, 1, 0, 0.503221,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475614,-99) , 
1, 130.869, 0, 0, 0.49961,-99) , 
1, 193.069, 0, 0, 0.502083,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.0565061);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53772,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474983,-99) , 
0, 114.683, 1, 0, 0.513927,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456237,-99) , 
0, 173.17, 1, 0, 0.504162,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533911,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488315,-99) , 
1, 152.623, 1, 0, 0.505378,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515471,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460485,-99) , 
0, 101.257, 0, 0, 0.491341,-99) , 
0, 134.66, 0, 0, 0.494798,-99) , 
1, 193.069, 0, 0, 0.498179,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.0340211);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539104,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473188,-99) , 
1, 195.807, 1, 0, 0.510732,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.560605,-99) , 
NN(
0, 
0, 
-1, 68.9546, 0, -1, 0.489853,-99) , 
1, 282.274, 0, 0, 0.495625,-99) , 
0, 171.363, 0, 0, 0.497742,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.0240684);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 78.1315, 1, 1, 0.515066,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478299,-99) , 
0, 173.17, 1, 0, 0.508847,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513578,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517946,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493397,-99) , 
2, 3.28368, 0, 0, 0.498665,-99) , 
3, 47.4132, 1, 0, 0.50079,-99) , 
1, 193.069, 0, 0, 0.503698,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.0448304);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532637,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487491,-99) , 
1, 195.807, 1, 0, 0.513214,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515902,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.441431,-99) , 
0, 59.5502, 0, 0, 0.509585,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504481,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.398205,-99) , 
0, 148.374, 1, 0, 0.474925,-99) , 
0, 127.474, 1, 0, 0.502028,-99) , 
0, 171.363, 0, 0, 0.503596,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.0264203);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537233,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496168,-99) , 
3, 133.117, 0, 0, 0.511663,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538983,-99) , 
NN(
0, 
0, 
-1, 244.547, 1, -1, 0.489648,-99) , 
1, 282.274, 0, 0, 0.493662,-99) , 
0, 171.363, 0, 0, 0.496185,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.0330864);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535483,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494719,-99) , 
2, 2.85432, 1, 0, 0.513289,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510978,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463106,-99) , 
0, 64.7751, 0, 0, 0.505818,-99) , 
NN(
0, 
0, 
-1, 148.374, 1, -1, 0.475403,-99) , 
0, 127.474, 1, 0, 0.499192,-99) , 
0, 171.363, 0, 0, 0.501167,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.0192918);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 133.117, 0, 1, 0.514033,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529809,-99) , 
NN(
0, 
0, 
-1, 244.547, 1, -1, 0.492918,-99) , 
1, 282.274, 0, 0, 0.495917,-99) , 
0, 171.363, 0, 0, 0.498456,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.0189751);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 133.117, 0, 1, 0.521342,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500632,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466688,-99) , 
0, 67.8545, 0, 0, 0.496875,-99) , 
0, 134.66, 0, 0, 0.503037,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478761,-99) , 
1, 301.918, 1, 0, 0.501253,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.016711);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530998,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497358,-99) , 
2, 4.14796, 0, 0, 0.503313,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514184,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494848,-99) , 
3, 189.24, 0, 0, 0.497725,-99) , 
2, 3.152, 0, 0, 0.499985,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505666,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487016,-99) , 
3, 97.2268, 0, 0, 0.495427,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475809,-99) , 
2, 1.61543, 0, 0, 0.489595,-99) , 
2, 2.4181, 0, 0, 0.497934,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.0177602);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506869,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474195,-99) , 
1, 239.701, 1, 0, 0.503573,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49307,-99) , 
1, 301.918, 1, 0, 0.502824,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501489,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491192,-99) , 
3, 97.2268, 0, 0, 0.495836,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479979,-99) , 
2, 1.61543, 0, 0, 0.491123,-99) , 
2, 2.4181, 0, 0, 0.500515,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.0175721);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524079,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496575,-99) , 
3, 133.117, 0, 0, 0.506934,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533549,-99) , 
NN(
0, 
0, 
-1, 244.547, 1, -1, 0.493836,-99) , 
1, 282.274, 0, 0, 0.497066,-99) , 
0, 171.363, 0, 0, 0.498448,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.0242527);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530305,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484833,-99) , 
0, 246.002, 1, 0, 0.519569,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503085,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482794,-99) , 
3, 141.815, 1, 0, 0.49744,-99) , 
0, 134.66, 0, 0, 0.50301,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486028,-99) , 
1, 301.918, 1, 0, 0.501763,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.0159624);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523175,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496218,-99) , 
2, 2.85432, 1, 0, 0.508484,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533084,-99) , 
NN(
0, 
0, 
-1, 244.547, 1, -1, 0.49506,-99) , 
1, 282.274, 0, 0, 0.498153,-99) , 
0, 171.363, 0, 0, 0.499597,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.0174314);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531953,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498577,-99) , 
3, 88.835, 0, 0, 0.518382,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502032,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479037,-99) , 
0, 123.525, 1, 0, 0.498584,-99) , 
0, 134.66, 0, 0, 0.503566,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489356,-99) , 
1, 301.918, 1, 0, 0.502522,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.010083);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 222.517, 0, 1, 0.506839,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511476,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497901,-99) , 
3, 121.493, 0, 0, 0.500091,-99) , 
3, 141.699, 0, 0, 0.50221,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500508,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488055,-99) , 
1, 184.002, 0, 0, 0.493728,-99) , 
2, 2.4181, 0, 0, 0.500537,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.0101766);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 4.14796, 0, 1, 0.506365,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511237,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498068,-99) , 
3, 189.24, 0, 0, 0.500027,-99) , 
2, 3.152, 0, 0, 0.50259,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50206,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49439,-99) , 
2, 2.18876, 0, 0, 0.497653,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485192,-99) , 
2, 1.61543, 0, 0, 0.493952,-99) , 
2, 2.4181, 0, 0, 0.500886,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.00966628);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517297,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501583,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485918,-99) , 
3, 138.382, 1, 0, 0.500259,-99) , 
3, 152.923, 0, 0, 0.502392,-99) , 
NN(
0, 
0, 
-1, 184.462, 1, -1, 0.492839,-99) , 
3, 188.841, 1, 0, 0.501116,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.0140771);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519673,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49778,-99) , 
2, 2.85432, 1, 0, 0.507738,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529965,-99) , 
NN(
0, 
0, 
-1, 244.547, 1, -1, 0.495543,-99) , 
1, 282.274, 0, 0, 0.498341,-99) , 
0, 171.363, 0, 0, 0.499655,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.011638);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 222.517, 0, 1, 0.506883,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504317,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48687,-99) , 
3, 33.9433, 0, 0, 0.502721,-99) , 
3, 141.699, 0, 0, 0.504028,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501804,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494204,-99) , 
1, 180.588, 1, 0, 0.498212,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487177,-99) , 
2, 1.61543, 0, 0, 0.494935,-99) , 
2, 2.4181, 0, 0, 0.502235,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.0177098);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52582,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487297,-99) , 
0, 246.002, 1, 0, 0.516728,-99) , 
NN(
0, 
0, 
-1, 67.8545, 0, -1, 0.496127,-99) , 
0, 134.66, 0, 0, 0.501309,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488121,-99) , 
1, 301.918, 1, 0, 0.50034,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.0156553);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518677,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499548,-99) , 
1, 184.91, 0, 0, 0.506006,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471432,-99) , 
1, 260.434, 1, 0, 0.504035,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492547,-99) , 
1, 301.918, 1, 0, 0.503192,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.0191735);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509803,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474453,-99) , 
0, 142.104, 1, 0, 0.50675,-99) , 
NN(
0, 
0, 
-1, 0, 1, 1, 0.501106,-99) , 
0, 171.363, 1, 0, 0.506008,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505391,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506593,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484551,-99) , 
2, 1.95937, 0, 0, 0.495469,-99) , 
0, 110.231, 1, 0, 0.499867,-99) , 
2, 2.4181, 0, 0, 0.504797,-99)    );
   return;
};
 
// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
