// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.06/01       [394753]
Creator        : kskovpen
Date           : Sat Aug 20 12:55:11 2016
Host           : Linux vocms0315.cern.ch 2.6.32-573.26.1.el6.x86_64 #1 SMP Wed May 4 09:23:05 CEST 2016 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /grid_mnt/home-pbs/kskovpen/tHFCNC2016/CMSSW_8_0_12/src/TopKinFit/test/Validation/TopTopLepHad/MVA
Training events: 5373
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
SeparationType: "giniindex" [Separation criterion for node splitting]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
MinNodeSize: "5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "2" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 4
TopHadRecMTruth               TopHadRecMTruth               TopHadRecMTruth               TopHadRecMTruth                                                 'F'    [74.4038238525,1126.79064941]
TopLepRecMTruth               TopLepRecMTruth               TopLepRecMTruth               TopLepRecMTruth                                                 'F'    [77.5896835327,1596.31469727]
TopLepTopHadRecDrTruth        TopLepTopHadRecDrTruth        TopLepTopHadRecDrTruth        TopLepTopHadRecDrTruth                                          'F'    [0.0517391115427,7.69647693634]
TopLepRecPtTruth              TopLepRecPtTruth              TopLepRecPtTruth              TopLepRecPtTruth                                                'F'    [3.11451840401,744.867919922]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTNode
   
#ifndef BDTNode__def
#define BDTNode__def
   
class BDTNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 4 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "TopHadRecMTruth", "TopLepRecMTruth", "TopLepTopHadRecDrTruth", "TopLepRecPtTruth" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[4];
   double fVmax[4];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[4];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadBDT::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(0.636913757285433);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 144.401, 0, 1, 0.726913,-99) , 
NN(
0, 
0, 
-1, 109.728, 0, -1, 0.300148,-99) , 
1, 231.897, 1, 0, 0.64948,-99) , 
NN(
0, 
0, 
-1, 267.723, 1, -1, 0.0330773,-99) , 
0, 224.745, 1, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.544724);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.82191, 0, 1, 0.784997,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.672005,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.356696,-99) , 
2, 3.32806, 0, 0, 0.437397,-99) , 
3, 144.401, 0, 0, 0.559464,-99) , 
NN(
0, 
0, 
-1, 267.723, 1, -1, 0.0607476,-99) , 
0, 224.745, 1, 0, 0.45525,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.456486);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.653361,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.288535,-99) , 
0, 132.33, 0, 0, 0.61166,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.259509,-99) , 
0, 196.084, 1, 0, 0.561333,-99) , 
NN(
0, 
0, 
-1, 267.723, 1, -1, 0.100324,-99) , 
0, 224.745, 1, 0, 0.476267,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.276125);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 3.17638, 0, 1, 0.722776,-99) , 
NN(
0, 
0, 
-1, 188.933, 1, -1, 0.431321,-99) , 
3, 179.722, 0, 0, 0.488608,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.042026,-99) , 
0, 274.858, 1, 0, 0.444211,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.302054);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.609002,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.415032,-99) , 
0, 188.933, 1, 0, 0.561436,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.258836,-99) , 
1, 283.333, 1, 0, 0.531082,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0546603,-99) , 
0, 274.858, 1, 0, 0.488082,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.222706);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 3.03446, 0, 1, 0.724818,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.72886,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452626,-99) , 
2, 4.05613, 0, 0, 0.475165,-99) , 
3, 215.044, 0, 0, 0.504397,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0725372,-99) , 
0, 274.858, 1, 0, 0.46907,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.234924);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.600769,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457574,-99) , 
1, 194.859, 1, 0, 0.559953,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.341545,-99) , 
1, 283.333, 1, 0, 0.539584,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.089021,-99) , 
0, 274.858, 1, 0, 0.50539,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.171667);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 179.925, 0, 1, 0.576769,-99) , 
NN(
0, 
0, 
-1, 143.302, 0, -1, 0.456418,-99) , 
2, 2.96402, 0, 0, 0.52273,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.110002,-99) , 
0, 274.858, 1, 0, 0.493633,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.149742);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.754963,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5259,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.387618,-99) , 
0, 141.213, 0, 0, 0.503335,-99) , 
3, 250.366, 0, 0, 0.518561,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.127967,-99) , 
0, 274.858, 1, 0, 0.492484,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.109191);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.726218,-99) , 
NN(
0, 
0, 
-1, 208.022, 1, -1, 0.478033,-99) , 
3, 250.366, 0, 0, 0.492593,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.145628,-99) , 
0, 274.858, 1, 0, 0.470471,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.16491);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.558866,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448715,-99) , 
0, 144.348, 0, 0, 0.535627,-99) , 
NN(
0, 
0, 
-1, 99.9585, 0, -1, 0.382156,-99) , 
0, 208.022, 1, 0, 0.516726,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.159746,-99) , 
0, 274.858, 1, 0, 0.494715,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.12753);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.688049,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522679,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.432415,-99) , 
0, 179.389, 1, 0, 0.489705,-99) , 
3, 250.366, 0, 0, 0.500953,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.183141,-99) , 
0, 274.858, 1, 0, 0.482202,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.126731);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.660043,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.588977,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464737,-99) , 
2, 3.69209, 0, 0, 0.481034,-99) , 
3, 250.366, 0, 0, 0.491002,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.202995,-99) , 
0, 274.858, 1, 0, 0.474562,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.137383);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542608,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.406265,-99) , 
1, 136.224, 0, 0, 0.524944,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.375021,-99) , 
1, 283.333, 1, 0, 0.511351,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.224271,-99) , 
0, 274.858, 1, 0, 0.495453,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.105899);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.723475,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498817,-99) , 
2, 3.42591, 0, 0, 0.532458,-99) , 
NN(
0, 
0, 
-1, 2.96402, 1, -1, 0.451777,-99) , 
3, 109.079, 0, 0, 0.49129,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.249072,-99) , 
0, 274.858, 1, 0, 0.478262,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.0885428);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 179.722, 0, 1, 0.526358,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.395252,-99) , 
2, 1.87191, 0, 0, 0.513922,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.2694,-99) , 
0, 274.858, 1, 0, 0.501047,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.136057);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.570242,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.423221,-99) , 
2, 2.76314, 0, 0, 0.533279,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50854,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.412039,-99) , 
2, 2.96402, 1, 0, 0.460506,-99) , 
3, 109.079, 0, 0, 0.495985,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.287179,-99) , 
0, 274.858, 1, 0, 0.485173,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.0980972);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.659152,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50919,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437164,-99) , 
3, 85.493, 0, 0, 0.482701,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.343773,-99) , 
0, 224.745, 1, 0, 0.468091,-99) , 
3, 250.366, 0, 0, 0.478858,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.11741);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.630474,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.593382,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463336,-99) , 
3, 215.044, 0, 0, 0.477155,-99) , 
2, 4.05613, 0, 0, 0.487326,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.33643,-99) , 
1, 294.55, 1, 0, 0.474314,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.0695789);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 175.559, 1, 1, 0.584152,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508404,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.435902,-99) , 
1, 139.576, 0, 0, 0.496711,-99) , 
2, 3.69209, 0, 0, 0.506977,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.363124,-99) , 
1, 294.55, 1, 0, 0.494726,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.072932);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.585716,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500501,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.43185,-99) , 
1, 201.567, 1, 0, 0.492424,-99) , 
2, 3.69209, 0, 0, 0.503189,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535549,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.442659,-99) , 
3, 109.728, 0, 0, 0.488055,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.288464,-99) , 
0, 190.001, 1, 0, 0.422441,-99) , 
1, 222.23, 1, 0, 0.484791,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.0977788);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.68736,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.418861,-99) , 
3, 74.7841, 0, 0, 0.554274,-99) , 
NN(
0, 
0, 
-1, 224.745, 1, -1, 0.46362,-99) , 
2, 3.69209, 0, 0, 0.47501,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.0588965);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.620169,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509474,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467993,-99) , 
0, 145.98, 0, 0, 0.500196,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.389037,-99) , 
0, 224.745, 1, 0, 0.489112,-99) , 
3, 250.366, 0, 0, 0.496322,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.0648228);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.647908,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491833,-99) , 
3, 215.044, 0, 0, 0.506052,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.426607,-99) , 
2, 1.87191, 0, 0, 0.498385,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.396953,-99) , 
1, 294.55, 1, 0, 0.489961,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.0567066);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 179.722, 0, 1, 0.519327,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.442534,-99) , 
2, 1.87191, 0, 0, 0.511939,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.41257,-99) , 
1, 294.55, 1, 0, 0.503723,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.0516378);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.587977,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505807,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463354,-99) , 
1, 149.907, 0, 0, 0.495331,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.386069,-99) , 
1, 294.55, 1, 0, 0.487121,-99) , 
2, 4.05613, 0, 0, 0.494387,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.0431264);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.597291,-99) , 
NN(
0, 
0, 
-1, 224.745, 1, -1, 0.482676,-99) , 
3, 250.366, 0, 0, 0.488732,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.0451864);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.585746,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505622,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450645,-99) , 
0, 203.241, 1, 0, 0.500828,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.406768,-99) , 
0, 224.745, 1, 0, 0.491584,-99) , 
2, 4.05613, 0, 0, 0.498371,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.0620479);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.574741,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512887,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476936,-99) , 
1, 174.016, 1, 0, 0.498069,-99) , 
NN(
0, 
0, 
-1, 190.001, 1, -1, 0.434375,-99) , 
1, 222.23, 1, 0, 0.484273,-99) , 
2, 4.05613, 0, 0, 0.490775,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.057372);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.584614,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513535,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474268,-99) , 
2, 2.96402, 1, 0, 0.492121,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4243,-99) , 
0, 224.745, 1, 0, 0.485571,-99) , 
3, 250.366, 0, 0, 0.490779,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.0868396);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.573384,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.710777,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473038,-99) , 
3, 180.848, 0, 0, 0.51656,-99) , 
NN(
0, 
0, 
-1, 226.16, 1, -1, 0.46967,-99) , 
2, 3.10246, 0, 0, 0.486158,-99) , 
2, 4.05613, 0, 0, 0.492438,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.0772975);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.6279,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516026,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.419059,-99) , 
2, 1.93071, 0, 0, 0.506262,-99) , 
2, 3.58437, 0, 0, 0.519586,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545526,-99) , 
NN(
0, 
0, 
-1, 178.589, 1, -1, 0.44709,-99) , 
2, 2.59999, 1, 0, 0.478642,-99) , 
3, 73.7577, 0, 0, 0.50845,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.0659122);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.648331,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.447248,-99) , 
3, 74.7841, 0, 0, 0.546588,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536844,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488239,-99) , 
2, 3.1719, 0, 0, 0.499538,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.420898,-99) , 
0, 224.745, 1, 0, 0.49205,-99) , 
2, 3.69209, 0, 0, 0.498792,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.071066);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 215.044, 0, 1, 0.527044,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.408216,-99) , 
0, 229.735, 1, 0, 0.516186,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520928,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.434247,-99) , 
0, 172.28, 0, 0, 0.475854,-99) , 
1, 149.91, 0, 0, 0.507195,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.0343758);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.56598,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546286,-99) , 
NN(
0, 
0, 
-1, 224.745, 1, -1, 0.487982,-99) , 
2, 4.05613, 0, 0, 0.492326,-99) , 
3, 250.366, 0, 0, 0.496065,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.0620603);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.553504,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514412,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462256,-99) , 
1, 139.578, 0, 0, 0.504749,-99) , 
0, 213.741, 0, 0, 0.510625,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549453,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499351,-99) , 
3, 109.728, 0, 0, 0.523904,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.362114,-99) , 
0, 190.001, 1, 0, 0.474294,-99) , 
1, 222.23, 1, 0, 0.502572,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.040597);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.616864,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.446938,-99) , 
3, 74.7841, 0, 0, 0.529978,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501177,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.447151,-99) , 
2, 3.34524, 1, 0, 0.495529,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.425637,-99) , 
1, 294.55, 1, 0, 0.490677,-99) , 
2, 3.69209, 0, 0, 0.495526,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.0543228);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.607225,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456993,-99) , 
3, 74.7841, 0, 0, 0.530311,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503571,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456686,-99) , 
3, 144.401, 1, 0, 0.488629,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437865,-99) , 
0, 224.745, 1, 0, 0.483905,-99) , 
2, 3.69209, 0, 0, 0.489616,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0480932);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.602803,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476378,-99) , 
2, 4.26436, 0, 0, 0.53076,-99) , 
NN(
0, 
0, 
-1, 294.55, 1, -1, 0.480682,-99) , 
2, 3.69209, 0, 0, 0.486829,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.0673031);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.569423,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.55598,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49398,-99) , 
2, 3.14878, 0, 0, 0.51504,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53417,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461974,-99) , 
2, 2.59999, 1, 0, 0.480664,-99) , 
3, 120.798, 0, 0, 0.493741,-99) , 
3, 250.366, 0, 0, 0.497578,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0374307);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.602779,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486121,-99) , 
3, 74.7841, 0, 0, 0.5429,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506738,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45601,-99) , 
2, 1.78516, 0, 0, 0.501667,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.447374,-99) , 
1, 294.55, 1, 0, 0.497952,-99) , 
2, 3.69209, 0, 0, 0.503451,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0454537);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.607379,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494693,-99) , 
2, 4.26436, 0, 0, 0.543241,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550513,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488907,-99) , 
2, 3.18826, 0, 0, 0.496167,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453752,-99) , 
2, 3.34524, 1, 0, 0.491614,-99) , 
2, 3.69209, 0, 0, 0.497922,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.0411026);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.598304,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494357,-99) , 
3, 74.7841, 0, 0, 0.544913,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51476,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487054,-99) , 
2, 2.71778, 0, 0, 0.504854,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46504,-99) , 
2, 3.34524, 1, 0, 0.500586,-99) , 
2, 3.69209, 0, 0, 0.505995,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.0781263);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 4.26436, 0, 1, 0.545288,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520128,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.430185,-99) , 
3, 207.347, 1, 0, 0.509498,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.60337,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457902,-99) , 
3, 180.848, 0, 0, 0.485596,-99) , 
2, 2.99856, 1, 0, 0.499074,-99) , 
2, 3.69209, 0, 0, 0.504706,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.0729861);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.593296,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.422111,-99) , 
2, 2.85181, 0, 0, 0.527716,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.560808,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517057,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474478,-99) , 
3, 120.847, 0, 0, 0.487483,-99) , 
2, 1.87191, 1, 0, 0.493976,-99) , 
3, 179.722, 0, 0, 0.499574,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.0460182);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.59559,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493456,-99) , 
2, 4.26436, 0, 0, 0.537301,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514612,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473116,-99) , 
3, 144.401, 1, 0, 0.501467,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465429,-99) , 
0, 224.745, 1, 0, 0.498159,-99) , 
2, 3.69209, 0, 0, 0.502923,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.0547569);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.586551,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451377,-99) , 
2, 2.85181, 0, 0, 0.534913,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53652,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50594,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470214,-99) , 
1, 180.462, 1, 0, 0.489771,-99) , 
2, 1.87191, 1, 0, 0.493895,-99) , 
3, 179.722, 0, 0, 0.500687,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0316316);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 4.26436, 0, 1, 0.538829,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524167,-99) , 
NN(
0, 
0, 
-1, 224.745, 1, -1, 0.488751,-99) , 
3, 215.044, 0, 0, 0.492529,-99) , 
2, 3.69209, 0, 0, 0.498155,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0539285);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.592226,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470938,-99) , 
0, 175.03, 0, 0, 0.530211,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546024,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489766,-99) , 
0, 176.68, 1, 0, 0.520115,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527386,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483968,-99) , 
2, 3.81388, 0, 0, 0.490514,-99) , 
2, 2.59999, 1, 0, 0.497211,-99) , 
3, 179.722, 0, 0, 0.50266,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0354127);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.592953,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.553732,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497518,-99) , 
3, 164.541, 0, 0, 0.504644,-99) , 
3, 215.044, 0, 0, 0.512597,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471566,-99) , 
2, 1.87191, 0, 0, 0.508603,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.0448102);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.584378,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515172,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467369,-99) , 
0, 224.745, 1, 0, 0.511255,-99) , 
3, 215.044, 0, 0, 0.517823,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480398,-99) , 
2, 1.87191, 0, 0, 0.514182,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.0387566);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536799,-99) , 
NN(
NN(
0, 
0, 
-1, 83.1413, 0, 1, 0.55976,-99) , 
NN(
0, 
0, 
-1, 3.69209, 1, -1, 0.491483,-99) , 
1, 231.897, 0, 0, 0.503474,-99) , 
0, 224.745, 0, 0, 0.506676,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.0612504);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.614132,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511127,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451164,-99) , 
1, 283.333, 1, 0, 0.506214,-99) , 
3, 215.234, 0, 0, 0.515549,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.571663,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483897,-99) , 
2, 2.11378, 1, 0, 0.529672,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.41735,-99) , 
3, 139.27, 1, 0, 0.498094,-99) , 
2, 2.59999, 0, 0, 0.511435,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.0411226);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.566046,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507283,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.424548,-99) , 
0, 229.735, 1, 0, 0.50071,-99) , 
3, 215.044, 0, 0, 0.506474,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521182,-99) , 
NN(
0, 
0, 
-1, 172.28, 0, -1, 0.459515,-99) , 
1, 132.667, 1, 0, 0.488157,-99) , 
1, 149.91, 0, 0, 0.502394,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.0460196);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52326,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.566889,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480933,-99) , 
3, 83.1413, 0, 0, 0.539075,-99) , 
NN(
0, 
0, 
-1, 3.69209, 1, -1, 0.483046,-99) , 
1, 231.897, 0, 0, 0.49282,-99) , 
0, 224.745, 0, 0, 0.495721,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.04463);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543081,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507457,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448148,-99) , 
3, 215.044, 1, 0, 0.502464,-99) , 
0, 213.741, 0, 0, 0.507204,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.551069,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49951,-99) , 
2, 2.93867, 1, 0, 0.52465,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.396674,-99) , 
0, 190.001, 1, 0, 0.486003,-99) , 
1, 222.23, 1, 0, 0.502578,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.0423985);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.566537,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477965,-99) , 
3, 233.559, 0, 0, 0.513085,-99) , 
NN(
NN(
0, 
0, 
-1, 103.321, 0, 1, 0.522514,-99) , 
NN(
0, 
0, 
-1, 45.364, 0, -1, 0.483847,-99) , 
2, 2.59999, 1, 0, 0.492592,-99) , 
3, 179.722, 0, 0, 0.495927,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.0327379);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.568249,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53211,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493248,-99) , 
3, 164.541, 0, 0, 0.498161,-99) , 
3, 215.044, 0, 0, 0.504311,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471597,-99) , 
2, 1.87191, 0, 0, 0.501145,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.0299135);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5602,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507762,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464814,-99) , 
0, 224.745, 1, 0, 0.504277,-99) , 
3, 215.044, 0, 0, 0.509175,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479762,-99) , 
2, 1.87191, 0, 0, 0.50633,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.036626);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.567983,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486091,-99) , 
2, 4.26436, 0, 0, 0.521683,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525083,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485551,-99) , 
0, 176.68, 1, 0, 0.508548,-99) , 
NN(
0, 
0, 
-1, 2.49863, 0, -1, 0.489013,-99) , 
3, 109.079, 1, 0, 0.498482,-99) , 
2, 3.69209, 0, 0, 0.5013,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.0285899);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526702,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.566602,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498554,-99) , 
3, 83.1413, 0, 0, 0.544547,-99) , 
NN(
0, 
0, 
-1, 3.69209, 1, -1, 0.493857,-99) , 
1, 231.897, 0, 0, 0.502691,-99) , 
0, 224.745, 0, 0, 0.504956,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.0497472);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547658,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512535,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460732,-99) , 
3, 215.044, 1, 0, 0.508201,-99) , 
0, 213.741, 0, 0, 0.512783,-99) , 
NN(
NN(
0, 
0, 
-1, 161.821, 0, 1, 0.531275,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.414757,-99) , 
0, 190.001, 1, 0, 0.496449,-99) , 
1, 222.23, 1, 0, 0.509233,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.03079);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520989,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543641,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.555116,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490195,-99) , 
2, 4.16268, 0, 0, 0.494696,-99) , 
2, 1.50788, 1, 0, 0.49767,-99) , 
3, 215.044, 0, 0, 0.499854,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.0244983);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.562691,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504423,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467694,-99) , 
1, 283.333, 1, 0, 0.501479,-99) , 
3, 215.044, 0, 0, 0.506823,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481239,-99) , 
2, 1.87191, 0, 0, 0.504355,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.0201909);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.572651,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501338,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.442088,-99) , 
3, 201.826, 1, 0, 0.497284,-99) , 
3, 240.295, 0, 0, 0.501888,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481135,-99) , 
3, 38.4361, 0, 0, 0.500222,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.0363978);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546803,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47168,-99) , 
0, 175.03, 0, 0, 0.508159,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52798,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533065,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48818,-99) , 
3, 162.894, 0, 0, 0.491121,-99) , 
2, 1.87191, 1, 0, 0.494346,-99) , 
3, 179.722, 0, 0, 0.49658,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.0218669);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.555521,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52913,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496897,-99) , 
1, 129.026, 1, 0, 0.499728,-99) , 
3, 215.044, 0, 0, 0.504574,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477924,-99) , 
2, 1.87191, 0, 0, 0.502004,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.0249699);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550115,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50688,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473815,-99) , 
0, 224.745, 1, 0, 0.504235,-99) , 
3, 215.044, 0, 0, 0.508216,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483383,-99) , 
2, 1.87191, 0, 0, 0.505822,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.0460849);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.555823,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485122,-99) , 
3, 74.7841, 0, 0, 0.518456,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513699,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.432861,-99) , 
2, 3.34524, 1, 0, 0.50591,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507784,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.401362,-99) , 
2, 2.52902, 0, 0, 0.48512,-99) , 
3, 144.401, 1, 0, 0.499285,-99) , 
2, 3.69209, 0, 0, 0.501608,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.044305);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.554948,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49148,-99) , 
2, 4.26436, 0, 0, 0.519143,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.572986,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479313,-99) , 
1, 197.363, 0, 0, 0.509325,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501685,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465265,-99) , 
2, 2.87472, 1, 0, 0.485401,-99) , 
2, 3.1719, 0, 0, 0.490832,-99) , 
2, 3.69209, 0, 0, 0.494261,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.0491989);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.570634,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521362,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486522,-99) , 
2, 3.57122, 0, 0, 0.493382,-99) , 
3, 215.234, 0, 0, 0.499828,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523351,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46482,-99) , 
2, 2.11378, 1, 0, 0.495059,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.429908,-99) , 
3, 139.27, 1, 0, 0.476912,-99) , 
2, 2.59999, 0, 0, 0.494426,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.0284052);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.55854,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530909,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497949,-99) , 
3, 174.746, 0, 0, 0.500837,-99) , 
3, 215.234, 0, 0, 0.50564,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511322,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461796,-99) , 
3, 54.9457, 0, 0, 0.494642,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.442005,-99) , 
3, 139.27, 1, 0, 0.480002,-99) , 
2, 2.59999, 0, 0, 0.499601,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.0339292);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.551525,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514957,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496784,-99) , 
1, 180.462, 1, 0, 0.506694,-99) , 
3, 215.234, 0, 0, 0.510421,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520363,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478373,-99) , 
2, 1.74989, 1, 0, 0.49232,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449022,-99) , 
3, 139.27, 1, 0, 0.480287,-99) , 
2, 2.59999, 0, 0, 0.503326,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.0373778);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 195.334, 0, 1, 0.511627,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543305,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46088,-99) , 
3, 120.927, 0, 0, 0.488038,-99) , 
2, 2.70469, 0, 0, 0.506959,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468674,-99) , 
2, 1.87191, 0, 0, 0.503289,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.0276017);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527866,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512734,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489325,-99) , 
1, 195.334, 0, 0, 0.497195,-99) , 
2, 2.42737, 1, 0, 0.500095,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477991,-99) , 
2, 1.87191, 0, 0, 0.497977,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.0320858);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528143,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499517,-99) , 
0, 192.056, 0, 0, 0.505983,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52476,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.388965,-99) , 
0, 190.001, 1, 0, 0.486502,-99) , 
1, 222.23, 1, 0, 0.501866,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480393,-99) , 
3, 215.044, 1, 0, 0.499899,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.0612622);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.551197,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494099,-99) , 
3, 100.295, 1, 0, 0.522708,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518834,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.436106,-99) , 
1, 171.057, 1, 0, 0.501041,-99) , 
1, 180.904, 0, 0, 0.507828,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535197,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489733,-99) , 
0, 161.821, 0, 0, 0.511748,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.424679,-99) , 
0, 190.001, 1, 0, 0.485954,-99) , 
1, 222.23, 1, 0, 0.503114,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.0490493);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51698,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485975,-99) , 
2, 2.59999, 0, 0, 0.509567,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443936,-99) , 
0, 229.735, 1, 0, 0.5042,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534914,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460479,-99) , 
0, 172.28, 0, 0, 0.496137,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.445477,-99) , 
3, 157.283, 1, 0, 0.48299,-99) , 
1, 149.91, 0, 0, 0.499456,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.0285085);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506739,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456134,-99) , 
2, 4.05613, 1, 0, 0.503172,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456076,-99) , 
0, 229.735, 1, 0, 0.499328,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515949,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495195,-99) , 
0, 172.28, 0, 0, 0.504739,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464826,-99) , 
2, 2.97066, 0, 0, 0.486524,-99) , 
1, 149.91, 0, 0, 0.496466,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.0316918);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515398,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522097,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490191,-99) , 
1, 231.897, 0, 0, 0.495759,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443755,-99) , 
0, 203.241, 1, 0, 0.491144,-99) , 
0, 224.745, 0, 0, 0.493346,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.0478507);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 196.769, 0, 1, 0.519452,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509074,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.446225,-99) , 
1, 171.057, 1, 0, 0.495561,-99) , 
1, 180.904, 0, 0, 0.50306,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534918,-99) , 
NN(
0, 
0, 
-1, 141.143, 1, -1, 0.45515,-99) , 
2, 3.28595, 0, 0, 0.477387,-99) , 
1, 222.23, 1, 0, 0.497537,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.0346099);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.554955,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495233,-99) , 
0, 196.769, 0, 0, 0.507498,-99) , 
NN(
0, 
0, 
-1, 171.057, 1, -1, 0.488734,-99) , 
1, 180.904, 0, 0, 0.494624,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525487,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477385,-99) , 
2, 2.93867, 1, 0, 0.500912,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438715,-99) , 
0, 190.001, 1, 0, 0.482644,-99) , 
1, 222.23, 1, 0, 0.492049,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.0395263);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527172,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475501,-99) , 
3, 69.3293, 0, 0, 0.512603,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505765,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466681,-99) , 
1, 171.057, 1, 0, 0.497384,-99) , 
1, 180.904, 0, 0, 0.502161,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531622,-99) , 
NN(
0, 
0, 
-1, 141.143, 1, -1, 0.467337,-99) , 
2, 3.28595, 0, 0, 0.4853,-99) , 
1, 222.23, 1, 0, 0.498539,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.0389077);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509971,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478282,-99) , 
2, 3.32806, 1, 0, 0.50289,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45213,-99) , 
0, 229.735, 1, 0, 0.498785,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527014,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468972,-99) , 
3, 106.763, 0, 0, 0.493368,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455412,-99) , 
3, 157.283, 1, 0, 0.483533,-99) , 
1, 149.91, 0, 0, 0.49537,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.0291112);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510192,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519647,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490915,-99) , 
1, 231.897, 0, 0, 0.495919,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443325,-99) , 
0, 203.241, 1, 0, 0.491254,-99) , 
0, 224.745, 0, 0, 0.492959,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.041258);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51757,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490622,-99) , 
1, 177.954, 0, 0, 0.50619,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511891,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458355,-99) , 
3, 91.2654, 0, 0, 0.492804,-99) , 
1, 160.241, 0, 0, 0.500837,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525617,-99) , 
NN(
0, 
0, 
-1, 141.143, 1, -1, 0.465322,-99) , 
2, 3.28595, 0, 0, 0.482133,-99) , 
1, 222.23, 1, 0, 0.496823,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.0586557);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.560482,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491406,-99) , 
3, 75.5327, 1, 0, 0.512189,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523613,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.442315,-99) , 
1, 176.317, 1, 0, 0.4815,-99) , 
3, 58.6198, 0, 0, 0.501016,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543175,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530475,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475053,-99) , 
3, 230.186, 0, 0, 0.482503,-99) , 
2, 3.42591, 0, 0, 0.490762,-99) , 
3, 109.079, 1, 0, 0.496114,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.0336949);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 180.462, 1, 1, 0.51261,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45272,-99) , 
3, 201.865, 1, 0, 0.506311,-99) , 
NN(
NN(
0, 
0, 
-1, 3.08656, 0, 1, 0.520594,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501461,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.431157,-99) , 
0, 219.548, 1, 0, 0.485954,-99) , 
3, 145.597, 0, 0, 0.495925,-99) , 
0, 174.631, 1, 0, 0.501627,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.0484351);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53523,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482064,-99) , 
0, 151.532, 0, 0, 0.509466,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503697,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457629,-99) , 
0, 150.738, 1, 0, 0.475352,-99) , 
3, 145.079, 1, 0, 0.49966,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512136,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489706,-99) , 
3, 138.928, 0, 0, 0.499904,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51267,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.436378,-99) , 
3, 54.8605, 0, 0, 0.468175,-99) , 
3, 75.0942, 0, 0, 0.490143,-99) , 
0, 174.631, 1, 0, 0.495368,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.0427482);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.56557,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503251,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463064,-99) , 
2, 3.32806, 1, 0, 0.493561,-99) , 
3, 130.943, 0, 0, 0.499833,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509876,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524093,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.434755,-99) , 
2, 2.86682, 1, 0, 0.477023,-99) , 
2, 3.14878, 0, 0, 0.487626,-99) , 
3, 144.401, 1, 0, 0.49628,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.0255732);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537477,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482585,-99) , 
2, 4.26436, 0, 0, 0.506423,-99) , 
NN(
0, 
0, 
-1, 224.745, 1, -1, 0.489046,-99) , 
2, 3.69209, 0, 0, 0.491142,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.0264627);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520492,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496099,-99) , 
2, 2.59999, 1, 0, 0.501581,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473525,-99) , 
3, 215.044, 1, 0, 0.499192,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523168,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484809,-99) , 
2, 2.93867, 1, 0, 0.503701,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450608,-99) , 
0, 190.001, 1, 0, 0.488315,-99) , 
1, 222.23, 1, 0, 0.496864,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.0165636);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 223.318, 0, 1, 0.505071,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463162,-99) , 
1, 313.078, 1, 0, 0.502612,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479006,-99) , 
2, 1.87191, 0, 0, 0.500351,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.0262841);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538376,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486544,-99) , 
3, 74.7841, 0, 0, 0.510727,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504275,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.439301,-99) , 
3, 215.044, 1, 0, 0.498331,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465756,-99) , 
0, 224.745, 1, 0, 0.49562,-99) , 
2, 3.69209, 0, 0, 0.497442,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.0229512);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516974,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501762,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48168,-99) , 
3, 144.401, 1, 0, 0.49597,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443702,-99) , 
0, 203.241, 1, 0, 0.491353,-99) , 
0, 224.745, 0, 0, 0.493646,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.0277396);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511241,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511904,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489684,-99) , 
1, 231.897, 0, 0, 0.493541,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449374,-99) , 
0, 203.241, 1, 0, 0.489644,-99) , 
0, 224.745, 0, 0, 0.491576,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.0296089);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511956,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497324,-99) , 
0, 178.906, 0, 0, 0.502836,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517567,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44666,-99) , 
1, 127.742, 1, 0, 0.484582,-99) , 
1, 139.578, 0, 0, 0.499497,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513385,-99) , 
NN(
0, 
0, 
-1, 141.143, 1, -1, 0.466908,-99) , 
2, 3.28595, 0, 0, 0.479756,-99) , 
1, 222.23, 1, 0, 0.495269,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.0372095);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531637,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493072,-99) , 
1, 183.041, 1, 0, 0.515599,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5067,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451913,-99) , 
2, 2.85107, 1, 0, 0.491381,-99) , 
2, 2.98976, 0, 0, 0.503857,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524369,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494122,-99) , 
3, 202.711, 0, 0, 0.499366,-99) , 
NN(
0, 
0, 
-1, 51.5093, 0, -1, 0.464987,-99) , 
3, 75.0942, 0, 0, 0.488804,-99) , 
0, 174.631, 1, 0, 0.497075,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.0271282);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511122,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499689,-99) , 
3, 109.079, 1, 0, 0.505982,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510251,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453361,-99) , 
1, 127.742, 1, 0, 0.483828,-99) , 
1, 139.578, 0, 0, 0.501932,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514885,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50542,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.423798,-99) , 
3, 141.143, 1, 0, 0.47625,-99) , 
2, 3.28595, 0, 0, 0.48694,-99) , 
1, 222.23, 1, 0, 0.498722,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.0347193);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537135,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.555216,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492955,-99) , 
2, 2.19544, 1, 0, 0.499126,-99) , 
3, 233.548, 0, 0, 0.502292,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510813,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470336,-99) , 
1, 198.941, 1, 0, 0.496885,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.43806,-99) , 
2, 2.23595, 0, 0, 0.485084,-99) , 
3, 73.7577, 0, 0, 0.497512,-99)    );
   return;
};
 
// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
