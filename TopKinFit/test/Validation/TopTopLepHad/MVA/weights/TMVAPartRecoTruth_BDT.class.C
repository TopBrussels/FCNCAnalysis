// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.06/01       [394753]
Creator        : kskovpen
Date           : Wed Jan 11 10:50:49 2017
Host           : Linux vocms0315.cern.ch 2.6.32-573.26.1.el6.x86_64 #1 SMP Wed May 4 09:23:05 CEST 2016 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /storage_mnt/storage/user/kskovpen/analysis/tHFCNC/CMSSW_8_0_12/src/TopKinFit/test/Validation/TopTopLepHad/MVA
Training events: 23314
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
SeparationType: "giniindex" [Separation criterion for node splitting]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
MinNodeSize: "5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "2" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 4
TopHadRecMTruth               TopHadRecMTruth               TopHadRecMTruth               TopHadRecMTruth                                                 'F'    [63.8264579773,1562.26623535]
TopLepRecMTTruth              TopLepRecMTTruth              TopLepRecMTTruth              TopLepRecMTTruth                                                'F'    [4.97143602371,909.168029785]
TopLepTopHadRecDphiTTruth     TopLepTopHadRecDphiTTruth     TopLepTopHadRecDphiTTruth     TopLepTopHadRecDphiTTruth                                       'F'    [-3.141528368,3.14150238037]
TopLepRecPtTTruth             TopLepRecPtTTruth             TopLepRecPtTTruth             TopLepRecPtTTruth                                               'F'    [0.659672319889,735.196960449]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTNode
   
#ifndef BDTNode__def
#define BDTNode__def
   
class BDTNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 4 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "TopHadRecMTruth", "TopLepRecMTTruth", "TopLepTopHadRecDphiTTruth", "TopLepRecPtTTruth" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[4];
   double fVmax[4];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[4];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadBDT::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(0.64984628848203);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 197.233, 0, 1, 0.846731,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.637861,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.324863,-99) , 
1, 177.199, 1, 0, 0.568644,-99) , 
3, 140.572, 0, 0, 0.678558,-99) , 
NN(
0, 
0, 
-1, 271.153, 1, -1, 0.0681967,-99) , 
0, 206.535, 1, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.408926);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 228.861, 0, 1, 0.832466,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540901,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.227842,-99) , 
0, 132.838, 0, 0, 0.499908,-99) , 
3, 175.549, 0, 0, 0.574048,-99) , 
NN(
0, 
0, 
-1, 271.153, 1, -1, 0.12294,-99) , 
0, 206.535, 1, 0, 0.456825,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.357238);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 130.957, 1, 1, 0.704068,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512138,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.339718,-99) , 
0, 147.878, 0, 0, 0.456759,-99) , 
NN(
0, 
0, 
-1, 244.586, 1, -1, 0.151083,-99) , 
0, 188.907, 1, 0, 0.347147,-99) , 
3, 175.549, 0, 0, 0.417106,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.317987);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 260.516, 0, 1, 0.768665,-99) , 
NN(
0, 
0, 
-1, 220.256, 1, -1, 0.400145,-99) , 
3, 210.527, 0, 0, 0.443419,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0303616,-99) , 
0, 277.889, 1, 0, 0.403093,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.275617);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.679275,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463686,-99) , 
3, 140.572, 0, 0, 0.534745,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.201253,-99) , 
1, 220.256, 1, 0, 0.503885,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0412587,-99) , 
0, 277.889, 1, 0, 0.463447,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.261805);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.577957,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.298162,-99) , 
0, 226.844, 1, 0, 0.559438,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.249203,-99) , 
1, 220.256, 1, 0, 0.532311,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0536495,-99) , 
0, 277.889, 1, 0, 0.49433,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.140235);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.743427,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487259,-99) , 
3, 245.505, 0, 0, 0.503041,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.301312,-99) , 
1, 220.256, 1, 0, 0.486111,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0686038,-99) , 
0, 277.889, 1, 0, 0.455822,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.142653);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 245.505, 0, 1, 0.533858,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.331629,-99) , 
1, 220.256, 1, 0, 0.517261,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0781249,-99) , 
0, 277.889, 1, 0, 0.487033,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.143861);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.601267,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490022,-99) , 
2, 2.84231, 0, 0, 0.513837,-99) , 
NN(
0, 
0, 
-1, 102.767, 0, -1, 0.374848,-99) , 
0, 196.278, 1, 0, 0.487422,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0890371,-99) , 
0, 277.889, 1, 0, 0.461384,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.16696);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.555534,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.412581,-99) , 
0, 127.868, 0, 0, 0.541025,-99) , 
NN(
0, 
0, 
-1, 170.454, 1, -1, 0.430114,-99) , 
0, 186.09, 1, 0, 0.51095,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.101416,-99) , 
0, 277.889, 1, 0, 0.485501,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.122854);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.665861,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518139,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.445942,-99) , 
3, 93.9082, 0, 0, 0.487637,-99) , 
3, 245.505, 0, 0, 0.498031,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.117676,-99) , 
0, 277.889, 1, 0, 0.475657,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.0874325);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.637994,-99) , 
NN(
0, 
0, 
-1, 226.844, 1, -1, 0.482811,-99) , 
3, 245.505, 0, 0, 0.491722,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.131042,-99) , 
0, 277.889, 1, 0, 0.471348,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.0943254);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 210.527, 0, 1, 0.521718,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.386904,-99) , 
1, 220.256, 1, 0, 0.511081,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.141323,-99) , 
0, 277.889, 1, 0, 0.49079,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.0967875);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.555373,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483934,-99) , 
2, -2.84234, 1, 0, 0.499566,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.371012,-99) , 
0, 226.844, 1, 0, 0.491212,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.153162,-99) , 
0, 277.889, 1, 0, 0.473208,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.0786469);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549533,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496905,-99) , 
2, 2.54312, 0, 0, 0.513195,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.393866,-99) , 
0, 226.844, 1, 0, 0.505513,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.166141,-99) , 
0, 277.889, 1, 0, 0.487963,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.0820845);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.622988,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514736,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.396495,-99) , 
0, 226.844, 1, 0, 0.507385,-99) , 
3, 245.505, 0, 0, 0.513808,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.177324,-99) , 
0, 277.889, 1, 0, 0.496811,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.071047);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.60354,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497212,-99) , 
3, 210.527, 0, 0, 0.506931,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.295022,-99) , 
0, 243.677, 1, 0, 0.491934,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.361502,-99) , 
1, 220.256, 1, 0, 0.480596,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.0819594);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 209.381, 0, 1, 0.521458,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.310011,-99) , 
0, 243.677, 1, 0, 0.506684,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.378057,-99) , 
1, 220.256, 1, 0, 0.495585,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.0627391);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.587943,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493045,-99) , 
0, 209.381, 0, 0, 0.500981,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.327809,-99) , 
0, 243.677, 1, 0, 0.489038,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.397511,-99) , 
1, 220.256, 1, 0, 0.481192,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.0992327);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525123,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466164,-99) , 
1, 91.0854, 0, 0, 0.516881,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.413723,-99) , 
0, 192.934, 1, 0, 0.507203,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.595805,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.446874,-99) , 
1, 136.591, 1, 0, 0.523666,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.220243,-99) , 
0, 271.153, 1, 0, 0.431474,-99) , 
0, 206.535, 1, 0, 0.494629,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.0609244);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.586459,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503934,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44395,-99) , 
0, 179.343, 1, 0, 0.48869,-99) , 
NN(
0, 
0, 
-1, 105.485, 0, -1, 0.420694,-99) , 
0, 206.535, 1, 0, 0.477927,-99) , 
3, 245.505, 0, 0, 0.484156,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.0848867);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520313,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454272,-99) , 
0, 158.009, 0, 0, 0.495955,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.362706,-99) , 
0, 243.677, 1, 0, 0.487067,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.398047,-99) , 
1, 220.256, 1, 0, 0.479576,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.0607006);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.569999,-99) , 
NN(
NN(
0, 
0, 
-1, 172.548, 1, -1, 0.479296,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501167,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.360909,-99) , 
3, 105.485, 0, 0, 0.434287,-99) , 
0, 206.535, 1, 0, 0.472268,-99) , 
3, 245.505, 0, 0, 0.477821,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.10259);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.647541,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522633,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454137,-99) , 
1, 134.142, 0, 0, 0.489593,-99) , 
3, 177.263, 0, 0, 0.517889,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.64906,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480628,-99) , 
3, 187.81, 0, 0, 0.502943,-99) , 
NN(
0, 
0, 
-1, 133.63, 1, -1, 0.428287,-99) , 
2, 1.51734, 0, 0, 0.475142,-99) , 
2, -2.54314, 1, 0, 0.48891,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.0891007);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.24393, 0, 1, 0.586235,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510582,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457641,-99) , 
1, 103.384, 0, 0, 0.497531,-99) , 
3, 175.549, 0, 0, 0.512769,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.579652,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485642,-99) , 
1, 212.064, 1, 0, 0.537428,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.312973,-99) , 
3, 134.262, 1, 0, 0.461424,-99) , 
1, 177.199, 1, 0, 0.501684,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.0626761);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 177.199, 0, 1, 0.516159,-99) , 
NN(
0, 
0, 
-1, 71.8185, 0, -1, 0.473669,-99) , 
0, 172.548, 1, 0, 0.500973,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541952,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.363306,-99) , 
1, 136.591, 1, 0, 0.449252,-99) , 
0, 206.535, 1, 0, 0.492631,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.0717964);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.579734,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529738,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454486,-99) , 
2, 2.71472, 1, 0, 0.487716,-99) , 
3, 156.674, 0, 0, 0.508836,-99) , 
NN(
0, 
0, 
-1, -1.00449, 1, -1, 0.473576,-99) , 
2, 1.34635, 0, 0, 0.488959,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.0715319);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 176.258, 0, 1, 0.528116,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516611,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454087,-99) , 
2, 2.11572, 0, 0, 0.492147,-99) , 
2, -2.24395, 1, 0, 0.505949,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532907,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.384342,-99) , 
1, 136.591, 1, 0, 0.456108,-99) , 
0, 206.535, 1, 0, 0.497976,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.0468346);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.577798,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48911,-99) , 
3, 91.0311, 1, 0, 0.526236,-99) , 
NN(
0, 
0, 
-1, 131.775, 0, -1, 0.488964,-99) , 
1, 177.199, 0, 0, 0.496688,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515067,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.401402,-99) , 
1, 136.591, 1, 0, 0.456478,-99) , 
0, 206.535, 1, 0, 0.490274,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.0429776);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549966,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509617,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.446834,-99) , 
0, 131.775, 0, 0, 0.502754,-99) , 
1, 220.256, 0, 0, 0.506368,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501075,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.391014,-99) , 
3, 100.552, 0, 0, 0.456722,-99) , 
0, 206.535, 1, 0, 0.498462,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.0378021);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539308,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504454,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473338,-99) , 
0, 152.16, 0, 0, 0.494357,-99) , 
1, 220.256, 0, 0, 0.497793,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500505,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.411325,-99) , 
1, 136.591, 1, 0, 0.454551,-99) , 
0, 206.535, 1, 0, 0.490913,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.0401773);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524753,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490913,-99) , 
1, 177.199, 0, 0, 0.497943,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455577,-99) , 
0, 192.934, 1, 0, 0.494005,-99) , 
NN(
0, 
0, 
-1, 100.552, 0, -1, 0.454762,-99) , 
0, 206.535, 1, 0, 0.487767,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.059997);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.593581,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501385,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.428414,-99) , 
0, 228.556, 1, 0, 0.495299,-99) , 
3, 210.527, 0, 0, 0.504092,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.563228,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481902,-99) , 
3, 77.3442, 0, 0, 0.525727,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.329251,-99) , 
3, 134.262, 1, 0, 0.459412,-99) , 
1, 177.199, 1, 0, 0.494623,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.0765415);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.57903,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518535,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474809,-99) , 
3, 150.553, 0, 0, 0.482798,-99) , 
3, 210.527, 0, 0, 0.491367,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549594,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493584,-99) , 
1, 212.064, 1, 0, 0.524623,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.342634,-99) , 
3, 134.262, 1, 0, 0.463513,-99) , 
1, 177.199, 1, 0, 0.485484,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.080455);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.571142,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547254,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485968,-99) , 
3, 120.564, 0, 0, 0.496532,-99) , 
0, 132.715, 1, 0, 0.503979,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.582331,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473833,-99) , 
2, -2.54314, 1, 0, 0.513487,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.334845,-99) , 
1, 170.414, 1, 0, 0.470974,-99) , 
3, 140.572, 1, 0, 0.493909,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.08447);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 177.199, 0, 1, 0.522963,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518095,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.419024,-99) , 
3, 74.0313, 0, 0, 0.481237,-99) , 
0, 193.977, 1, 0, 0.513858,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.603315,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47194,-99) , 
2, 2.54312, 0, 0, 0.518967,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.352995,-99) , 
1, 170.414, 1, 0, 0.479758,-99) , 
3, 140.572, 1, 0, 0.503483,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.0350061);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543232,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50429,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460029,-99) , 
2, 2.84223, 1, 0, 0.496182,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505822,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.387967,-99) , 
1, 170.414, 1, 0, 0.478228,-99) , 
3, 140.532, 1, 0, 0.491412,-99) , 
3, 245.505, 0, 0, 0.494072,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.0299318);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534534,-99) , 
NN(
0, 
0, 
-1, 140.532, 1, -1, 0.486097,-99) , 
3, 245.505, 0, 0, 0.488581,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.046271);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.56742,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50432,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478032,-99) , 
1, 119.786, 0, 0, 0.493076,-99) , 
3, 210.527, 0, 0, 0.49958,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53636,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496445,-99) , 
3, 77.3442, 0, 0, 0.518022,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.399647,-99) , 
3, 134.262, 1, 0, 0.479069,-99) , 
1, 177.199, 1, 0, 0.495294,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.0547818);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.559126,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501973,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.447717,-99) , 
2, -2.84228, 0, 0, 0.490557,-99) , 
3, 175.704, 0, 0, 0.503031,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514709,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459704,-99) , 
3, 138.849, 1, 0, 0.499844,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.385857,-99) , 
0, 215.542, 1, 0, 0.48566,-99) , 
1, 134.142, 1, 0, 0.493944,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0712358);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.578833,-99) , 
NN(
0, 
0, 
-1, 68.1068, 0, -1, 0.482489,-99) , 
3, 176.258, 0, 0, 0.498663,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.55361,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475275,-99) , 
3, 156.674, 0, 0, 0.492717,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51312,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.373395,-99) , 
3, 100.378, 1, 0, 0.453133,-99) , 
2, 1.34638, 0, 0, 0.480943,-99) , 
2, -2.24395, 1, 0, 0.487653,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0492401);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 134.73, 0, 1, 0.523664,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457792,-99) , 
3, 71.4571, 0, 0, 0.510508,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.558541,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494854,-99) , 
3, 187.81, 0, 0, 0.502597,-99) , 
NN(
0, 
0, 
-1, 100.378, 1, -1, 0.450398,-99) , 
2, 1.34638, 0, 0, 0.487095,-99) , 
2, -2.24395, 1, 0, 0.495966,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.0321209);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 156.674, 0, 1, 0.518295,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470442,-99) , 
1, 195.584, 1, 0, 0.511919,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501884,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473918,-99) , 
2, -0.364379, 1, 0, 0.498744,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.40697,-99) , 
3, 210.527, 1, 0, 0.489868,-99) , 
2, 1.34635, 0, 0, 0.499503,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.0343319);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541103,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518396,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488358,-99) , 
2, 2.71472, 1, 0, 0.501207,-99) , 
3, 187.81, 0, 0, 0.506033,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501835,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482484,-99) , 
2, -2.71422, 0, 0, 0.492516,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.414745,-99) , 
3, 210.527, 1, 0, 0.485014,-99) , 
2, 1.34635, 0, 0, 0.494197,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.04711);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.576142,-99) , 
NN(
0, 
0, 
-1, 120.521, 1, -1, 0.490766,-99) , 
3, 157.534, 0, 0, 0.511598,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516826,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487148,-99) , 
2, -1.24666, 0, 0, 0.497229,-99) , 
NN(
0, 
0, 
-1, 133.344, 1, -1, 0.433154,-99) , 
3, 175.549, 1, 0, 0.486957,-99) , 
2, 2.54312, 0, 0, 0.494521,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.0525234);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.564599,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5117,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481966,-99) , 
3, 120.521, 1, 0, 0.502542,-99) , 
3, 157.534, 0, 0, 0.517648,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.599432,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49945,-99) , 
3, 177.263, 0, 0, 0.51714,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50291,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.308332,-99) , 
3, 166.873, 1, 0, 0.471983,-99) , 
2, -2.60014, 1, 0, 0.492006,-99) , 
2, 2.54312, 0, 0, 0.499877,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.0586157);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.583477,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520037,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465884,-99) , 
3, 69.3203, 0, 0, 0.509194,-99) , 
3, 177.263, 0, 0, 0.521917,-99) , 
NN(
NN(
0, 
0, 
-1, 157.534, 0, 1, 0.514232,-99) , 
NN(
0, 
0, 
-1, 166.873, 1, -1, 0.462617,-99) , 
2, 2.60012, 0, 0, 0.484916,-99) , 
2, -2.54314, 1, 0, 0.496874,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0372091);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548631,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521318,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497852,-99) , 
1, 177.199, 0, 0, 0.502704,-99) , 
2, -3.05606, 1, 0, 0.511173,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519863,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488453,-99) , 
2, -0.192129, 1, 0, 0.49484,-99) , 
NN(
0, 
0, 
-1, 130.726, 1, -1, 0.441479,-99) , 
3, 166.857, 1, 0, 0.485175,-99) , 
2, -2.24395, 1, 0, 0.49505,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0465546);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -2.97064, 1, 1, 0.537685,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521576,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474602,-99) , 
0, 175.477, 1, 0, 0.502841,-99) , 
3, 141.324, 0, 0, 0.513914,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512074,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485838,-99) , 
1, 158.799, 1, 0, 0.504158,-99) , 
NN(
0, 
0, 
-1, 100.378, 1, -1, 0.460788,-99) , 
2, 1.34638, 0, 0, 0.491372,-99) , 
2, -2.24395, 1, 0, 0.499936,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0508827);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -1.64548, 0, 1, 0.534931,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505103,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475571,-99) , 
1, 144.39, 1, 0, 0.496363,-99) , 
1, 177.199, 0, 0, 0.504463,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.57323,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482717,-99) , 
2, -2.84234, 1, 0, 0.507503,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.402199,-99) , 
1, 170.414, 1, 0, 0.482894,-99) , 
3, 140.572, 1, 0, 0.498028,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.0311963);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.597245,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496456,-99) , 
3, 210.527, 0, 0, 0.504634,-99) , 
NN(
0, 
0, 
-1, 134.262, 1, -1, 0.475162,-99) , 
1, 177.199, 1, 0, 0.498576,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472122,-99) , 
0, 135.181, 0, 0, 0.495473,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.0286446);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -2.84234, 1, 1, 0.511022,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504829,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.447742,-99) , 
3, 100.552, 0, 0, 0.481447,-99) , 
0, 203.153, 1, 0, 0.505371,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479903,-99) , 
0, 135.181, 0, 0, 0.502385,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.0552278);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525221,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46624,-99) , 
3, 58.9505, 0, 0, 0.510764,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519438,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483862,-99) , 
3, 59.0905, 1, 0, 0.490535,-99) , 
1, 134.142, 0, 0, 0.501294,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549007,-99) , 
NN(
0, 
0, 
-1, 130.957, 1, -1, 0.441936,-99) , 
2, -2.54314, 1, 0, 0.480112,-99) , 
3, 175.549, 1, 0, 0.497892,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.0319572);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533551,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503125,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483818,-99) , 
2, -2.84228, 0, 0, 0.499327,-99) , 
3, 158.89, 0, 0, 0.501591,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.567175,-99) , 
NN(
0, 
0, 
-1, 133.344, 1, -1, 0.443291,-99) , 
2, 2.54312, 0, 0, 0.484024,-99) , 
3, 175.549, 1, 0, 0.498774,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.0401287);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531202,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503356,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487502,-99) , 
2, -2.59205, 1, 0, 0.499748,-99) , 
2, -3.05606, 1, 0, 0.505509,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.55815,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483017,-99) , 
3, 157.534, 0, 0, 0.50185,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501516,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.404737,-99) , 
3, 133.617, 1, 0, 0.477154,-99) , 
2, 2.62861, 0, 0, 0.488505,-99) , 
2, -2.24395, 1, 0, 0.494967,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.0294013);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547151,-99) , 
NN(
0, 
0, 
-1, 68.7228, 0, -1, 0.48889,-99) , 
3, 157.534, 0, 0, 0.502979,-99) , 
NN(
0, 
0, 
-1, 210.527, 1, -1, 0.487584,-99) , 
2, 2.54312, 0, 0, 0.492323,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.044026);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545258,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465314,-99) , 
1, 66.473, 0, 0, 0.515593,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528101,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491336,-99) , 
0, 185.558, 0, 0, 0.502168,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506436,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.376321,-99) , 
1, 239.497, 1, 0, 0.480564,-99) , 
1, 169, 1, 0, 0.495841,-99) , 
1, 91.0854, 1, 0, 0.498578,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.0357245);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 210.527, 0, 1, 0.509464,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464322,-99) , 
1, 160.792, 1, 0, 0.503973,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524023,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48307,-99) , 
2, -1.64548, 0, 0, 0.507009,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.427525,-99) , 
3, 134.262, 1, 0, 0.481311,-99) , 
1, 177.199, 1, 0, 0.499265,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.0382268);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53462,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495373,-99) , 
2, -2.97077, 1, 0, 0.50912,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470653,-99) , 
0, 208.366, 1, 0, 0.503869,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538221,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494628,-99) , 
3, 157.534, 0, 0, 0.505511,-99) , 
NN(
0, 
0, 
-1, 133.617, 1, -1, 0.473887,-99) , 
2, 2.62861, 0, 0, 0.48842,-99) , 
2, -2.24395, 1, 0, 0.494295,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.0348063);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 139.857, 1, 1, 0.516707,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505782,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472059,-99) , 
0, 193.977, 1, 0, 0.498603,-99) , 
3, 125.578, 0, 0, 0.503502,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539394,-99) , 
NN(
0, 
0, 
-1, 130.957, 1, -1, 0.451859,-99) , 
2, -2.54314, 1, 0, 0.483325,-99) , 
3, 175.549, 1, 0, 0.500294,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.0265156);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547392,-99) , 
NN(
0, 
0, 
-1, 78.781, 0, -1, 0.494256,-99) , 
3, 210.527, 0, 0, 0.498515,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525651,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496317,-99) , 
2, 1.64527, 0, 0, 0.507993,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.43562,-99) , 
3, 134.262, 1, 0, 0.484624,-99) , 
1, 177.199, 1, 0, 0.495635,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.0249046);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540814,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503973,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472626,-99) , 
1, 78.781, 0, 0, 0.500884,-99) , 
3, 210.527, 0, 0, 0.504082,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516611,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499147,-99) , 
2, -1.64548, 0, 0, 0.509348,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44215,-99) , 
3, 134.262, 1, 0, 0.48767,-99) , 
1, 177.199, 1, 0, 0.50068,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.0347565);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -2.54932, 0, 1, 0.512529,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522627,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4806,-99) , 
3, 144.479, 0, 0, 0.496144,-99) , 
2, -2.88511, 0, 0, 0.504311,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525129,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491892,-99) , 
3, 126.453, 0, 0, 0.506605,-99) , 
NN(
0, 
0, 
-1, 133.617, 1, -1, 0.480253,-99) , 
2, 2.62861, 0, 0, 0.492363,-99) , 
2, -2.24395, 1, 0, 0.496908,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.0375296);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544427,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507097,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480292,-99) , 
3, 60.6118, 0, 0, 0.499725,-99) , 
0, 132.715, 1, 0, 0.504167,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540836,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493114,-99) , 
2, 2.84231, 0, 0, 0.505721,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.422302,-99) , 
1, 170.414, 1, 0, 0.486308,-99) , 
3, 140.572, 1, 0, 0.498885,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.0312821);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522174,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496174,-99) , 
2, -0.106853, 1, 0, 0.503292,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518774,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481034,-99) , 
3, 134.435, 0, 0, 0.490512,-99) , 
2, -2.54309, 0, 0, 0.499245,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458045,-99) , 
2, -1.94476, 1, 0, 0.486302,-99) , 
3, 175.549, 1, 0, 0.497199,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.0246163);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520455,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497978,-99) , 
1, 116.749, 0, 0, 0.511831,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480468,-99) , 
1, 195.584, 1, 0, 0.507677,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518129,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496783,-99) , 
2, -1.21887, 0, 0, 0.500452,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437703,-99) , 
3, 210.527, 1, 0, 0.494843,-99) , 
2, 1.34635, 0, 0, 0.500465,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.029378);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545687,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488287,-99) , 
1, 74.6732, 0, 0, 0.515715,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512509,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488271,-99) , 
1, 117.058, 0, 0, 0.505253,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501734,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461859,-99) , 
3, 134.262, 1, 0, 0.489148,-99) , 
1, 169, 1, 0, 0.500555,-99) , 
1, 91.0854, 1, 0, 0.502654,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.0249364);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548453,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492811,-99) , 
2, 1.94467, 0, 0, 0.516054,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519325,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495216,-99) , 
0, 185.558, 0, 0, 0.502307,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500601,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473174,-99) , 
3, 101.061, 1, 0, 0.486435,-99) , 
1, 169, 1, 0, 0.497677,-99) , 
1, 91.0854, 1, 0, 0.500221,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.0355455);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528508,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511686,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4936,-99) , 
0, 175.477, 1, 0, 0.504355,-99) , 
3, 175.704, 0, 0, 0.508541,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.555532,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496887,-99) , 
1, 207.961, 0, 0, 0.50786,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.409887,-99) , 
0, 215.542, 1, 0, 0.495981,-99) , 
1, 134.142, 1, 0, 0.501982,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.0257375);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 210.527, 0, 1, 0.51179,-99) , 
NN(
0, 
0, 
-1, 212.064, 1, -1, 0.480963,-99) , 
1, 177.199, 1, 0, 0.505493,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490179,-99) , 
0, 135.181, 0, 0, 0.503699,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.0257661);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533662,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499562,-99) , 
1, 138.52, 0, 0, 0.514422,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504008,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487661,-99) , 
3, 95.8334, 1, 0, 0.498851,-99) , 
3, 125.578, 0, 0, 0.503064,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537723,-99) , 
NN(
0, 
0, 
-1, 133.344, 1, -1, 0.467375,-99) , 
2, 2.54312, 0, 0, 0.490548,-99) , 
3, 175.549, 1, 0, 0.501093,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.0270007);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -2.97064, 1, 1, 0.52115,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509416,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485616,-99) , 
0, 175.477, 1, 0, 0.499958,-99) , 
3, 141.324, 0, 0, 0.506654,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507916,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482036,-99) , 
3, 63.2669, 0, 0, 0.503012,-99) , 
NN(
0, 
0, 
-1, -0.192368, 1, -1, 0.479674,-99) , 
2, 1.34638, 0, 0, 0.496179,-99) , 
2, -2.24395, 1, 0, 0.500167,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.0211721);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523378,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517483,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494925,-99) , 
1, 177.199, 0, 0, 0.499646,-99) , 
2, -3.04184, 1, 0, 0.503758,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503893,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48813,-99) , 
0, 183.727, 1, 0, 0.49882,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468763,-99) , 
2, 1.34676, 0, 0, 0.493611,-99) , 
2, -1.04718, 1, 0, 0.498382,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.0250496);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -3.04184, 1, 1, 0.513116,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512012,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486548,-99) , 
2, -2.54436, 0, 0, 0.496827,-99) , 
3, 105.768, 0, 0, 0.505386,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511113,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49188,-99) , 
1, 151.779, 0, 0, 0.496948,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467461,-99) , 
1, 195.584, 1, 0, 0.492968,-99) , 
2, -1.04718, 1, 0, 0.498806,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.0199153);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514998,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499215,-99) , 
3, 117.244, 0, 0, 0.504075,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500831,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472676,-99) , 
3, 92.9643, 0, 0, 0.490751,-99) , 
2, 2.84223, 1, 0, 0.501438,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527657,-99) , 
NN(
0, 
0, 
-1, 133.344, 1, -1, 0.468547,-99) , 
2, 2.54312, 0, 0, 0.48805,-99) , 
3, 175.549, 1, 0, 0.499333,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.0294055);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54207,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503206,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487473,-99) , 
2, 2.84223, 1, 0, 0.500359,-99) , 
0, 132.715, 1, 0, 0.504496,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539235,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488221,-99) , 
3, 197.233, 0, 0, 0.505821,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443817,-99) , 
1, 170.414, 1, 0, 0.491475,-99) , 
3, 140.572, 1, 0, 0.500657,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.0244694);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537978,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490523,-99) , 
1, 78.7733, 0, 0, 0.508871,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517688,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493385,-99) , 
0, 185.558, 0, 0, 0.500527,-99) , 
NN(
0, 
0, 
-1, -2.54309, 0, -1, 0.486573,-99) , 
1, 169, 1, 0, 0.496463,-99) , 
1, 91.0854, 1, 0, 0.49818,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.0217761);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521764,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497245,-99) , 
0, 183.811, 1, 0, 0.514291,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511854,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496912,-99) , 
1, 177.199, 0, 0, 0.500051,-99) , 
3, 133.906, 0, 0, 0.503039,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527542,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467416,-99) , 
2, -1.94476, 1, 0, 0.492897,-99) , 
3, 175.549, 1, 0, 0.501448,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.021231);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521161,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506523,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493413,-99) , 
2, -2.84228, 0, 0, 0.503949,-99) , 
3, 158.89, 0, 0, 0.505088,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531896,-99) , 
NN(
0, 
0, 
-1, 133.344, 1, -1, 0.474911,-99) , 
2, 2.54312, 0, 0, 0.493723,-99) , 
3, 175.549, 1, 0, 0.503306,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.0178186);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529428,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498381,-99) , 
2, -2.97077, 1, 0, 0.509223,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483884,-99) , 
0, 208.366, 1, 0, 0.505809,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517572,-99) , 
NN(
0, 
0, 
-1, 198.769, 1, -1, 0.494594,-99) , 
1, 91.0372, 1, 0, 0.497647,-99) , 
2, -2.24395, 1, 0, 0.500755,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.0177516);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523466,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510302,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498798,-99) , 
3, 92.4458, 1, 0, 0.503905,-99) , 
3, 175.704, 0, 0, 0.506973,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506754,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488831,-99) , 
2, 1.14746, 0, 0, 0.503995,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476772,-99) , 
1, 195.584, 1, 0, 0.500325,-99) , 
2, -1.04718, 1, 0, 0.503452,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.0259064);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 177.199, 0, 1, 0.509933,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485626,-99) , 
0, 208.366, 1, 0, 0.506569,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518252,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492722,-99) , 
0, 160.888, 0, 0, 0.503555,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51129,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47059,-99) , 
1, 122.015, 1, 0, 0.485834,-99) , 
0, 183.727, 1, 0, 0.49782,-99) , 
2, -0.149609, 1, 0, 0.502231,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.028919);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519157,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506697,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.422782,-99) , 
0, 230.291, 1, 0, 0.500472,-99) , 
1, 220.256, 0, 0, 0.501899,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527002,-99) , 
NN(
0, 
0, 
-1, 133.344, 1, -1, 0.475821,-99) , 
2, 2.54312, 0, 0, 0.492701,-99) , 
3, 175.549, 1, 0, 0.500459,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.0320104);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524611,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484333,-99) , 
2, 1.34634, 0, 0, 0.503011,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.563615,-99) , 
NN(
0, 
0, 
-1, 131.775, 0, -1, 0.488609,-99) , 
1, 220.256, 0, 0, 0.494237,-99) , 
0, 206.535, 0, 0, 0.49558,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.0217544);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53012,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51973,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495085,-99) , 
3, 134.624, 0, 0, 0.500947,-99) , 
3, 176.258, 0, 0, 0.505727,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506635,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482039,-99) , 
1, 147.732, 1, 0, 0.501506,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504079,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475346,-99) , 
1, 202.56, 1, 0, 0.490427,-99) , 
1, 170.414, 1, 0, 0.498786,-99) , 
2, -2.24395, 1, 0, 0.50143,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.0193382);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524698,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511037,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497102,-99) , 
3, 101.365, 1, 0, 0.503799,-99) , 
3, 176.258, 0, 0, 0.507222,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509464,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482781,-99) , 
0, 183.727, 1, 0, 0.501007,-99) , 
NN(
0, 
0, 
-1, 133.617, 1, -1, 0.492336,-99) , 
2, 2.62861, 0, 0, 0.496327,-99) , 
2, -2.24395, 1, 0, 0.500476,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.0220331);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 121.84, 0, 1, 0.512513,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506816,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483578,-99) , 
3, 138.849, 1, 0, 0.50028,-99) , 
1, 134.142, 1, 0, 0.506012,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512758,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494786,-99) , 
1, 150.822, 0, 0, 0.501484,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504603,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472719,-99) , 
3, 121.458, 0, 0, 0.486376,-99) , 
0, 183.727, 1, 0, 0.4966,-99) , 
2, -0.149609, 1, 0, 0.501346,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.0255966);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53854,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505753,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48778,-99) , 
2, 1.94475, 1, 0, 0.498395,-99) , 
3, 210.527, 0, 0, 0.501525,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520213,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483567,-99) , 
3, 101.061, 1, 0, 0.503063,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474372,-99) , 
2, -2.54309, 0, 0, 0.49409,-99) , 
1, 177.199, 1, 0, 0.499996,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.0178915);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5203,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499336,-99) , 
0, 183.727, 0, 0, 0.506081,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48793,-99) , 
1, 195.584, 1, 0, 0.503692,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527904,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496725,-99) , 
3, 177.263, 0, 0, 0.50186,-99) , 
NN(
0, 
0, 
-1, 133.63, 1, -1, 0.486174,-99) , 
2, -2.50042, 1, 0, 0.495526,-99) , 
2, 1.34635, 0, 0, 0.499104,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.0222689);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.364174, 1, 1, 0.508757,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50976,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490335,-99) , 
3, 117.51, 0, 0, 0.497024,-99) , 
2, -1.34636, 0, 0, 0.50343,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521506,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478245,-99) , 
2, 2.24393, 0, 0, 0.494198,-99) , 
3, 175.549, 1, 0, 0.501989,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.0251274);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539718,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509758,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495793,-99) , 
3, 120.564, 0, 0, 0.498193,-99) , 
0, 132.715, 1, 0, 0.502306,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533476,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490195,-99) , 
3, 197.233, 0, 0, 0.505016,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463846,-99) , 
1, 170.414, 1, 0, 0.495537,-99) , 
3, 140.572, 1, 0, 0.500316,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.0206481);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 210.527, 0, 1, 0.50911,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504391,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468928,-99) , 
1, 212.064, 1, 0, 0.488796,-99) , 
1, 177.199, 1, 0, 0.504977,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491291,-99) , 
0, 135.181, 0, 0, 0.503373,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.0325568);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513864,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.598204,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4965,-99) , 
0, 209.381, 0, 0, 0.505048,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.402568,-99) , 
0, 243.677, 1, 0, 0.499066,-99) , 
1, 220.256, 0, 0, 0.500236,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.026019);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -1.24666, 0, 1, 0.509997,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509611,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47602,-99) , 
0, 188.881, 1, 0, 0.501363,-99) , 
2, 2.54304, 1, 0, 0.507372,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52594,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477222,-99) , 
2, -1.94476, 1, 0, 0.497955,-99) , 
3, 175.549, 1, 0, 0.505904,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.014886);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507909,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523665,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505759,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492849,-99) , 
1, 134.142, 0, 0, 0.499498,-99) , 
3, 235.519, 0, 0, 0.50086,-99) , 
3, 35.6376, 1, 0, 0.501385,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.026725);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 90.2121, 1, 1, 0.507732,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482259,-99) , 
1, 72.6323, 0, 0, 0.504173,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549296,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499324,-99) , 
0, 188.54, 0, 0, 0.507941,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.422341,-99) , 
0, 215.542, 1, 0, 0.497739,-99) , 
1, 134.142, 1, 0, 0.500816,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.019207);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527344,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489964,-99) , 
2, 1.94467, 0, 0, 0.505521,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543867,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497305,-99) , 
1, 207.957, 0, 0, 0.502573,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500483,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46802,-99) , 
3, 100.552, 0, 0, 0.486029,-99) , 
0, 208.366, 1, 0, 0.500205,-99) , 
1, 91.0854, 1, 0, 0.500941,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.0284203);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.561545,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487853,-99) , 
0, 168.598, 1, 0, 0.532616,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502696,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464915,-99) , 
1, 160.791, 1, 0, 0.498054,-99) , 
1, 177.199, 0, 0, 0.505026,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513803,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481551,-99) , 
2, 1.34634, 0, 0, 0.496517,-99) , 
0, 206.535, 1, 0, 0.503731,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.0308483);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 188.54, 0, 1, 0.513139,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.428463,-99) , 
0, 215.542, 1, 0, 0.503069,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522803,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493999,-99) , 
3, 140.736, 0, 0, 0.503284,-99) , 
NN(
0, 
0, 
-1, 2.54363, 0, -1, 0.490603,-99) , 
2, -1.04718, 1, 0, 0.496489,-99) , 
1, 134.142, 0, 0, 0.499921,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.0178761);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526915,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504345,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492049,-99) , 
2, 1.64556, 1, 0, 0.499029,-99) , 
3, 210.527, 0, 0, 0.501191,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509634,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486001,-99) , 
3, 101.061, 1, 0, 0.49857,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47969,-99) , 
2, -2.54309, 0, 0, 0.492663,-99) , 
1, 177.199, 1, 0, 0.499441,-99)    );
   return;
};
 
// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
