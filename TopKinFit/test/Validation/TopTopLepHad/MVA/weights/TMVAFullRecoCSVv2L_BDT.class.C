// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.06/01       [394753]
Creator        : kskovpen
Date           : Fri Feb  3 11:10:20 2017
Host           : Linux vocms0301.cern.ch 2.6.32-642.11.1.el6.x86_64 #1 SMP Wed Nov 16 09:40:09 CET 2016 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /storage_mnt/storage/user/kskovpen/analysis/tHFCNC/CMSSW_8_0_25/src/TopKinFit/test/Validation/TopTopLepHad/MVA
Training events: 665850
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
SeparationType: "giniindex" [Separation criterion for node splitting]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
MinNodeSize: "5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "2" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 4
TopHadRecMCSVv2L              TopHadRecMCSVv2L              TopHadRecMCSVv2L              TopHadRecMCSVv2L                                                'F'    [34.366519928,4203.75732422]
TopLepRecMCSVv2L              TopLepRecMCSVv2L              TopLepRecMCSVv2L              TopLepRecMCSVv2L                                                'F'    [51.2727279663,4464.16748047]
TopLepTopHadRecDrCSVv2L       TopLepTopHadRecDrCSVv2L       TopLepTopHadRecDrCSVv2L       TopLepTopHadRecDrCSVv2L                                         'F'    [0.00615907181054,10.6436824799]
TopLepRecPtCSVv2L             TopLepRecPtCSVv2L             TopLepRecPtCSVv2L             TopLepRecPtCSVv2L                                               'F'    [0.173498287797,1331.37036133]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTNode
   
#ifndef BDTNode__def
#define BDTNode__def
   
class BDTNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 4 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "TopHadRecMCSVv2L", "TopLepRecMCSVv2L", "TopLepTopHadRecDrCSVv2L", "TopLepRecPtCSVv2L" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[4];
   double fVmax[4];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[4];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadBDT::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(0.423712354192705);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.730165,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496467,-99) , 
0, 195.443, 1, 0, 0.686171,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.328331,-99) , 
1, 263.021, 1, 0, 0.640596,-99) , 
NN(
0, 
0, 
-1, 261.411, 1, -1, 0.276898,-99) , 
0, 232.909, 1, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.29412);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 158.62, 0, 1, 0.655823,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504176,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.335067,-99) , 
1, 198.783, 1, 0, 0.442592,-99) , 
2, 2.54381, 0, 0, 0.605252,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.552327,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.365864,-99) , 
3, 184.726, 0, 0, 0.4277,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.166415,-99) , 
1, 261.411, 1, 0, 0.369075,-99) , 
0, 232.909, 1, 0, 0.514912,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.196297);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.647405,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491772,-99) , 
0, 234.67, 1, 0, 0.594231,-99) , 
NN(
0, 
0, 
-1, 123.279, 0, -1, 0.449107,-99) , 
2, 2.95754, 0, 0, 0.527565,-99) , 
NN(
0, 
0, 
-1, 222.263, 1, -1, 0.303588,-99) , 
1, 261.411, 1, 0, 0.490794,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.164689);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.619627,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492415,-99) , 
2, 2.53411, 0, 0, 0.59457,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507531,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.370456,-99) , 
1, 205.657, 1, 0, 0.479736,-99) , 
3, 123.208, 0, 0, 0.542302,-99) , 
NN(
0, 
0, 
-1, 222.263, 1, -1, 0.346611,-99) , 
1, 261.411, 1, 0, 0.510812,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.162685);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.636765,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477146,-99) , 
0, 147.819, 0, 0, 0.600251,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505213,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.423518,-99) , 
0, 421.998, 1, 0, 0.478045,-99) , 
0, 232.909, 1, 0, 0.550007,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526845,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.33579,-99) , 
0, 139.612, 0, 0, 0.485176,-99) , 
NN(
0, 
0, 
-1, 173.22, 1, -1, 0.383565,-99) , 
0, 199.141, 1, 0, 0.437901,-99) , 
3, 126.954, 0, 0, 0.49667,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.149488);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.574437,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.435352,-99) , 
1, 211.372, 1, 0, 0.553651,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533355,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.43514,-99) , 
2, 3.44836, 0, 0, 0.459918,-99) , 
3, 123.208, 0, 0, 0.510671,-99) , 
NN(
0, 
0, 
-1, 222.263, 1, -1, 0.380333,-99) , 
1, 261.411, 1, 0, 0.489975,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.0955544);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 237.341, 0, 1, 0.612216,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503201,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.398206,-99) , 
0, 138.365, 0, 0, 0.485583,-99) , 
3, 184.664, 0, 0, 0.518556,-99) , 
NN(
0, 
0, 
-1, 261.411, 1, -1, 0.446164,-99) , 
0, 232.909, 1, 0, 0.491015,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.100583);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 242.753, 0, 1, 0.592802,-99) , 
NN(
0, 
0, 
-1, 2.95435, 0, -1, 0.475574,-99) , 
0, 234.67, 1, 0, 0.540559,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515424,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.447208,-99) , 
2, 2.46671, 0, 0, 0.498169,-99) , 
NN(
0, 
0, 
-1, 202.355, 1, -1, 0.414885,-99) , 
1, 200.638, 1, 0, 0.469586,-99) , 
3, 190.344, 0, 0, 0.488928,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.0589482);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 245.08, 1, 1, 0.566168,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500031,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451875,-99) , 
3, 84.6936, 0, 0, 0.48551,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.354842,-99) , 
1, 341.464, 1, 0, 0.476335,-99) , 
3, 253.735, 0, 0, 0.488467,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.0626375);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 245.08, 1, 1, 0.551637,-99) , 
NN(
0, 
0, 
-1, 341.464, 1, -1, 0.471893,-99) , 
3, 253.735, 0, 0, 0.482639,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.0647748);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515992,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449552,-99) , 
1, 128.465, 0, 0, 0.509529,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.423216,-99) , 
1, 231.389, 1, 0, 0.502881,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524629,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.364724,-99) , 
0, 222.263, 1, 0, 0.446136,-99) , 
1, 261.411, 1, 0, 0.494063,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.0668893);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 242.753, 0, 1, 0.545114,-99) , 
NN(
0, 
0, 
-1, 2.95435, 0, -1, 0.48073,-99) , 
0, 234.67, 1, 0, 0.516249,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529088,-99) , 
NN(
0, 
0, 
-1, 309.791, 1, -1, 0.466118,-99) , 
2, 4.05855, 0, 0, 0.47317,-99) , 
3, 190.344, 0, 0, 0.484874,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.045015);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510399,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470497,-99) , 
2, 1.97589, 0, 0, 0.505549,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448414,-99) , 
1, 231.389, 1, 0, 0.501174,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513067,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.391438,-99) , 
0, 222.263, 1, 0, 0.453699,-99) , 
1, 261.411, 1, 0, 0.493838,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.0366342);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524247,-99) , 
NN(
0, 
0, 
-1, 133.9, 0, -1, 0.489127,-99) , 
3, 246.12, 0, 0, 0.494167,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501817,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.402213,-99) , 
0, 222.263, 1, 0, 0.453306,-99) , 
1, 261.411, 1, 0, 0.487864,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.0384946);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510341,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478611,-99) , 
1, 140.378, 0, 0, 0.504312,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472057,-99) , 
1, 221.382, 1, 0, 0.500696,-99) , 
NN(
0, 
0, 
-1, 222.263, 1, -1, 0.452985,-99) , 
1, 261.411, 1, 0, 0.493345,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.0337906);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5086,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487581,-99) , 
1, 181.353, 1, 0, 0.500802,-99) , 
NN(
0, 
0, 
-1, 2.95976, 1, -1, 0.471969,-99) , 
3, 61.7518, 0, 0, 0.496476,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502282,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.420401,-99) , 
0, 222.263, 1, 0, 0.462539,-99) , 
1, 261.411, 1, 0, 0.491253,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.0395471);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518292,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487866,-99) , 
3, 184.726, 1, 0, 0.507926,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503249,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.382297,-99) , 
0, 130.717, 0, 0, 0.489074,-99) , 
0, 234.67, 0, 0, 0.495889,-99) , 
NN(
0, 
0, 
-1, 3.04545, 0, -1, 0.462242,-99) , 
1, 261.411, 1, 0, 0.490714,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.0534751);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531314,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525709,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47509,-99) , 
0, 202.086, 1, 0, 0.500085,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506794,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470147,-99) , 
2, 4.06253, 0, 0, 0.474645,-99) , 
3, 151.103, 0, 0, 0.484057,-99) , 
3, 317.125, 0, 0, 0.487172,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.031339);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509934,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487306,-99) , 
2, 3.04221, 0, 0, 0.498613,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500896,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454599,-99) , 
2, 2.82857, 1, 0, 0.472008,-99) , 
3, 63.5638, 0, 0, 0.494589,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461187,-99) , 
2, 1.52581, 0, 0, 0.492272,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.072223);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524563,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497997,-99) , 
1, 181.356, 1, 0, 0.514396,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451745,-99) , 
1, 261.411, 1, 0, 0.502971,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527002,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.399464,-99) , 
0, 128.01, 0, 0, 0.507798,-99) , 
NN(
0, 
0, 
-1, 214.9, 1, -1, 0.44018,-99) , 
0, 185.637, 1, 0, 0.487047,-99) , 
0, 232.909, 0, 0, 0.49309,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.0364992);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516025,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496094,-99) , 
0, 421.998, 1, 0, 0.510174,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469688,-99) , 
1, 261.411, 1, 0, 0.502805,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502339,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.428178,-99) , 
0, 208.147, 1, 0, 0.491836,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.417602,-99) , 
0, 128.91, 0, 0, 0.483791,-99) , 
0, 232.909, 0, 0, 0.491014,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.0536869);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512127,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495307,-99) , 
3, 184.726, 1, 0, 0.50641,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478788,-99) , 
1, 261.411, 1, 0, 0.501385,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519228,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458408,-99) , 
0, 180.234, 1, 0, 0.489713,-99) , 
NN(
0, 
0, 
-1, 126.209, 0, -1, 0.445156,-99) , 
0, 147.819, 0, 0, 0.478934,-99) , 
0, 232.909, 0, 0, 0.487463,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.0376906);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 234.67, 0, 1, 0.517312,-99) , 
NN(
0, 
0, 
-1, 2.53439, 0, -1, 0.490339,-99) , 
2, 2.95435, 0, 0, 0.506426,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508487,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476921,-99) , 
2, 1.81526, 0, 0, 0.495804,-99) , 
NN(
0, 
0, 
-1, 45.4523, 0, -1, 0.476994,-99) , 
2, 2.5389, 1, 0, 0.482316,-99) , 
3, 190.344, 0, 0, 0.488866,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.0250901);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 244.679, 0, 1, 0.508303,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476075,-99) , 
3, 63.5638, 0, 0, 0.503883,-99) , 
NN(
0, 
0, 
-1, 128.91, 0, -1, 0.486171,-99) , 
0, 232.909, 0, 0, 0.492907,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.0243645);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521506,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50839,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484193,-99) , 
2, 2.64226, 0, 0, 0.502544,-99) , 
NN(
0, 
0, 
-1, 376.778, 1, -1, 0.487695,-99) , 
3, 151.103, 0, 0, 0.493188,-99) , 
3, 317.125, 0, 0, 0.495061,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.0185679);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515423,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503009,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45477,-99) , 
0, 130.36, 0, 0, 0.498886,-99) , 
NN(
0, 
0, 
-1, 136.507, 0, -1, 0.477941,-99) , 
0, 370.343, 1, 0, 0.49586,-99) , 
3, 317.125, 0, 0, 0.497154,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.0169586);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510782,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49607,-99) , 
1, 263.021, 0, 0, 0.498247,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477645,-99) , 
2, 1.81202, 0, 0, 0.496335,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504085,-99) , 
NN(
0, 
0, 
-1, 42.4336, 0, -1, 0.473685,-99) , 
2, 2.54618, 1, 0, 0.483994,-99) , 
3, 63.5638, 0, 0, 0.494397,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.0115126);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511729,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49914,-99) , 
2, 2.54296, 1, 0, 0.501232,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481878,-99) , 
2, 1.81202, 0, 0, 0.499436,-99) , 
NN(
0, 
0, 
-1, 48.4707, 0, -1, 0.485353,-99) , 
3, 63.5638, 0, 0, 0.497225,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.0185659);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 184.308, 1, 1, 0.509345,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513718,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493408,-99) , 
3, 238.894, 0, 0, 0.497206,-99) , 
2, 3.16641, 0, 0, 0.501446,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502724,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478875,-99) , 
3, 48.4707, 0, 0, 0.48823,-99) , 
3, 63.5638, 0, 0, 0.499372,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.0108019);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.54296, 1, 1, 0.503117,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488015,-99) , 
2, 1.81202, 0, 0, 0.501716,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503646,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481822,-99) , 
2, 2.54618, 1, 0, 0.489227,-99) , 
3, 63.5638, 0, 0, 0.499756,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.0291391);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509871,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497214,-99) , 
3, 184.726, 1, 0, 0.505569,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489404,-99) , 
1, 261.411, 1, 0, 0.502635,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51145,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476724,-99) , 
0, 154.122, 0, 0, 0.49977,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450522,-99) , 
0, 214, 1, 0, 0.495216,-99) , 
0, 232.909, 0, 0, 0.498038,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.011844);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 244.679, 0, 1, 0.504282,-99) , 
NN(
0, 
0, 
-1, 204.545, 1, -1, 0.495046,-99) , 
0, 232.909, 0, 0, 0.498643,-99) , 
NN(
0, 
0, 
-1, 36.3964, 0, -1, 0.487473,-99) , 
3, 63.5638, 0, 0, 0.49689,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.012255);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511839,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501689,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473913,-99) , 
0, 130.36, 0, 0, 0.49932,-99) , 
NN(
0, 
0, 
-1, 3.20882, 1, -1, 0.482709,-99) , 
0, 370.343, 1, 0, 0.49692,-99) , 
3, 317.125, 0, 0, 0.497906,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.010148);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508777,-99) , 
NN(
0, 
0, 
-1, 370.343, 1, -1, 0.495188,-99) , 
3, 317.125, 0, 0, 0.496086,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.00832424);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509634,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498768,-99) , 
2, 2.54296, 1, 0, 0.500575,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490488,-99) , 
2, 1.81202, 0, 0, 0.499638,-99) , 
NN(
0, 
0, 
-1, 36.3964, 0, -1, 0.491034,-99) , 
3, 63.5638, 0, 0, 0.498288,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.00632839);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 263.021, 0, 1, 0.501964,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492569,-99) , 
2, 1.81202, 0, 0, 0.501092,-99) , 
NN(
0, 
0, 
-1, 36.3964, 0, -1, 0.493114,-99) , 
3, 63.5638, 0, 0, 0.49984,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.017607);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.95435, 1, 1, 0.51013,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502741,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48711,-99) , 
0, 391.444, 1, 0, 0.497659,-99) , 
3, 190.344, 0, 0, 0.501716,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504372,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475908,-99) , 
0, 128.46, 0, 0, 0.501075,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460595,-99) , 
0, 214, 1, 0, 0.497336,-99) , 
0, 232.909, 0, 0, 0.499002,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.0251424);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.95435, 1, 1, 0.505729,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500476,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488646,-99) , 
3, 126.953, 1, 0, 0.496119,-99) , 
3, 190.344, 0, 0, 0.499245,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523238,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487668,-99) , 
0, 155.923, 0, 0, 0.503382,-99) , 
NN(
0, 
0, 
-1, 195.091, 0, -1, 0.482527,-99) , 
0, 176.182, 1, 0, 0.494672,-99) , 
0, 232.909, 0, 0, 0.496412,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0162842);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514495,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49117,-99) , 
0, 222.263, 1, 0, 0.502945,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503234,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481093,-99) , 
1, 151.335, 0, 0, 0.497133,-99) , 
1, 261.411, 0, 0, 0.498026,-99) , 
NN(
0, 
0, 
-1, 36.3964, 0, -1, 0.492115,-99) , 
3, 63.5638, 0, 0, 0.497099,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.0201297);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541328,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48777,-99) , 
1, 198.783, 0, 0, 0.506881,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483037,-99) , 
0, 280.664, 1, 0, 0.500221,-99) , 
NN(
NN(
0, 
0, 
-1, 222.263, 1, 1, 0.504693,-99) , 
NN(
0, 
0, 
-1, 132.985, 0, -1, 0.493467,-99) , 
1, 263.021, 0, 0, 0.495114,-99) , 
2, 2.5389, 1, 0, 0.496428,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0178764);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509153,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504479,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.425594,-99) , 
1, 339.899, 1, 0, 0.499273,-99) , 
2, 4.13091, 0, 0, 0.500179,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49324,-99) , 
2, 1.52581, 0, 0, 0.499697,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0174361);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535616,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490594,-99) , 
1, 198.783, 0, 0, 0.506647,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486671,-99) , 
0, 280.664, 1, 0, 0.501067,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50195,-99) , 
NN(
0, 
0, 
-1, 2.68593, 0, -1, 0.493697,-99) , 
2, 4.08267, 0, 0, 0.494713,-99) , 
2, 2.5389, 1, 0, 0.496347,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.0120315);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531277,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494952,-99) , 
1, 198.783, 0, 0, 0.5079,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491028,-99) , 
0, 280.664, 1, 0, 0.503187,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505079,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497953,-99) , 
1, 263.021, 0, 0, 0.498993,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502492,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480485,-99) , 
3, 42.4336, 0, 0, 0.491888,-99) , 
3, 63.5638, 0, 0, 0.497998,-99) , 
2, 2.5389, 1, 0, 0.499332,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.0194977);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.8173, 0, 1, 0.510481,-99) , 
NN(
0, 
0, 
-1, 143.958, 0, -1, 0.494802,-99) , 
2, 2.95754, 1, 0, 0.502134,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51706,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474766,-99) , 
2, 3.04545, 0, 0, 0.495073,-99) , 
1, 261.411, 1, 0, 0.501058,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.018413);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507425,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495689,-99) , 
2, 3.44836, 1, 0, 0.504842,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482264,-99) , 
1, 131.324, 0, 0, 0.50245,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512189,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47963,-99) , 
2, 3.04545, 0, 0, 0.495265,-99) , 
1, 261.411, 1, 0, 0.501355,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.0168545);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511932,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510545,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490365,-99) , 
3, 127.334, 0, 0, 0.500556,-99) , 
2, 4.2274, 0, 0, 0.504946,-99) , 
NN(
NN(
0, 
0, 
-1, 256.339, 0, 1, 0.503472,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.430297,-99) , 
1, 338.369, 1, 0, 0.498625,-99) , 
2, 3.552, 0, 0, 0.499843,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.0164319);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50772,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506767,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49415,-99) , 
2, 3.80929, 1, 0, 0.500514,-99) , 
2, 4.2274, 0, 0, 0.503295,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520322,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497113,-99) , 
1, 256.339, 0, 0, 0.499258,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.434433,-99) , 
1, 338.369, 1, 0, 0.494969,-99) , 
2, 3.552, 0, 0, 0.496573,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0114341);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502739,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484657,-99) , 
1, 236.63, 1, 0, 0.50152,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486283,-99) , 
1, 131.324, 0, 0, 0.499906,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505195,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480931,-99) , 
3, 126.954, 0, 0, 0.493999,-99) , 
1, 261.411, 1, 0, 0.499007,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0123442);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503362,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497773,-99) , 
2, 3.35219, 0, 0, 0.500701,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490645,-99) , 
3, 63.5638, 0, 0, 0.499123,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508666,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48656,-99) , 
2, 2.96274, 1, 0, 0.501102,-99) , 
NN(
0, 
0, 
-1, 2.49409, 1, -1, 0.492955,-99) , 
2, 2.75599, 0, 0, 0.495821,-99) , 
2, 3.04545, 0, 0, 0.497355,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0170814);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507667,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495584,-99) , 
3, 123.208, 1, 0, 0.501307,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50971,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482751,-99) , 
3, 164.206, 0, 0, 0.493015,-99) , 
1, 151.337, 0, 0, 0.499076,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505216,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484985,-99) , 
2, 3.04545, 0, 0, 0.4947,-99) , 
1, 261.411, 1, 0, 0.49841,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.00892593);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516331,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498924,-99) , 
0, 411.832, 0, 0, 0.500848,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487978,-99) , 
2, 3.93918, 1, 0, 0.499515,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503211,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48513,-99) , 
3, 126.954, 0, 0, 0.494868,-99) , 
1, 261.411, 1, 0, 0.498807,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.00758693);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 411.832, 0, 1, 0.502586,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490209,-99) , 
2, 3.93918, 1, 0, 0.501304,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50098,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48736,-99) , 
3, 126.954, 0, 0, 0.494696,-99) , 
1, 261.411, 1, 0, 0.500298,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.0104646);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507493,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498856,-99) , 
1, 172.303, 1, 0, 0.501836,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505383,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487434,-99) , 
3, 164.206, 0, 0, 0.494268,-99) , 
1, 151.337, 0, 0, 0.4998,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500641,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488921,-99) , 
2, 3.04545, 0, 0, 0.494549,-99) , 
1, 261.411, 1, 0, 0.499001,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.00904681);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515564,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492266,-99) , 
1, 235.677, 1, 0, 0.508628,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500228,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486808,-99) , 
1, 187.074, 1, 0, 0.498395,-99) , 
1, 201.37, 0, 0, 0.500561,-99) , 
NN(
0, 
0, 
-1, 222.263, 1, -1, 0.494652,-99) , 
1, 261.411, 1, 0, 0.499662,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.00992296);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51255,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500451,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489108,-99) , 
3, 124.175, 0, 0, 0.494012,-99) , 
1, 194.821, 0, 0, 0.50126,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501107,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490126,-99) , 
2, 2.86976, 0, 0, 0.498816,-99) , 
NN(
0, 
0, 
-1, 42.4336, 0, -1, 0.492064,-99) , 
3, 63.5638, 0, 0, 0.497871,-99) , 
2, 2.5389, 1, 0, 0.498743,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.00892835);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510071,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50044,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490468,-99) , 
2, 1.8171, 1, 0, 0.494347,-99) , 
1, 194.821, 0, 0, 0.500494,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500293,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491301,-99) , 
1, 152.99, 0, 0, 0.497722,-99) , 
NN(
0, 
0, 
-1, 222.263, 1, -1, 0.492614,-99) , 
1, 263.021, 1, 0, 0.496975,-99) , 
2, 2.5389, 1, 0, 0.49788,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.0161295);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528706,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490567,-99) , 
1, 198.783, 0, 0, 0.504147,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489021,-99) , 
0, 280.664, 1, 0, 0.499923,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502372,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490634,-99) , 
0, 202.355, 1, 0, 0.49707,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493143,-99) , 
3, 253.735, 1, 0, 0.496485,-99) , 
2, 2.5389, 1, 0, 0.497369,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.0147645);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513886,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497635,-99) , 
0, 411.352, 0, 0, 0.502573,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496321,-99) , 
2, 3.44407, 1, 0, 0.501082,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521957,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495162,-99) , 
0, 196.892, 0, 0, 0.498428,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474547,-99) , 
0, 214, 1, 0, 0.496224,-99) , 
0, 232.909, 0, 0, 0.498074,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.0140752);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530094,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497694,-99) , 
0, 200.931, 0, 0, 0.508267,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493785,-99) , 
0, 280.664, 1, 0, 0.504223,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506043,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497312,-99) , 
0, 421.998, 1, 0, 0.503341,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502112,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465994,-99) , 
0, 204.545, 1, 0, 0.496971,-99) , 
0, 232.909, 0, 0, 0.499357,-99) , 
2, 2.5389, 1, 0, 0.500609,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.0114748);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513894,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496115,-99) , 
0, 280.664, 1, 0, 0.509238,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494201,-99) , 
3, 185.58, 1, 0, 0.506088,-99) , 
NN(
NN(
0, 
0, 
-1, 190.344, 0, 1, 0.502001,-99) , 
NN(
0, 
0, 
-1, 204.545, 1, -1, 0.494453,-99) , 
0, 232.909, 0, 0, 0.497281,-99) , 
2, 2.5389, 1, 0, 0.499545,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.0132843);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 124.175, 0, 1, 0.508607,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493693,-99) , 
2, 1.33283, 0, 0, 0.505609,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503615,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488732,-99) , 
3, 190.344, 1, 0, 0.500005,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508993,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494049,-99) , 
3, 246.183, 0, 0, 0.496799,-99) , 
2, 3.31079, 0, 0, 0.498,-99) , 
2, 2.5389, 1, 0, 0.499956,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.00575702);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51217,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507639,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49863,-99) , 
2, 2.29769, 0, 0, 0.500988,-99) , 
0, 161.071, 1, 0, 0.503624,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500299,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495651,-99) , 
2, 2.86976, 0, 0, 0.499329,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502418,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486258,-99) , 
3, 42.4336, 0, 0, 0.494633,-99) , 
3, 63.5638, 0, 0, 0.498672,-99) , 
2, 2.5389, 1, 0, 0.499945,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.00670975);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509001,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497773,-99) , 
0, 280.664, 1, 0, 0.506061,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495313,-99) , 
3, 185.58, 1, 0, 0.503809,-99) , 
NN(
NN(
0, 
0, 
-1, 3.86234, 1, -1, 0.49849,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500979,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487697,-99) , 
3, 42.4336, 0, 0, 0.49458,-99) , 
3, 63.5638, 0, 0, 0.497943,-99) , 
2, 2.5389, 1, 0, 0.499451,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.00595275);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50854,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505546,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495908,-99) , 
2, 1.9374, 1, 0, 0.500314,-99) , 
1, 194.821, 0, 0, 0.503529,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500826,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496021,-99) , 
2, 3.86234, 1, 0, 0.500168,-99) , 
NN(
0, 
0, 
-1, 42.4336, 0, -1, 0.494519,-99) , 
3, 63.5638, 0, 0, 0.499377,-99) , 
2, 2.5389, 1, 0, 0.500444,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.00893316);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 124.175, 0, 1, 0.504771,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496086,-99) , 
2, 1.33283, 0, 0, 0.503025,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514753,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496987,-99) , 
3, 205.437, 0, 0, 0.499163,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495757,-99) , 
3, 253.735, 1, 0, 0.498656,-99) , 
2, 2.5389, 1, 0, 0.499779,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.011977);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505196,-99) , 
NN(
NN(
0, 
0, 
-1, 205.39, 0, 1, 0.501906,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526429,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465931,-99) , 
0, 195.424, 1, 0, 0.491621,-99) , 
1, 265.373, 1, 0, 0.500434,-99) , 
3, 317.125, 0, 0, 0.500749,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.0136465);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507784,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500478,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495519,-99) , 
3, 126.954, 0, 0, 0.498475,-99) , 
2, 1.97068, 1, 0, 0.499737,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535661,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49667,-99) , 
1, 263.021, 0, 0, 0.50163,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500597,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461667,-99) , 
0, 196.892, 0, 0, 0.487426,-99) , 
0, 185.637, 1, 0, 0.497279,-99) , 
0, 232.909, 0, 0, 0.498215,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.0128183);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51658,-99) , 
NN(
0, 
0, 
-1, 355.404, 1, -1, 0.496394,-99) , 
3, 108.842, 0, 0, 0.50029,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507876,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501307,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467912,-99) , 
0, 299.089, 1, 0, 0.495671,-99) , 
0, 431.451, 0, 0, 0.497264,-99) , 
3, 126.954, 1, 0, 0.498706,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.0130078);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 236.343, 0, 1, 0.505249,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483227,-99) , 
0, 355.404, 1, 0, 0.502258,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504672,-99) , 
NN(
0, 
0, 
-1, 299.089, 1, -1, 0.493548,-99) , 
0, 431.451, 0, 0, 0.494999,-99) , 
3, 126.954, 1, 0, 0.49846,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.0087087);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511062,-99) , 
NN(
0, 
0, 
-1, 355.404, 1, -1, 0.497218,-99) , 
3, 108.842, 0, 0, 0.499889,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506723,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497267,-99) , 
1, 263.021, 0, 0, 0.498669,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488978,-99) , 
2, 2.20291, 0, 0, 0.497402,-99) , 
3, 126.954, 1, 0, 0.498588,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.0155458);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507376,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495578,-99) , 
3, 36.3964, 0, 0, 0.503212,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504369,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443941,-99) , 
1, 338.369, 1, 0, 0.500148,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491214,-99) , 
2, 4.06934, 1, 0, 0.499486,-99) , 
3, 63.5638, 1, 0, 0.500071,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.00751392);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50662,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49973,-99) , 
2, 2.54618, 1, 0, 0.502069,-99) , 
NN(
NN(
0, 
0, 
-1, 431.451, 1, -1, 0.498203,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501965,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482644,-99) , 
0, 193.509, 0, 0, 0.493341,-99) , 
2, 2.71495, 0, 0, 0.496678,-99) , 
3, 63.5638, 1, 0, 0.497524,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.00610912);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506053,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499925,-99) , 
0, 199.998, 0, 0, 0.502672,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500812,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494581,-99) , 
0, 431.451, 1, 0, 0.500082,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500086,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484521,-99) , 
0, 193.509, 0, 0, 0.493139,-99) , 
2, 2.71495, 0, 0, 0.497904,-99) , 
3, 63.5638, 1, 0, 0.498652,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.00695248);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 48.4707, 0, 1, 0.50283,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501509,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497734,-99) , 
2, 3.03743, 1, 0, 0.498912,-99) , 
NN(
0, 
0, 
-1, 193.509, 0, -1, 0.492975,-99) , 
2, 2.71495, 0, 0, 0.49705,-99) , 
3, 63.5638, 1, 0, 0.497957,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.0114132);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50363,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522678,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499634,-99) , 
1, 256.339, 0, 0, 0.501765,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.445756,-99) , 
1, 338.369, 1, 0, 0.497989,-99) , 
2, 4.05855, 0, 0, 0.498522,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.00910613);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522942,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495586,-99) , 
1, 228.054, 1, 0, 0.507719,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501399,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489514,-99) , 
3, 246.12, 1, 0, 0.499661,-99) , 
1, 211.376, 0, 0, 0.500924,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503628,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491669,-99) , 
2, 3.04545, 0, 0, 0.497412,-99) , 
1, 261.411, 1, 0, 0.50039,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.0123087);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504556,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507599,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498489,-99) , 
1, 205.39, 0, 0, 0.500274,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521657,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467962,-99) , 
0, 195.424, 1, 0, 0.490757,-99) , 
1, 265.373, 1, 0, 0.498913,-99) , 
3, 317.125, 0, 0, 0.499286,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.00634027);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 411.832, 0, 1, 0.502733,-99) , 
NN(
0, 
0, 
-1, 123.208, 0, -1, 0.495637,-99) , 
2, 3.44836, 1, 0, 0.5012,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501095,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493383,-99) , 
3, 126.954, 0, 0, 0.497536,-99) , 
1, 261.411, 1, 0, 0.500643,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.0117204);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508028,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503877,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494183,-99) , 
3, 127.334, 0, 0, 0.49908,-99) , 
2, 4.2274, 0, 0, 0.502534,-99) , 
NN(
NN(
0, 
0, 
-1, 256.339, 0, 1, 0.502694,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450071,-99) , 
1, 338.369, 1, 0, 0.499223,-99) , 
2, 3.552, 0, 0, 0.499861,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.0109088);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511538,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497479,-99) , 
2, 4.22741, 0, 0, 0.504151,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497628,-99) , 
3, 126.954, 1, 0, 0.501385,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513114,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498407,-99) , 
1, 256.339, 0, 0, 0.499764,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452974,-99) , 
1, 338.369, 1, 0, 0.496679,-99) , 
2, 3.552, 0, 0, 0.497586,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.00918478);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510736,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497945,-99) , 
3, 72.6195, 0, 0, 0.50429,-99) , 
NN(
0, 
0, 
-1, 0, 1, 1, 0.500355,-99) , 
3, 126.954, 1, 0, 0.502621,-99) , 
NN(
NN(
0, 
0, 
-1, 411.832, 0, 1, 0.501988,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455678,-99) , 
1, 338.369, 1, 0, 0.498937,-99) , 
2, 3.552, 0, 0, 0.499646,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.00988117);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509211,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49988,-99) , 
2, 4.22741, 0, 0, 0.504309,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498059,-99) , 
3, 126.954, 1, 0, 0.501658,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510952,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498297,-99) , 
0, 411.832, 0, 0, 0.499692,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457957,-99) , 
1, 338.369, 1, 0, 0.496943,-99) , 
2, 3.552, 0, 0, 0.497851,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.0104168);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508958,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49998,-99) , 
3, 72.6195, 0, 0, 0.504434,-99) , 
NN(
0, 
0, 
-1, 0, 1, 1, 0.500529,-99) , 
3, 126.954, 1, 0, 0.502778,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502829,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492075,-99) , 
1, 133.299, 0, 0, 0.501618,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460411,-99) , 
1, 338.369, 1, 0, 0.498904,-99) , 
2, 3.552, 0, 0, 0.499651,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.00895077);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 4.22741, 0, 1, 0.504455,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497925,-99) , 
3, 126.954, 1, 0, 0.501685,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506666,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498319,-99) , 
3, 246.183, 0, 0, 0.4996,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463,-99) , 
1, 338.369, 1, 0, 0.497191,-99) , 
2, 3.552, 0, 0, 0.498057,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.00983845);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 259.738, 0, 1, 0.502599,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464202,-99) , 
1, 341.464, 1, 0, 0.50004,-99) , 
NN(
0, 
0, 
-1, 305.052, 0, -1, 0.494394,-99) , 
3, 253.735, 1, 0, 0.49928,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.0144554);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519292,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49796,-99) , 
0, 236.059, 0, 0, 0.501606,-99) , 
NN(
0, 
0, 
-1, 336.907, 1, -1, 0.479118,-99) , 
0, 299.089, 1, 0, 0.49818,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494302,-99) , 
0, 431.451, 1, 0, 0.497766,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.0142898);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 263.021, 0, 1, 0.507084,-99) , 
NN(
0, 
0, 
-1, 196.892, 0, -1, 0.488257,-99) , 
0, 185.637, 1, 0, 0.50132,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50494,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501998,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489415,-99) , 
3, 184.726, 1, 0, 0.497719,-99) , 
1, 261.411, 0, 0, 0.499021,-99) , 
0, 232.909, 1, 0, 0.500445,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.00922861);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519813,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499305,-99) , 
0, 196.892, 0, 0, 0.501802,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481531,-99) , 
0, 214, 1, 0, 0.499935,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502637,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492413,-99) , 
0, 421.999, 1, 0, 0.499373,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501313,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492051,-99) , 
0, 384.513, 0, 0, 0.495267,-99) , 
2, 2.95294, 0, 0, 0.49744,-99) , 
0, 232.909, 1, 0, 0.498985,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.0145373);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525089,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499128,-99) , 
0, 162.676, 0, 0, 0.506962,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505666,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482226,-99) , 
0, 195.091, 0, 0, 0.494436,-99) , 
0, 176.182, 1, 0, 0.501732,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503304,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498056,-99) , 
2, 2.95435, 1, 0, 0.500213,-99) , 
NN(
0, 
0, 
-1, 185.064, 1, -1, 0.495941,-99) , 
3, 190.344, 0, 0, 0.49733,-99) , 
0, 232.909, 1, 0, 0.500056,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.0143041);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 263.021, 0, 1, 0.507613,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503909,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47788,-99) , 
1, 177.423, 1, 0, 0.490936,-99) , 
0, 185.637, 1, 0, 0.502508,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503957,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498349,-99) , 
0, 421.999, 1, 0, 0.502167,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503204,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495262,-99) , 
2, 1.97068, 1, 0, 0.497549,-99) , 
2, 2.95294, 0, 0, 0.499993,-99) , 
0, 232.909, 1, 0, 0.501551,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.0093077);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 256.339, 0, 1, 0.502768,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466489,-99) , 
1, 338.369, 1, 0, 0.500331,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497069,-99) , 
2, 4.05855, 1, 0, 0.500023,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.00825075);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503052,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499727,-99) , 
2, 3.8897, 0, 0, 0.501785,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510916,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49801,-99) , 
0, 411.832, 0, 0, 0.499433,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471778,-99) , 
1, 338.369, 1, 0, 0.497616,-99) , 
2, 3.552, 0, 0, 0.498419,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.00689089);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505898,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49915,-99) , 
3, 126.954, 0, 0, 0.502781,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502287,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496108,-99) , 
0, 224.024, 1, 0, 0.499891,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49212,-99) , 
2, 3.93918, 1, 0, 0.499086,-99) , 
1, 261.411, 0, 0, 0.499646,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.00668858);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 3.04545, 0, 1, 0.50265,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506161,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50074,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482462,-99) , 
0, 300.812, 1, 0, 0.498102,-99) , 
0, 433.124, 0, 0, 0.498918,-99) , 
1, 261.411, 0, 0, 0.499484,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.0112446);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50858,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488111,-99) , 
0, 380.124, 1, 0, 0.501714,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508431,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493479,-99) , 
0, 421.998, 0, 0, 0.498396,-99) , 
3, 126.954, 1, 0, 0.499811,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500743,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486272,-99) , 
0, 128.46, 0, 0, 0.499068,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478542,-99) , 
0, 214, 1, 0, 0.497176,-99) , 
0, 232.909, 0, 0, 0.49818,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.0157445);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503093,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511017,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496557,-99) , 
1, 141.33, 1, 0, 0.499281,-99) , 
1, 261.411, 0, 0, 0.499968,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530614,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494529,-99) , 
1, 263.021, 0, 0, 0.499106,-99) , 
NN(
0, 
0, 
-1, 196.892, 0, -1, 0.487241,-99) , 
0, 185.637, 1, 0, 0.495474,-99) , 
0, 232.909, 0, 0, 0.497185,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.0133108);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50378,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503241,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498086,-99) , 
1, 182.276, 1, 0, 0.500728,-99) , 
3, 253.735, 0, 0, 0.50127,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512375,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495578,-99) , 
0, 155.923, 0, 0, 0.502997,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503155,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481434,-99) , 
0, 195.091, 0, 0, 0.492745,-99) , 
0, 176.182, 1, 0, 0.498717,-99) , 
0, 232.909, 0, 0, 0.499689,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.00679519);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502671,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50469,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497896,-99) , 
3, 127.334, 0, 0, 0.501329,-99) , 
2, 4.2274, 0, 0, 0.501847,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508563,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499711,-99) , 
3, 246.183, 0, 0, 0.50107,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469486,-99) , 
1, 338.369, 1, 0, 0.498993,-99) , 
2, 3.552, 0, 0, 0.499543,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.00975088);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 157.139, 0, 1, 0.503105,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469964,-99) , 
1, 341.464, 1, 0, 0.500898,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501662,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491358,-99) , 
3, 305.052, 0, 0, 0.497143,-99) , 
3, 253.735, 1, 0, 0.500392,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.00878786);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506337,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498936,-99) , 
1, 201.655, 0, 0, 0.500953,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469535,-99) , 
1, 338.369, 1, 0, 0.498843,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495462,-99) , 
2, 4.05855, 1, 0, 0.498524,-99)    );
   return;
};
 
// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
