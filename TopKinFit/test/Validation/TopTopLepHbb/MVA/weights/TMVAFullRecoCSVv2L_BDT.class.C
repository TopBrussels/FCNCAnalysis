// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.06/01       [394753]
Creator        : kskovpen
Date           : Tue Jan 10 12:00:57 2017
Host           : Linux vocms0315.cern.ch 2.6.32-573.26.1.el6.x86_64 #1 SMP Wed May 4 09:23:05 CEST 2016 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /storage_mnt/storage/user/kskovpen/analysis/tHFCNC/CMSSW_8_0_12/src/TopKinFit/test/Validation/TopTopLepHbb/MVA
Training events: 274367
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
SeparationType: "giniindex" [Separation criterion for node splitting]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
MinNodeSize: "5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "2" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 4
HiggsRecMCSVv2L               HiggsRecMCSVv2L               HiggsRecMCSVv2L               HiggsRecMCSVv2L                                                 'F'    [18.1104202271,2453.29223633]
TopLepRecMCSVv2L              TopLepRecMCSVv2L              TopLepRecMCSVv2L              TopLepRecMCSVv2L                                                'F'    [42.1962661743,3703.69238281]
HiggsTopLepRecDrCSVv2L        HiggsTopLepRecDrCSVv2L        HiggsTopLepRecDrCSVv2L        HiggsTopLepRecDrCSVv2L                                          'F'    [0.0131017994136,9.35446357727]
TopLepRecPtCSVv2L             TopLepRecPtCSVv2L             TopLepRecPtCSVv2L             TopLepRecPtCSVv2L                                               'F'    [0.159955620766,1056.87805176]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTNode
   
#ifndef BDTNode__def
#define BDTNode__def
   
class BDTNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 4 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "HiggsRecMCSVv2L", "TopLepRecMCSVv2L", "HiggsTopLepRecDrCSVv2L", "TopLepRecPtCSVv2L" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[4];
   double fVmax[4];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[4];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadBDT::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(0.362737396839477);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.56086, 0, 1, 0.676311,-99) , 
NN(
0, 
0, 
-1, 76.2208, 0, -1, 0.40135,-99) , 
0, 89.8953, 0, 0, 0.600278,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.597174,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.345005,-99) , 
3, 188.101, 0, 0, 0.419914,-99) , 
NN(
0, 
0, 
-1, 2.66556, 0, -1, 0.178445,-99) , 
1, 225.388, 1, 0, 0.330445,-99) , 
0, 134.071, 1, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.262555);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 141.116, 0, 1, 0.652947,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51455,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.391447,-99) , 
2, 1.95458, 0, 0, 0.464984,-99) , 
2, 2.73117, 0, 0, 0.574158,-99) , 
NN(
0, 
0, 
-1, 2.685, 0, -1, 0.336211,-99) , 
1, 216.553, 1, 0, 0.495388,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.257995);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.610852,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459911,-99) , 
2, 2.55576, 0, 0, 0.559699,-99) , 
NN(
0, 
0, 
-1, 140.149, 0, -1, 0.259984,-99) , 
0, 161.681, 1, 0, 0.516467,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.203896,-99) , 
0, 250.033, 1, 0, 0.487658,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.212918);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.56586,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.326796,-99) , 
1, 331.106, 1, 0, 0.54562,-99) , 
NN(
0, 
0, 
-1, 169.569, 1, -1, 0.336427,-99) , 
0, 150.637, 1, 0, 0.508264,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.248968,-99) , 
0, 250.033, 1, 0, 0.485441,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.154832);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.592636,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468385,-99) , 
2, 2.74112, 0, 0, 0.543233,-99) , 
NN(
0, 
0, 
-1, 161.681, 1, -1, 0.438226,-99) , 
3, 151.12, 0, 0, 0.481187,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.290861,-99) , 
0, 250.033, 1, 0, 0.464966,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.137537);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539171,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.383109,-99) , 
0, 72.8033, 0, 0, 0.519638,-99) , 
NN(
0, 
0, 
-1, 2.68555, 0, -1, 0.379735,-99) , 
0, 161.681, 1, 0, 0.500784,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.323798,-99) , 
0, 250.033, 1, 0, 0.486013,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.108309);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 263.271, 0, 1, 0.543192,-99) , 
NN(
0, 
0, 
-1, 140.071, 0, -1, 0.470316,-99) , 
3, 141.834, 0, 0, 0.503272,-99) , 
NN(
0, 
0, 
-1, 382.608, 1, -1, 0.408245,-99) , 
1, 216.553, 1, 0, 0.47245,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.0827255);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516184,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.409792,-99) , 
1, 258.064, 1, 0, 0.501373,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.360689,-99) , 
1, 390.91, 1, 0, 0.493407,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.364274,-99) , 
0, 250.033, 1, 0, 0.48287,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.0548226);
  fForest.push_back( 
NN(
0, 
0, 
-1, 390.91, 1, -1, 0.472616,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.0620968);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511347,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.418848,-99) , 
1, 130.758, 0, 0, 0.503084,-99) , 
NN(
0, 
0, 
-1, 313.42, 1, -1, 0.413418,-99) , 
1, 274.671, 1, 0, 0.493353,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.37703,-99) , 
1, 390.91, 1, 0, 0.486298,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.0914759);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522652,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.447729,-99) , 
0, 104.879, 0, 0, 0.494305,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.392459,-99) , 
0, 183.768, 1, 0, 0.485744,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.391019,-99) , 
0, 250.033, 1, 0, 0.478105,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.0913201);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 4.12247, 0, 1, 0.537601,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536366,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45947,-99) , 
2, 2.38679, 0, 0, 0.515524,-99) , 
NN(
0, 
0, 
-1, 238.072, 1, -1, 0.449921,-99) , 
3, 202.131, 0, 0, 0.466512,-99) , 
2, 3.57172, 0, 0, 0.476935,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.052707);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509177,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448092,-99) , 
1, 137.084, 0, 0, 0.500828,-99) , 
NN(
0, 
0, 
-1, 3.06199, 0, -1, 0.450168,-99) , 
1, 241.461, 1, 0, 0.491509,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.397183,-99) , 
1, 390.91, 1, 0, 0.485822,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.0651104);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519711,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478966,-99) , 
0, 112.769, 0, 0, 0.498016,-99) , 
NN(
0, 
0, 
-1, 2.68555, 0, -1, 0.434881,-99) , 
0, 150.637, 1, 0, 0.487138,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.416914,-99) , 
0, 250.033, 1, 0, 0.481527,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.054628);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540987,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547023,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480188,-99) , 
2, 4.01654, 0, 0, 0.485252,-99) , 
3, 283.508, 0, 0, 0.490616,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.416708,-99) , 
1, 390.91, 1, 0, 0.486182,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.0404215);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 3.1277, 0, 1, 0.509923,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516982,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460595,-99) , 
2, 2.24095, 1, 0, 0.477354,-99) , 
3, 94.6094, 0, 0, 0.499771,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.430044,-99) , 
1, 390.91, 1, 0, 0.495601,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.0466115);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526754,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491617,-99) , 
2, 2.55576, 1, 0, 0.503802,-99) , 
NN(
0, 
0, 
-1, 2.68555, 0, -1, 0.455825,-99) , 
0, 150.637, 1, 0, 0.495567,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.436337,-99) , 
0, 250.033, 1, 0, 0.49086,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.0418948);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 136.643, 1, 1, 0.531818,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536762,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47427,-99) , 
2, 3.71999, 0, 0, 0.506779,-99) , 
3, 94.1305, 0, 0, 0.523334,-99) , 
NN(
0, 
0, 
-1, 238.072, 1, -1, 0.483992,-99) , 
2, 3.12689, 0, 0, 0.496345,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.0441507);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51717,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472579,-99) , 
0, 68.5952, 0, 0, 0.512352,-99) , 
NN(
0, 
0, 
-1, 188.502, 1, -1, 0.472703,-99) , 
0, 150.637, 1, 0, 0.50556,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451917,-99) , 
0, 250.033, 1, 0, 0.501311,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.0327027);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50995,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482267,-99) , 
1, 148.943, 0, 0, 0.504261,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457052,-99) , 
1, 291.277, 1, 0, 0.50045,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.447963,-99) , 
1, 390.91, 1, 0, 0.497322,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.0293483);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517412,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499858,-99) , 
2, 3.14713, 0, 0, 0.505222,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522044,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472637,-99) , 
2, 2.11019, 1, 0, 0.481508,-99) , 
3, 100.8, 0, 0, 0.497276,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46039,-99) , 
2, 1.34758, 0, 0, 0.494264,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.0211636);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51419,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497862,-99) , 
2, 2.55576, 1, 0, 0.503621,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462145,-99) , 
0, 194.812, 1, 0, 0.500981,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463941,-99) , 
0, 250.033, 1, 0, 0.498051,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.0327983);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 237.383, 0, 1, 0.51084,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52531,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478513,-99) , 
2, 3.6353, 0, 0, 0.488354,-99) , 
3, 100.8, 0, 0, 0.50331,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464253,-99) , 
2, 1.34758, 0, 0, 0.500124,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.0257303);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.9421, 1, 1, 0.509401,-99) , 
NN(
0, 
0, 
-1, 2.24037, 0, -1, 0.486907,-99) , 
1, 191.645, 1, 0, 0.499762,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457428,-99) , 
1, 390.91, 1, 0, 0.497244,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.0209226);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509946,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495729,-99) , 
2, 2.97885, 0, 0, 0.501712,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464974,-99) , 
0, 194.812, 1, 0, 0.499376,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466244,-99) , 
0, 250.033, 1, 0, 0.49676,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.0195319);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505233,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481948,-99) , 
1, 137.082, 0, 0, 0.502419,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476015,-99) , 
1, 291.277, 1, 0, 0.500293,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464961,-99) , 
1, 390.91, 1, 0, 0.498193,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.0225359);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511369,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493677,-99) , 
2, 2.55576, 1, 0, 0.499916,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468056,-99) , 
0, 194.812, 1, 0, 0.497891,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469504,-99) , 
0, 250.033, 1, 0, 0.495651,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.0233601);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.95076, 0, 1, 0.521541,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527197,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49358,-99) , 
2, 4.01656, 0, 0, 0.496662,-99) , 
3, 251.76, 0, 0, 0.500184,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471604,-99) , 
2, 1.34758, 0, 0, 0.497856,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.0145718);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 216.765, 0, 1, 0.504969,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477819,-99) , 
1, 398.982, 1, 0, 0.503452,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477429,-99) , 
2, 1.34758, 0, 0, 0.501334,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.0198877);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517436,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497906,-99) , 
2, 2.56013, 1, 0, 0.504728,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500209,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454544,-99) , 
2, 2.24037, 0, 0, 0.487624,-99) , 
0, 139.593, 1, 0, 0.500632,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475586,-99) , 
0, 250.033, 1, 0, 0.498658,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.0192044);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 4.10735, 0, 1, 0.506488,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515384,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490164,-99) , 
2, 1.9286, 1, 0, 0.49567,-99) , 
2, 2.87272, 0, 0, 0.501385,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479524,-99) , 
2, 1.34758, 0, 0, 0.499607,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.0220785);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507617,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478244,-99) , 
0, 58.6044, 0, 0, 0.505423,-99) , 
NN(
0, 
0, 
-1, 2.24037, 0, -1, 0.484734,-99) , 
0, 139.593, 1, 0, 0.50047,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479778,-99) , 
0, 250.033, 1, 0, 0.498839,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.00945716);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501189,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479898,-99) , 
1, 125.221, 0, 0, 0.499867,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482173,-99) , 
1, 291.277, 1, 0, 0.498444,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477511,-99) , 
1, 390.91, 1, 0, 0.497201,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.0228214);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511239,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487206,-99) , 
0, 244.511, 1, 0, 0.505543,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510881,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489695,-99) , 
2, 2.06708, 1, 0, 0.49251,-99) , 
0, 134.071, 0, 0, 0.496969,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481718,-99) , 
2, 1.34758, 0, 0, 0.495729,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.0149229);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512569,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502807,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488172,-99) , 
3, 101.48, 0, 0, 0.498115,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473494,-99) , 
2, 1.15694, 0, 0, 0.496539,-99) , 
2, 4.01654, 0, 0, 0.497781,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.0346024);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521371,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516298,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486461,-99) , 
2, 3.23281, 0, 0, 0.496151,-99) , 
2, 1.79241, 1, 0, 0.500332,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526482,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48829,-99) , 
1, 225.05, 0, 0, 0.498713,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467971,-99) , 
2, 2.35199, 0, 0, 0.491228,-99) , 
3, 151.12, 1, 0, 0.496556,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.0199009);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537532,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499735,-99) , 
2, 1.9421, 1, 0, 0.506087,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504168,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463788,-99) , 
2, 2.24037, 0, 0, 0.493463,-99) , 
1, 191.645, 1, 0, 0.50068,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477487,-99) , 
1, 390.91, 1, 0, 0.499303,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.0193379);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.9421, 1, 1, 0.509391,-99) , 
NN(
0, 
0, 
-1, 1.79574, 0, -1, 0.491124,-99) , 
1, 191.645, 1, 0, 0.501568,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482454,-99) , 
1, 390.91, 1, 0, 0.500433,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0241789);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514214,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518057,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49017,-99) , 
1, 152.256, 0, 0, 0.50673,-99) , 
NN(
0, 
0, 
-1, 2.24037, 0, -1, 0.490918,-99) , 
1, 186.651, 1, 0, 0.498831,-99) , 
3, 302.079, 0, 0, 0.500068,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.0101664);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 134.071, 0, 1, 0.504192,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491476,-99) , 
3, 50.4799, 0, 0, 0.502898,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489814,-99) , 
2, 1.34758, 0, 0, 0.501837,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0215538);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522771,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506891,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491799,-99) , 
0, 128.091, 1, 0, 0.501015,-99) , 
2, 4.01654, 0, 0, 0.503199,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520028,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492789,-99) , 
1, 225.05, 0, 0, 0.50027,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472395,-99) , 
2, 1.96286, 0, 0, 0.495927,-99) , 
3, 151.12, 1, 0, 0.500183,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0114644);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504125,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491689,-99) , 
2, 3.57172, 1, 0, 0.502438,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487423,-99) , 
1, 291.277, 1, 0, 0.501233,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487831,-99) , 
1, 390.91, 1, 0, 0.500437,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.0297563);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 201.539, 0, 1, 0.517043,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465975,-99) , 
2, 2.24037, 0, 0, 0.503444,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54517,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490673,-99) , 
0, 126.003, 1, 0, 0.521116,-99) , 
NN(
0, 
0, 
-1, 200.797, 1, -1, 0.491917,-99) , 
2, 1.95458, 1, 0, 0.496948,-99) , 
1, 216.553, 0, 0, 0.499017,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.0141381);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 212.994, 0, 1, 0.505857,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500548,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483955,-99) , 
2, 3.06199, 0, 0, 0.490017,-99) , 
1, 241.461, 1, 0, 0.502961,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486853,-99) , 
1, 390.91, 1, 0, 0.502004,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.0158896);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508168,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511515,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495869,-99) , 
1, 152.256, 0, 0, 0.505158,-99) , 
NN(
0, 
0, 
-1, 1.79574, 0, -1, 0.492667,-99) , 
1, 186.651, 1, 0, 0.498919,-99) , 
3, 302.079, 0, 0, 0.499661,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.0242968);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 94.1305, 0, 1, 0.511781,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48349,-99) , 
2, 2.23724, 0, 0, 0.504278,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5565,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493465,-99) , 
0, 79.639, 0, 0, 0.513989,-99) , 
NN(
0, 
0, 
-1, 100.416, 0, -1, 0.492874,-99) , 
0, 89.8953, 1, 0, 0.499003,-99) , 
0, 134.071, 0, 0, 0.500825,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.0174992);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.56013, 1, 1, 0.508429,-99) , 
NN(
0, 
0, 
-1, 192.183, 1, -1, 0.48925,-99) , 
0, 139.593, 1, 0, 0.503839,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494009,-99) , 
0, 250.033, 1, 0, 0.503066,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0230773);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526528,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494765,-99) , 
3, 107.554, 0, 0, 0.510088,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492496,-99) , 
3, 188.101, 1, 0, 0.504634,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545467,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495289,-99) , 
0, 90.298, 1, 0, 0.511447,-99) , 
NN(
0, 
0, 
-1, 78.8515, 0, -1, 0.493096,-99) , 
2, 2.56086, 1, 0, 0.499556,-99) , 
0, 134.071, 0, 0, 0.501309,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0127551);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 212.994, 0, 1, 0.506983,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50222,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48847,-99) , 
1, 312.628, 1, 0, 0.498179,-99) , 
1, 241.461, 1, 0, 0.505373,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497347,-99) , 
1, 390.91, 1, 0, 0.504897,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0181416);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 201.539, 0, 1, 0.512935,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474186,-99) , 
2, 1.79574, 0, 0, 0.506436,-99) , 
NN(
NN(
0, 
0, 
-1, 126.003, 1, 1, 0.519708,-99) , 
NN(
0, 
0, 
-1, 200.797, 1, -1, 0.496541,-99) , 
2, 1.95458, 1, 0, 0.500529,-99) , 
1, 216.553, 0, 0, 0.502409,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.0118501);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 228.706, 0, 1, 0.510798,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503537,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483878,-99) , 
3, 38.4989, 0, 0, 0.501936,-99) , 
3, 201.44, 0, 0, 0.504126,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496101,-99) , 
2, 1.34758, 0, 0, 0.503478,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.0194032);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521898,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509412,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494933,-99) , 
2, 2.49134, 1, 0, 0.500791,-99) , 
2, 4.01654, 0, 0, 0.50291,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50955,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488872,-99) , 
2, 3.14881, 1, 0, 0.50261,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479987,-99) , 
2, 1.96286, 0, 0, 0.499094,-99) , 
3, 151.12, 1, 0, 0.501328,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.0177003);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524494,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491541,-99) , 
2, 2.58993, 0, 0, 0.512157,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510708,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49646,-99) , 
2, 2.24095, 1, 0, 0.500575,-99) , 
3, 122.365, 0, 0, 0.503257,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521073,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497065,-99) , 
1, 227.471, 0, 0, 0.503844,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500402,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482303,-99) , 
0, 130.995, 0, 0, 0.489046,-99) , 
3, 194.252, 0, 0, 0.498501,-99) , 
3, 151.12, 1, 0, 0.501285,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.0180123);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.43092, 0, 1, 0.514599,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50476,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487538,-99) , 
3, 50.4799, 0, 0, 0.503046,-99) , 
2, 2.57617, 1, 0, 0.504836,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516179,-99) , 
NN(
0, 
0, 
-1, 186.651, 1, -1, 0.485286,-99) , 
0, 107.21, 1, 0, 0.496105,-99) , 
2, 2.23724, 0, 0, 0.502654,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.0111187);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518789,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514566,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499199,-99) , 
2, 1.34754, 1, 0, 0.500697,-99) , 
2, 4.01654, 0, 0, 0.502513,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513626,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498086,-99) , 
1, 227.471, 0, 0, 0.502472,-99) , 
NN(
0, 
0, 
-1, 169.605, 0, -1, 0.487017,-99) , 
3, 194.252, 0, 0, 0.496891,-99) , 
3, 151.12, 1, 0, 0.500182,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.0160936);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521916,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492245,-99) , 
3, 72.0448, 0, 0, 0.510629,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51934,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497825,-99) , 
3, 51.2756, 1, 0, 0.501223,-99) , 
2, 3.12689, 0, 0, 0.504247,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507409,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49755,-99) , 
0, 134.188, 1, 0, 0.503683,-99) , 
NN(
0, 
0, 
-1, 169.605, 0, -1, 0.489795,-99) , 
3, 194.252, 0, 0, 0.498668,-99) , 
3, 151.12, 1, 0, 0.501934,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.0192169);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517184,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509301,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483322,-99) , 
1, 234.8, 1, 0, 0.504723,-99) , 
1, 331.106, 0, 0, 0.505806,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506877,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492977,-99) , 
2, 3.18584, 1, 0, 0.502172,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491133,-99) , 
2, 2.35199, 0, 0, 0.499493,-99) , 
3, 151.12, 1, 0, 0.503188,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.0093793);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 212.994, 0, 1, 0.503881,-99) , 
NN(
0, 
0, 
-1, 312.628, 1, -1, 0.493087,-99) , 
1, 241.461, 1, 0, 0.501908,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491284,-99) , 
1, 390.91, 1, 0, 0.501278,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.015444);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 235.086, 0, 1, 0.505658,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489869,-99) , 
2, 1.79241, 0, 0, 0.50307,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530191,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494684,-99) , 
0, 90.298, 1, 0, 0.506103,-99) , 
NN(
0, 
0, 
-1, 78.8515, 0, -1, 0.494233,-99) , 
2, 2.56086, 1, 0, 0.498408,-99) , 
0, 134.071, 0, 0, 0.500017,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.0178926);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508503,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489143,-99) , 
0, 75.959, 0, 0, 0.505427,-99) , 
NN(
0, 
0, 
-1, 192.183, 1, -1, 0.489464,-99) , 
0, 139.593, 1, 0, 0.501606,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494899,-99) , 
0, 250.033, 1, 0, 0.501078,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.0238172);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542125,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491315,-99) , 
0, 144.59, 1, 0, 0.5066,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494705,-99) , 
0, 244.511, 1, 0, 0.503759,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537853,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494353,-99) , 
0, 79.639, 0, 0, 0.508488,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501123,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463465,-99) , 
0, 100.416, 0, 0, 0.494343,-99) , 
0, 89.8953, 1, 0, 0.498444,-99) , 
0, 134.071, 0, 0, 0.500278,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.0203192);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516382,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48749,-99) , 
0, 244.511, 1, 0, 0.509907,-99) , 
NN(
0, 
0, 
-1, 0, 1, 1, 0.500496,-99) , 
3, 188.101, 1, 0, 0.506989,-99) , 
NN(
NN(
0, 
0, 
-1, 2.38007, 1, 1, 0.510577,-99) , 
NN(
0, 
0, 
-1, 100.416, 0, -1, 0.490532,-99) , 
0, 89.8953, 1, 0, 0.496341,-99) , 
0, 134.071, 0, 0, 0.500016,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.0146239);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512685,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491994,-99) , 
3, 71.7563, 0, 0, 0.507106,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495416,-99) , 
3, 188.101, 1, 0, 0.503481,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508166,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496902,-99) , 
2, 2.56086, 1, 0, 0.500931,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487932,-99) , 
0, 123.027, 1, 0, 0.498476,-99) , 
0, 134.071, 0, 0, 0.500203,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.00662731);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5063,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506468,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499794,-99) , 
3, 194.255, 0, 0, 0.501782,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485273,-99) , 
2, 1.28346, 0, 0, 0.50061,-99) , 
3, 50.4799, 1, 0, 0.501198,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.0142233);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517821,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505787,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487887,-99) , 
1, 152.255, 0, 0, 0.501901,-99) , 
1, 331.106, 0, 0, 0.503285,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513243,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497622,-99) , 
1, 227.471, 0, 0, 0.502032,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501041,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487945,-99) , 
3, 169.605, 0, 0, 0.494853,-99) , 
3, 194.252, 0, 0, 0.499441,-99) , 
3, 151.12, 1, 0, 0.501691,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.0111157);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511469,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49941,-99) , 
3, 129.885, 0, 0, 0.505568,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50324,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493423,-99) , 
1, 216.158, 0, 0, 0.498159,-99) , 
1, 175.039, 1, 0, 0.501308,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493024,-99) , 
1, 390.91, 1, 0, 0.500816,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.00904722);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506384,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509078,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499669,-99) , 
0, 116.453, 0, 0, 0.503017,-99) , 
NN(
0, 
0, 
-1, 192.183, 1, -1, 0.492711,-99) , 
0, 139.593, 1, 0, 0.50055,-99) , 
0, 250.033, 0, 0, 0.50101,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.00889379);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.57617, 1, 1, 0.502663,-99) , 
NN(
NN(
0, 
0, 
-1, 1.70766, 1, 1, 0.509332,-99) , 
NN(
0, 
0, 
-1, 1.49719, 0, -1, 0.489761,-99) , 
1, 186.651, 1, 0, 0.499158,-99) , 
2, 2.23724, 0, 0, 0.501787,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.0125094);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513367,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494509,-99) , 
1, 195.486, 1, 0, 0.504503,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496888,-99) , 
3, 188.101, 1, 0, 0.502142,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506558,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498119,-99) , 
1, 177.272, 1, 0, 0.50178,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487523,-99) , 
0, 123.027, 1, 0, 0.499088,-99) , 
0, 134.071, 0, 0, 0.500141,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.0103889);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518219,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496459,-99) , 
0, 134.188, 0, 0, 0.505013,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510019,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498633,-99) , 
1, 166.014, 0, 0, 0.502769,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50198,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490857,-99) , 
3, 143.925, 1, 0, 0.498012,-99) , 
1, 186.651, 1, 0, 0.50039,-99) , 
3, 251.76, 0, 0, 0.501038,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.0109041);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510502,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504395,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498332,-99) , 
0, 134.188, 0, 0, 0.500633,-99) , 
2, 2.74112, 1, 0, 0.504376,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509018,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494442,-99) , 
0, 110.398, 0, 0, 0.503197,-99) , 
NN(
0, 
0, 
-1, 143.927, 1, -1, 0.496875,-99) , 
1, 186.651, 1, 0, 0.50004,-99) , 
3, 201.44, 0, 0, 0.501101,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.0128131);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 201.539, 0, 1, 0.509052,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48888,-99) , 
2, 2.24037, 0, 0, 0.503693,-99) , 
NN(
NN(
0, 
0, 
-1, 1.9421, 1, 1, 0.503313,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484073,-99) , 
1, 199.948, 1, 0, 0.50087,-99) , 
1, 216.553, 0, 0, 0.501769,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.0127626);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513661,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502992,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485719,-99) , 
3, 144.037, 1, 0, 0.49844,-99) , 
3, 201.539, 0, 0, 0.502192,-99) , 
NN(
NN(
0, 
0, 
-1, 126.003, 1, 1, 0.512122,-99) , 
NN(
0, 
0, 
-1, 200.797, 1, -1, 0.495647,-99) , 
2, 1.95458, 1, 0, 0.49848,-99) , 
1, 216.553, 0, 0, 0.499662,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.0118546);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514133,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489895,-99) , 
3, 60.5695, 0, 0, 0.506446,-99) , 
NN(
0, 
0, 
-1, 134.188, 1, -1, 0.497334,-99) , 
3, 141.116, 1, 0, 0.502422,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503297,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493158,-99) , 
1, 225.05, 1, 0, 0.500609,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489538,-99) , 
2, 1.19931, 0, 0, 0.499584,-99) , 
2, 3.12689, 0, 0, 0.500476,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.0114262);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512591,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491403,-99) , 
2, 3.42344, 0, 0, 0.505363,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501794,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497718,-99) , 
0, 134.188, 1, 0, 0.500297,-99) , 
3, 141.116, 1, 0, 0.503126,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504208,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484136,-99) , 
2, 1.09339, 0, 0, 0.501223,-99) , 
NN(
0, 
0, 
-1, 2.67501, 0, -1, 0.495861,-99) , 
2, 2.53379, 1, 0, 0.498595,-99) , 
2, 3.12689, 0, 0, 0.50002,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.0131175);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505682,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498141,-99) , 
1, 225.05, 1, 0, 0.503593,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488338,-99) , 
3, 50.4799, 0, 0, 0.502056,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513033,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495417,-99) , 
2, 2.31287, 0, 0, 0.499629,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480536,-99) , 
2, 2.55497, 1, 0, 0.4971,-99) , 
2, 2.68206, 0, 0, 0.500013,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.0122176);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515731,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504915,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49248,-99) , 
0, 136.391, 1, 0, 0.500507,-99) , 
3, 201.539, 0, 0, 0.50426,-99) , 
NN(
NN(
0, 
0, 
-1, 126.003, 1, 1, 0.509999,-99) , 
NN(
0, 
0, 
-1, 200.797, 1, -1, 0.495922,-99) , 
2, 1.95458, 1, 0, 0.498343,-99) , 
1, 216.553, 0, 0, 0.500225,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.0111054);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50524,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499854,-99) , 
1, 225.05, 1, 0, 0.503748,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493297,-99) , 
3, 50.4799, 0, 0, 0.502695,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526645,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496005,-99) , 
2, 1.79614, 1, 0, 0.50692,-99) , 
NN(
0, 
0, 
-1, 1.41113, 0, -1, 0.494738,-99) , 
0, 106.201, 1, 0, 0.49892,-99) , 
2, 2.68206, 0, 0, 0.501139,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.00880053);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 201.539, 0, 1, 0.508735,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494633,-99) , 
2, 2.24037, 0, 0, 0.504988,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509213,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499989,-99) , 
2, 1.9421, 1, 0, 0.50153,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488631,-99) , 
1, 199.948, 1, 0, 0.499893,-99) , 
1, 216.553, 0, 0, 0.501514,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.00679851);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508191,-99) , 
NN(
NN(
0, 
0, 
-1, 194.255, 0, 1, 0.502373,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490957,-99) , 
2, 1.28346, 0, 0, 0.501563,-99) , 
3, 50.4799, 1, 0, 0.502248,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.00634492);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506492,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50523,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498741,-99) , 
3, 194.255, 0, 0, 0.500673,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492656,-99) , 
2, 1.28346, 0, 0, 0.500104,-99) , 
3, 50.4799, 1, 0, 0.500765,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.0143083);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511022,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489342,-99) , 
0, 244.511, 1, 0, 0.506166,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496262,-99) , 
3, 188.101, 1, 0, 0.503096,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529564,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497744,-99) , 
0, 79.639, 0, 0, 0.508079,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50084,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473871,-99) , 
0, 98.3129, 0, 0, 0.497065,-99) , 
0, 89.8953, 1, 0, 0.500257,-99) , 
0, 134.071, 0, 0, 0.501236,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.00752675);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507493,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501893,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493123,-99) , 
0, 144.324, 1, 0, 0.500565,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48479,-99) , 
0, 194.812, 1, 0, 0.499564,-99) , 
0, 250.033, 0, 0, 0.500189,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.0137762);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 225.388, 0, 1, 0.50571,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496515,-99) , 
3, 94.1305, 0, 0, 0.503024,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526274,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498895,-99) , 
2, 2.38007, 1, 0, 0.507453,-99) , 
NN(
0, 
0, 
-1, 100.416, 0, -1, 0.492608,-99) , 
0, 89.8953, 1, 0, 0.496909,-99) , 
0, 134.071, 0, 0, 0.499018,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.00519938);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505096,-99) , 
NN(
NN(
0, 
0, 
-1, 95.0731, 1, 1, 0.502328,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50036,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495774,-99) , 
1, 186.651, 0, 0, 0.498058,-99) , 
2, 2.97727, 0, 0, 0.499827,-99) , 
3, 50.4799, 1, 0, 0.500372,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.00662191);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505599,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500658,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484965,-99) , 
2, 1.08632, 0, 0, 0.499588,-99) , 
2, 3.23278, 0, 0, 0.500337,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507265,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487501,-99) , 
2, 4.12247, 0, 0, 0.496402,-99) , 
2, 3.57172, 1, 0, 0.499757,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.00915312);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502681,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515226,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487966,-99) , 
3, 139.662, 1, 0, 0.502469,-99) , 
NN(
0, 
0, 
-1, 98.412, 0, -1, 0.497117,-99) , 
2, 3.40072, 0, 0, 0.49806,-99) , 
3, 50.4799, 1, 0, 0.498538,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.00727698);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51583,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498785,-99) , 
2, 3.35382, 0, 0, 0.503565,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501211,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495883,-99) , 
2, 2.77282, 1, 0, 0.499707,-99) , 
2, 3.06332, 0, 0, 0.500672,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504538,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488817,-99) , 
2, 4.12247, 0, 0, 0.495896,-99) , 
2, 3.57172, 1, 0, 0.499968,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.00592574);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 3.35382, 0, 1, 0.504364,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500555,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496798,-99) , 
2, 2.33707, 0, 0, 0.498915,-99) , 
2, 3.06332, 0, 0, 0.500277,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502719,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490635,-99) , 
2, 4.12247, 0, 0, 0.496076,-99) , 
2, 3.57172, 1, 0, 0.499659,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.00988289);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507105,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496335,-99) , 
2, 2.87388, 0, 0, 0.501689,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513649,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496613,-99) , 
2, 1.34754, 1, 0, 0.498271,-99) , 
3, 151.764, 0, 0, 0.499729,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493471,-99) , 
2, 4.01654, 1, 0, 0.499244,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.00428013);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503536,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499665,-99) , 
3, 151.764, 0, 0, 0.501333,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494116,-99) , 
2, 1.15694, 0, 0, 0.500876,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495942,-99) , 
2, 4.01654, 1, 0, 0.500494,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.0120021);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516989,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503282,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488741,-99) , 
1, 234.8, 1, 0, 0.500719,-99) , 
1, 331.106, 0, 0, 0.502135,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510559,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494734,-99) , 
2, 2.09255, 0, 0, 0.503417,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500654,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484322,-99) , 
2, 3.00054, 0, 0, 0.495791,-99) , 
2, 2.74112, 1, 0, 0.498837,-99) , 
3, 151.12, 1, 0, 0.500767,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.00941017);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508484,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502454,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490622,-99) , 
3, 144.037, 1, 0, 0.499338,-99) , 
3, 201.539, 0, 0, 0.501592,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502016,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49406,-99) , 
3, 189.403, 1, 0, 0.499805,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486541,-99) , 
1, 199.948, 1, 0, 0.498121,-99) , 
1, 216.553, 0, 0, 0.499225,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.00887308);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50315,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493907,-99) , 
1, 225.05, 1, 0, 0.500557,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50399,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495367,-99) , 
3, 123.03, 0, 0, 0.497426,-99) , 
3, 151.764, 0, 0, 0.498762,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493516,-99) , 
2, 4.01654, 1, 0, 0.498355,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.0182645);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.685, 1, 1, 0.506384,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538266,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480259,-99) , 
0, 90.0145, 1, 0, 0.498726,-99) , 
0, 134.188, 0, 0, 0.501668,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511898,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498834,-99) , 
0, 126.003, 1, 0, 0.506115,-99) , 
NN(
0, 
0, 
-1, 200.797, 1, -1, 0.495589,-99) , 
2, 1.95458, 1, 0, 0.497399,-99) , 
1, 216.553, 0, 0, 0.498757,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.00550982);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 250.033, 0, 1, 0.502145,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489541,-99) , 
1, 307.882, 1, 0, 0.501398,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495383,-99) , 
1, 390.91, 1, 0, 0.501041,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.00438834);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520263,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499992,-99) , 
0, 250.033, 0, 0, 0.501407,-99) , 
NN(
0, 
0, 
-1, 312.628, 1, -1, 0.494711,-99) , 
1, 241.461, 1, 0, 0.500184,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496761,-99) , 
1, 390.91, 1, 0, 0.49998,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.00699048);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512686,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499448,-99) , 
2, 2.31287, 0, 0, 0.502614,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511011,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498637,-99) , 
2, 3.32961, 0, 0, 0.500335,-99) , 
2, 2.55495, 1, 0, 0.501291,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505945,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493389,-99) , 
2, 4.12247, 0, 0, 0.499043,-99) , 
2, 3.57172, 1, 0, 0.50096,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.00613681);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503976,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499631,-99) , 
1, 225.05, 1, 0, 0.502797,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495782,-99) , 
2, 1.15694, 0, 0, 0.502353,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497008,-99) , 
2, 4.01654, 1, 0, 0.501939,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.00974798);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510235,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506224,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493293,-99) , 
0, 136.391, 1, 0, 0.50164,-99) , 
3, 201.539, 0, 0, 0.503758,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503355,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497615,-99) , 
3, 189.403, 1, 0, 0.50176,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491893,-99) , 
1, 199.948, 1, 0, 0.500508,-99) , 
1, 216.553, 0, 0, 0.501541,-99)    );
   return;
};
 
// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
