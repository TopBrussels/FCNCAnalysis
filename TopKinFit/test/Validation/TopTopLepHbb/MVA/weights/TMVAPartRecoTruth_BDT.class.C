// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.06/01       [394753]
Creator        : kskovpen
Date           : Fri Feb  3 15:58:45 2017
Host           : Linux vocms0301.cern.ch 2.6.32-642.11.1.el6.x86_64 #1 SMP Wed Nov 16 09:40:09 CET 2016 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /storage_mnt/storage/user/kskovpen/analysis/tHFCNC/CMSSW_8_0_25/src/TopKinFit/test/Validation/TopTopLepHbb/MVA
Training events: 205009
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
SeparationType: "giniindex" [Separation criterion for node splitting]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
MinNodeSize: "5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "2" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 4
HiggsRecMTruth                HiggsRecMTruth                HiggsRecMTruth                HiggsRecMTruth                                                  'F'    [18.8569850922,1395.77966309]
TopLepRecMTTruth              TopLepRecMTTruth              TopLepRecMTTruth              TopLepRecMTTruth                                                'F'    [4.15502595901,1252.03723145]
HiggsTopLepRecDphiTTruth      HiggsTopLepRecDphiTTruth      HiggsTopLepRecDphiTTruth      HiggsTopLepRecDphiTTruth                                        'F'    [-3.14159226418,3.14158916473]
TopLepRecPtTTruth             TopLepRecPtTTruth             TopLepRecPtTTruth             TopLepRecPtTTruth                                               'F'    [0.132021471858,956.018859863]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTNode
   
#ifndef BDTNode__def
#define BDTNode__def
   
class BDTNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 4 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "HiggsRecMTruth", "TopLepRecMTTruth", "HiggsTopLepRecDphiTTruth", "TopLepRecPtTTruth" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[4];
   double fVmax[4];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[4];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadBDT::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(0.535761878189586);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 134.398, 0, 1, 0.682874,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.263775,-99) , 
0, 75.0578, 0, 0, 0.631245,-99) , 
NN(
0, 
0, 
-1, 209.316, 1, -1, 0.0760128,-99) , 
0, 149.992, 1, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.321967);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 134.883, 1, 1, 0.816286,-99) , 
NN(
0, 
0, 
-1, 213.601, 1, -1, 0.461855,-99) , 
3, 179.153, 0, 0, 0.536245,-99) , 
NN(
0, 
0, 
-1, 209.316, 1, -1, 0.123247,-99) , 
0, 149.992, 1, 0, 0.449116,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.371204);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 134.398, 0, 1, 0.625072,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.245378,-99) , 
1, 213.601, 1, 0, 0.585174,-99) , 
NN(
0, 
0, 
-1, 209.316, 1, -1, 0.162456,-99) , 
0, 149.992, 1, 0, 0.502617,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.281361);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.709529,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451125,-99) , 
1, 175.487, 1, 0, 0.657229,-99) , 
NN(
0, 
0, 
-1, 131.308, 1, -1, 0.434558,-99) , 
3, 134.398, 0, 0, 0.513388,-99) , 
NN(
0, 
0, 
-1, 209.316, 1, -1, 0.219452,-99) , 
0, 149.992, 1, 0, 0.459588,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.242321);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.795748,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.55095,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.333708,-99) , 
0, 131.259, 1, 0, 0.498854,-99) , 
3, 227.724, 0, 0, 0.525781,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.087963,-99) , 
0, 215.56, 1, 0, 0.497117,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.146907);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.753544,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500162,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.318577,-99) , 
0, 84.4247, 0, 0, 0.466854,-99) , 
3, 227.724, 0, 0, 0.491587,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.109443,-99) , 
0, 215.56, 1, 0, 0.46839,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.178621);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.725259,-99) , 
NN(
0, 
0, 
-1, 166.7, 1, -1, 0.443365,-99) , 
3, 227.724, 0, 0, 0.466962,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.124604,-99) , 
0, 215.56, 1, 0, 0.447158,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.156367);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 182.206, 0, 1, 0.545022,-99) , 
NN(
0, 
0, 
-1, 131.255, 1, -1, 0.394421,-99) , 
1, 167.836, 1, 0, 0.504094,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.145428,-99) , 
0, 215.56, 1, 0, 0.484425,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.132735);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -2.24399, 1, 1, 0.616123,-99) , 
NN(
0, 
0, 
-1, 140.626, 1, -1, 0.461287,-99) , 
3, 182.206, 0, 0, 0.486153,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.165958,-99) , 
0, 215.56, 1, 0, 0.469362,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.199344);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.581909,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.426999,-99) , 
0, 94.2374, 0, 0, 0.532157,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522371,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.319968,-99) , 
3, 136.717, 0, 0, 0.388152,-99) , 
0, 140.626, 1, 0, 0.508704,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.185154,-99) , 
0, 215.56, 1, 0, 0.492345,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.142174);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.552242,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466373,-99) , 
3, 91.1689, 0, 0, 0.517532,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.287374,-99) , 
0, 181.992, 1, 0, 0.499903,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.253303,-99) , 
1, 241.847, 1, 0, 0.482908,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.107743);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522181,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.36442,-99) , 
0, 65.4667, 0, 0, 0.510803,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.317345,-99) , 
0, 181.992, 1, 0, 0.496314,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.281122,-99) , 
1, 241.847, 1, 0, 0.481858,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.128905);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545445,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465523,-99) , 
0, 101.719, 0, 0, 0.505396,-99) , 
NN(
0, 
0, 
-1, 136.717, 0, -1, 0.411041,-99) , 
0, 127.614, 1, 0, 0.476922,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.3034,-99) , 
1, 241.847, 1, 0, 0.465474,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.0821195);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.628985,-99) , 
NN(
0, 
0, 
-1, 181.992, 1, -1, 0.475459,-99) , 
3, 227.724, 0, 0, 0.486589,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.331313,-99) , 
1, 241.847, 1, 0, 0.47652,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.0930964);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5284,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.442703,-99) , 
1, 94.7009, 0, 0, 0.513321,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.385722,-99) , 
0, 181.992, 1, 0, 0.504143,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.349751,-99) , 
1, 241.847, 1, 0, 0.494237,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.08845);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.630947,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513975,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45197,-99) , 
1, 114.512, 0, 0, 0.491241,-99) , 
3, 227.724, 0, 0, 0.501395,-99) , 
NN(
0, 
0, 
-1, -2.24399, 1, -1, 0.416482,-99) , 
1, 182.424, 1, 0, 0.484135,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.134199);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.659472,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525835,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468188,-99) , 
3, 105.249, 0, 0, 0.493462,-99) , 
3, 156.529, 0, 0, 0.543231,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.671237,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491793,-99) , 
3, 155.999, 0, 0, 0.546094,-99) , 
NN(
0, 
0, 
-1, 182.206, 1, -1, 0.43024,-99) , 
2, -2.60019, 1, 0, 0.463895,-99) , 
2, 2.54319, 0, 0, 0.482927,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.0896876);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.615526,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.552947,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49296,-99) , 
3, 98.2346, 0, 0, 0.518651,-99) , 
3, 137.226, 0, 0, 0.557093,-99) , 
NN(
NN(
0, 
0, 
-1, 155.402, 0, 1, 0.531646,-99) , 
NN(
0, 
0, 
-1, 179.153, 1, -1, 0.45584,-99) , 
2, 2.32948, 0, 0, 0.485056,-99) , 
2, -2.54319, 1, 0, 0.502217,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.0749019);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 117.189, 0, 1, 0.571252,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5199,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45709,-99) , 
0, 127.614, 1, 0, 0.501175,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.387213,-99) , 
1, 241.847, 1, 0, 0.494093,-99) , 
2, -2.84239, 1, 0, 0.504491,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.0728882);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.621367,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525948,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465574,-99) , 
1, 101.635, 0, 0, 0.512637,-99) , 
3, 182.568, 0, 0, 0.53062,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.580398,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478311,-99) , 
3, 118.07, 0, 0, 0.534258,-99) , 
NN(
0, 
0, 
-1, 179.153, 1, -1, 0.470942,-99) , 
2, 2.88513, 0, 0, 0.48176,-99) , 
2, -2.24399, 1, 0, 0.496834,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.0435202);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.579023,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509362,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.42156,-99) , 
0, 181.992, 1, 0, 0.503414,-99) , 
3, 227.724, 0, 0, 0.508506,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.427304,-99) , 
1, 241.847, 1, 0, 0.503528,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.0247161);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.553292,-99) , 
NN(
0, 
0, 
-1, 241.847, 1, -1, 0.490799,-99) , 
3, 227.724, 0, 0, 0.495269,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.0550513);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520694,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460936,-99) , 
1, 72.0669, 0, 0, 0.515749,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.429021,-99) , 
0, 69.6812, 0, 0, 0.508664,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501224,-99) , 
NN(
0, 
0, 
-1, -1.77392, 1, -1, 0.449101,-99) , 
2, 1.64559, 0, 0, 0.468207,-99) , 
1, 182.424, 1, 0, 0.500564,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.047625);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.577405,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480829,-99) , 
3, 117.189, 0, 0, 0.533757,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508809,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478047,-99) , 
3, 91.1689, 1, 0, 0.491331,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.429728,-99) , 
1, 241.847, 1, 0, 0.48757,-99) , 
2, -2.84239, 1, 0, 0.493756,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.0414987);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550183,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505918,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.369587,-99) , 
0, 137.503, 1, 0, 0.495435,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503756,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438133,-99) , 
3, 108.521, 0, 0, 0.466602,-99) , 
0, 149.992, 1, 0, 0.491361,-99) , 
3, 227.724, 0, 0, 0.495547,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.0559342);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.556686,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485868,-99) , 
3, 117.189, 0, 0, 0.52459,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.554121,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472111,-99) , 
3, 118.07, 0, 0, 0.516674,-99) , 
NN(
0, 
0, 
-1, 182.206, 1, -1, 0.476281,-99) , 
2, 2.85664, 0, 0, 0.482333,-99) , 
2, -2.84239, 1, 0, 0.487977,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.0340563);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544069,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506801,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461258,-99) , 
0, 150.303, 1, 0, 0.500424,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5057,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466409,-99) , 
2, -2.24398, 1, 0, 0.480784,-99) , 
3, 130.184, 1, 0, 0.494436,-99) , 
3, 227.724, 0, 0, 0.49794,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.0220036);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535609,-99) , 
NN(
0, 
0, 
-1, 241.847, 1, -1, 0.490867,-99) , 
3, 227.724, 0, 0, 0.494023,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.0184161);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544558,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501481,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454003,-99) , 
0, 181.992, 1, 0, 0.498293,-99) , 
3, 227.724, 0, 0, 0.50135,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458455,-99) , 
1, 241.847, 1, 0, 0.498747,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.0282188);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.84239, 0, 1, 0.50489,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.439799,-99) , 
0, 69.6812, 0, 0, 0.499571,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516259,-99) , 
NN(
0, 
0, 
-1, 1.204, 0, -1, 0.458774,-99) , 
2, -1.9448, 1, 0, 0.477912,-99) , 
1, 182.424, 1, 0, 0.495244,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.0529127);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.583886,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511695,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475598,-99) , 
2, 2.45771, 1, 0, 0.489552,-99) , 
3, 193.189, 0, 0, 0.501566,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542394,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491343,-99) , 
3, 182.568, 0, 0, 0.499058,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500516,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.388348,-99) , 
3, 89.6424, 1, 0, 0.450866,-99) , 
2, -1.64562, 1, 0, 0.483296,-99) , 
2, 1.34639, 0, 0, 0.490989,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.0438859);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543838,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520295,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493054,-99) , 
1, 150.375, 0, 0, 0.503223,-99) , 
3, 182.568, 0, 0, 0.509457,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.56628,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492912,-99) , 
3, 193.189, 0, 0, 0.502175,-99) , 
NN(
0, 
0, 
-1, 134.398, 1, -1, 0.45436,-99) , 
2, 1.20392, 0, 0, 0.486483,-99) , 
2, -1.9448, 1, 0, 0.494682,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.053914);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 118.07, 0, 1, 0.527195,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51356,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462765,-99) , 
0, 144.477, 1, 0, 0.505188,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532666,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.374483,-99) , 
2, -2.00179, 1, 0, 0.444679,-99) , 
3, 182.206, 1, 0, 0.496655,-99) , 
2, 2.84239, 0, 0, 0.50078,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.0417132);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.566978,-99) , 
NN(
0, 
0, 
-1, 67.2725, 0, -1, 0.482927,-99) , 
3, 155.34, 0, 0, 0.505933,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501843,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474621,-99) , 
0, 144.477, 1, 0, 0.497224,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.419556,-99) , 
3, 182.206, 1, 0, 0.48628,-99) , 
2, 2.24399, 0, 0, 0.492422,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.0390466);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.55671,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501925,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466852,-99) , 
3, 67.2725, 0, 0, 0.493349,-99) , 
3, 155.34, 0, 0, 0.510665,-99) , 
NN(
0, 
0, 
-1, 182.206, 1, -1, 0.481819,-99) , 
2, 2.24399, 0, 0, 0.490831,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.0441092);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.595696,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48856,-99) , 
1, 124.943, 1, 0, 0.52724,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.55006,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493504,-99) , 
1, 213.601, 0, 0, 0.498968,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.386256,-99) , 
0, 137.503, 1, 0, 0.490229,-99) , 
0, 149.992, 0, 0, 0.495573,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.0465408);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.585029,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499586,-99) , 
1, 124.943, 1, 0, 0.53036,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512506,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453882,-99) , 
0, 64.055, 0, 0, 0.507867,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.396764,-99) , 
0, 137.503, 1, 0, 0.499288,-99) , 
0, 149.992, 0, 0, 0.503771,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.0331614);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 124.943, 1, 1, 0.533662,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503082,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469677,-99) , 
3, 179.153, 1, 0, 0.498073,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.407955,-99) , 
0, 137.503, 1, 0, 0.491141,-99) , 
0, 149.992, 0, 0, 0.497274,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0380714);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 124.943, 1, 1, 0.525401,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52455,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488825,-99) , 
1, 213.601, 0, 0, 0.492268,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.415988,-99) , 
0, 137.503, 1, 0, 0.486415,-99) , 
0, 149.992, 0, 0, 0.492035,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.0200708);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 227.724, 0, 1, 0.504338,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464324,-99) , 
1, 196.57, 1, 0, 0.500584,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.446752,-99) , 
1, 241.847, 1, 0, 0.497357,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0215667);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538299,-99) , 
NN(
0, 
0, 
-1, 72.0662, 0, -1, 0.493651,-99) , 
3, 227.724, 0, 0, 0.496507,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451718,-99) , 
1, 241.847, 1, 0, 0.493825,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.026199);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507527,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473617,-99) , 
1, 193.336, 1, 0, 0.503718,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46865,-99) , 
1, 72.0662, 0, 0, 0.501209,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457065,-99) , 
1, 241.847, 1, 0, 0.498567,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.0303054);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.551211,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493952,-99) , 
1, 124.943, 1, 0, 0.514498,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531664,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493777,-99) , 
1, 213.601, 0, 0, 0.497432,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.422349,-99) , 
0, 137.503, 1, 0, 0.491687,-99) , 
0, 149.992, 0, 0, 0.494965,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.0253135);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5356,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509138,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490584,-99) , 
1, 128.659, 0, 0, 0.500942,-99) , 
3, 227.724, 0, 0, 0.503156,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460386,-99) , 
1, 241.847, 1, 0, 0.500604,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.026476);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511754,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475365,-99) , 
0, 70.3568, 0, 0, 0.508598,-99) , 
NN(
0, 
0, 
-1, 158.354, 1, -1, 0.489752,-99) , 
1, 151.296, 1, 0, 0.502062,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466681,-99) , 
1, 241.847, 1, 0, 0.499953,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.030375);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531636,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507024,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492454,-99) , 
0, 120.816, 1, 0, 0.501757,-99) , 
2, -2.92789, 1, 0, 0.50924,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550581,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498999,-99) , 
3, 193.189, 0, 0, 0.505384,-99) , 
NN(
0, 
0, 
-1, 89.6424, 1, -1, 0.459578,-99) , 
2, 1.08994, 0, 0, 0.492681,-99) , 
2, -1.6456, 1, 0, 0.499145,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.0331855);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.551305,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514683,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477093,-99) , 
1, 104.163, 0, 0, 0.506308,-99) , 
3, 193.189, 0, 0, 0.511917,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525737,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499366,-99) , 
2, -2.95841, 1, 0, 0.504622,-99) , 
NN(
0, 
0, 
-1, 89.6424, 1, -1, 0.464666,-99) , 
2, -1.2182, 1, 0, 0.494069,-99) , 
2, 1.34639, 0, 0, 0.501589,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0323233);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 124.943, 1, 1, 0.521703,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509491,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480268,-99) , 
3, 179.153, 1, 0, 0.505132,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.43381,-99) , 
0, 137.503, 1, 0, 0.499693,-99) , 
0, 149.992, 0, 0, 0.502851,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0115482);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529426,-99) , 
NN(
0, 
0, 
-1, 181.992, 1, -1, 0.497387,-99) , 
3, 227.724, 0, 0, 0.499416,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471118,-99) , 
1, 241.847, 1, 0, 0.497732,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0129143);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526548,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502171,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473742,-99) , 
0, 181.992, 1, 0, 0.500274,-99) , 
3, 227.724, 0, 0, 0.501938,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473996,-99) , 
1, 241.847, 1, 0, 0.500275,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.0231845);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 124.943, 1, 1, 0.516154,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531282,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495715,-99) , 
1, 213.601, 0, 0, 0.499141,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.441364,-99) , 
0, 137.503, 1, 0, 0.494741,-99) , 
0, 149.992, 0, 0, 0.49781,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.0160622);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 227.724, 0, 1, 0.505333,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47926,-99) , 
1, 196.57, 1, 0, 0.502892,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472127,-99) , 
1, 241.847, 1, 0, 0.501061,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.0281396);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542273,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523783,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494516,-99) , 
2, -2.14433, 0, 0, 0.49949,-99) , 
3, 182.568, 0, 0, 0.50588,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527034,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494104,-99) , 
0, 84.4247, 1, 0, 0.499621,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458336,-99) , 
3, 179.153, 1, 0, 0.493329,-99) , 
2, -1.6456, 1, 0, 0.498231,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.0276644);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 175.703, 0, 1, 0.513758,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508866,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47044,-99) , 
2, 0.719505, 0, 0, 0.49924,-99) , 
2, -1.9448, 1, 0, 0.504658,-99) , 
NN(
0, 
0, 
-1, -0.748149, 0, -1, 0.486953,-99) , 
3, 45.6504, 0, 0, 0.502433,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.0178707);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506623,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491592,-99) , 
3, 134.398, 1, 0, 0.5021,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48082,-99) , 
1, 72.0662, 0, 0, 0.500582,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476538,-99) , 
1, 241.847, 1, 0, 0.499154,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.0167083);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515822,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503992,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488361,-99) , 
1, 123.001, 0, 0, 0.498366,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479702,-99) , 
3, 184.372, 1, 0, 0.496892,-99) , 
3, 227.724, 0, 0, 0.498165,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.0135999);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537489,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497942,-99) , 
3, 227.724, 0, 0, 0.500408,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479143,-99) , 
1, 196.57, 1, 0, 0.498418,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477676,-99) , 
1, 241.847, 1, 0, 0.497186,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.0309708);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530784,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491168,-99) , 
3, 118.07, 0, 0, 0.512467,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505009,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488307,-99) , 
2, -2.85664, 0, 0, 0.502719,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544681,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.410434,-99) , 
2, -2.00179, 1, 0, 0.470814,-99) , 
3, 182.206, 1, 0, 0.498318,-99) , 
2, 2.84239, 0, 0, 0.500225,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.0235344);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523064,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49891,-99) , 
3, 118.07, 0, 0, 0.511892,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500452,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48731,-99) , 
2, 1.98753, 1, 0, 0.497099,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53699,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.417948,-99) , 
2, -2.00179, 1, 0, 0.47153,-99) , 
3, 182.206, 1, 0, 0.493578,-99) , 
2, 2.84239, 0, 0, 0.496046,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.033561);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.552452,-99) , 
NN(
0, 
0, 
-1, 148.168, 0, -1, 0.48804,-99) , 
3, 155.34, 0, 0, 0.505492,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510503,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491931,-99) , 
0, 81.667, 1, 0, 0.494602,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451144,-99) , 
3, 182.206, 1, 0, 0.488633,-99) , 
2, 2.24399, 0, 0, 0.493905,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.0248749);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54414,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504952,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491229,-99) , 
1, 148.168, 0, 0, 0.496428,-99) , 
3, 155.34, 0, 0, 0.509342,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506321,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495413,-99) , 
2, -1.85931, 0, 0, 0.500578,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459467,-99) , 
3, 182.206, 1, 0, 0.494938,-99) , 
2, 2.24399, 0, 0, 0.499442,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.0351261);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537862,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508646,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481923,-99) , 
3, 85.2381, 0, 0, 0.497045,-99) , 
3, 137.226, 0, 0, 0.512843,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503544,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490033,-99) , 
1, 183.191, 1, 0, 0.500896,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547377,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.378965,-99) , 
2, 2.0588, 0, 0, 0.467451,-99) , 
3, 179.153, 1, 0, 0.496054,-99) , 
2, -2.54319, 1, 0, 0.500041,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.0336816);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52912,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50927,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485374,-99) , 
1, 141.717, 0, 0, 0.495886,-99) , 
3, 137.226, 0, 0, 0.508742,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5061,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493404,-99) , 
0, 84.4247, 1, 0, 0.495556,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53866,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.387267,-99) , 
2, 2.0588, 0, 0, 0.466909,-99) , 
3, 179.153, 1, 0, 0.491418,-99) , 
2, -2.54319, 1, 0, 0.495531,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.0323177);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513457,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485151,-99) , 
1, 156.957, 1, 0, 0.508261,-99) , 
NN(
0, 
0, 
-1, 233.358, 1, -1, 0.47834,-99) , 
1, 182.424, 1, 0, 0.502409,-99) , 
NN(
0, 
0, 
-1, 62.5684, 0, -1, 0.479574,-99) , 
0, 84.4247, 0, 0, 0.498487,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.024282);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534969,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496628,-99) , 
1, 124.943, 1, 0, 0.510367,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541623,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495333,-99) , 
1, 213.601, 0, 0, 0.49978,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.445817,-99) , 
0, 137.503, 1, 0, 0.495676,-99) , 
0, 149.992, 0, 0, 0.497776,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.0243888);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -2.71419, 1, 1, 0.513907,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478664,-99) , 
0, 81.9941, 0, 0, 0.508293,-99) , 
NN(
NN(
0, 
0, 
-1, 193.189, 0, 1, 0.505056,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501467,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.439885,-99) , 
3, 89.6424, 1, 0, 0.474952,-99) , 
2, 1.00446, 0, 0, 0.498018,-99) , 
2, -1.3464, 1, 0, 0.502301,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.0300689);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515119,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494821,-99) , 
2, -2.44346, 1, 0, 0.50704,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487687,-99) , 
0, 81.9941, 0, 0, 0.503997,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510867,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469611,-99) , 
0, 84.9637, 0, 0, 0.503043,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500601,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.40479,-99) , 
3, 134.398, 1, 0, 0.478243,-99) , 
2, 2.14426, 0, 0, 0.492842,-99) , 
2, -1.0472, 1, 0, 0.497729,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.0297901);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519132,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519629,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49324,-99) , 
2, -2.244, 0, 0, 0.501327,-99) , 
3, 182.568, 0, 0, 0.503888,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518118,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491264,-99) , 
3, 155.34, 0, 0, 0.498377,-99) , 
NN(
0, 
0, 
-1, 134.398, 1, -1, 0.474217,-99) , 
2, 2.14426, 0, 0, 0.48844,-99) , 
2, -1.0472, 1, 0, 0.495209,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.0188924);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516617,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508125,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492187,-99) , 
0, 120.816, 1, 0, 0.502286,-99) , 
2, -2.94213, 1, 0, 0.505287,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50949,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496857,-99) , 
0, 84.4247, 1, 0, 0.498992,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463278,-99) , 
3, 179.153, 1, 0, 0.493562,-99) , 
2, -1.0472, 1, 0, 0.4987,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.0297863);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511756,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496765,-99) , 
1, 112.875, 0, 0, 0.507569,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504918,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467538,-99) , 
0, 125.065, 1, 0, 0.492422,-99) , 
3, 58.655, 0, 0, 0.503175,-99) , 
NN(
NN(
0, 
0, 
-1, -2.84253, 1, 1, 0.514023,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507372,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.431298,-99) , 
2, 1.85932, 0, 0, 0.48001,-99) , 
2, -2.24399, 1, 0, 0.492182,-99) , 
3, 136.687, 1, 0, 0.499722,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.0220325);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506616,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493686,-99) , 
0, 84.7518, 0, 0, 0.504284,-99) , 
NN(
0, 
0, 
-1, 125.065, 1, -1, 0.48995,-99) , 
3, 58.655, 0, 0, 0.500127,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512939,-99) , 
NN(
0, 
0, 
-1, 181.271, 1, -1, 0.479518,-99) , 
3, 214.719, 0, 0, 0.488167,-99) , 
3, 136.687, 1, 0, 0.49637,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.0185941);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527368,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495838,-99) , 
3, 104.257, 0, 0, 0.508883,-99) , 
NN(
0, 
0, 
-1, 171.33, 1, -1, 0.49634,-99) , 
1, 182.424, 0, 0, 0.498764,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520921,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463171,-99) , 
2, 2.24399, 0, 0, 0.483635,-99) , 
3, 182.206, 1, 0, 0.496585,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.0187612);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508426,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498449,-99) , 
2, 2.32948, 1, 0, 0.504707,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500995,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49335,-99) , 
2, -2.97063, 1, 0, 0.495826,-99) , 
2, -2.54319, 0, 0, 0.502669,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522146,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462494,-99) , 
2, -1.94479, 1, 0, 0.48498,-99) , 
3, 182.206, 1, 0, 0.500123,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.0149891);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 147.522, 0, 1, 0.503463,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492831,-99) , 
2, -2.84239, 0, 0, 0.502129,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519053,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465122,-99) , 
2, 1.94479, 0, 0, 0.486126,-99) , 
3, 182.206, 1, 0, 0.499826,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.0247474);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517747,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476985,-99) , 
0, 176.813, 1, 0, 0.507226,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503456,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483634,-99) , 
3, 115.95, 1, 0, 0.495156,-99) , 
0, 127.614, 0, 0, 0.498682,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479397,-99) , 
1, 241.847, 1, 0, 0.497542,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.0219455);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529817,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498016,-99) , 
1, 124.943, 1, 0, 0.509388,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52857,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495259,-99) , 
1, 213.601, 0, 0, 0.498455,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443285,-99) , 
0, 137.503, 1, 0, 0.494255,-99) , 
0, 149.992, 0, 0, 0.496414,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.017965);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529335,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515878,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490112,-99) , 
1, 144.937, 0, 0, 0.500417,-99) , 
3, 156.529, 0, 0, 0.508619,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51714,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49873,-99) , 
0, 81.667, 1, 0, 0.501423,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475269,-99) , 
3, 182.206, 1, 0, 0.49794,-99) , 
2, 2.54319, 0, 0, 0.500507,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.0191158);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 117.189, 0, 1, 0.514857,-99) , 
NN(
NN(
0, 
0, 
-1, 147.522, 0, 1, 0.504245,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518212,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44367,-99) , 
2, 1.71684, 0, 0, 0.480881,-99) , 
3, 182.206, 1, 0, 0.501066,-99) , 
2, -2.84239, 1, 0, 0.502902,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.0190721);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530479,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512699,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49416,-99) , 
3, 121.9, 0, 0, 0.500236,-99) , 
3, 182.568, 0, 0, 0.504704,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503523,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494796,-99) , 
3, 85.3799, 0, 0, 0.499394,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468572,-99) , 
3, 179.153, 1, 0, 0.494823,-99) , 
2, -1.6456, 1, 0, 0.498688,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.015103);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525726,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504831,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486654,-99) , 
0, 81.9941, 0, 0, 0.501879,-99) , 
3, 182.568, 0, 0, 0.505401,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50657,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497647,-99) , 
0, 84.4247, 1, 0, 0.499138,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473324,-99) , 
3, 179.153, 1, 0, 0.495311,-99) , 
2, -1.6456, 1, 0, 0.499258,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.0198381);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 124.943, 1, 1, 0.511643,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504407,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472323,-99) , 
0, 64.055, 0, 0, 0.501869,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449255,-99) , 
0, 137.503, 1, 0, 0.497868,-99) , 
0, 149.992, 0, 0, 0.499834,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.0121786);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519584,-99) , 
NN(
0, 
0, 
-1, 181.992, 1, -1, 0.495844,-99) , 
3, 227.724, 0, 0, 0.497281,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477948,-99) , 
1, 241.847, 1, 0, 0.496142,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.0180934);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516855,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482832,-99) , 
0, 176.813, 1, 0, 0.508071,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501033,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484155,-99) , 
0, 86.1825, 0, 0, 0.496613,-99) , 
0, 127.614, 0, 0, 0.499957,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480988,-99) , 
1, 241.847, 1, 0, 0.49884,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.0217815);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 124.943, 1, 1, 0.510161,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522979,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494382,-99) , 
0, 75.3545, 1, 0, 0.498357,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452765,-99) , 
0, 137.503, 1, 0, 0.494892,-99) , 
0, 149.992, 0, 0, 0.497069,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.0167373);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519578,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497358,-99) , 
2, 2.71418, 0, 0, 0.510611,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479862,-99) , 
0, 84.9637, 0, 0, 0.504767,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512961,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498251,-99) , 
0, 81.667, 1, 0, 0.500359,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478974,-99) , 
3, 182.206, 1, 0, 0.497481,-99) , 
2, 2.24399, 0, 0, 0.499762,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.0148071);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517961,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505819,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492642,-99) , 
3, 52.5736, 0, 0, 0.503626,-99) , 
3, 182.568, 0, 0, 0.50568,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505563,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497635,-99) , 
3, 110.954, 1, 0, 0.502823,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47796,-99) , 
3, 179.153, 1, 0, 0.499072,-99) , 
2, -1.0472, 1, 0, 0.501968,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.0090816);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 227.724, 0, 1, 0.503,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485409,-99) , 
1, 196.57, 1, 0, 0.501354,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488177,-99) , 
1, 241.847, 1, 0, 0.500577,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.0152271);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513673,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492436,-99) , 
3, 78.2817, 0, 0, 0.50839,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482523,-99) , 
0, 84.9637, 0, 0, 0.503474,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50931,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498102,-99) , 
3, 147.522, 0, 0, 0.499497,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480358,-99) , 
3, 182.206, 1, 0, 0.496924,-99) , 
2, 2.24399, 0, 0, 0.498974,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.0153127);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520885,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50399,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489289,-99) , 
1, 186.616, 1, 0, 0.501434,-99) , 
0, 84.9121, 1, 0, 0.504616,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520705,-99) , 
NN(
0, 
0, 
-1, 179.412, 1, -1, 0.494479,-99) , 
3, 214.719, 0, 0, 0.498076,-99) , 
3, 91.1689, 1, 0, 0.500767,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.0134526);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 155.999, 0, 1, 0.51082,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50757,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489938,-99) , 
0, 120.816, 1, 0, 0.501096,-99) , 
2, -2.74266, 1, 0, 0.504917,-99) , 
NN(
NN(
0, 
0, 
-1, 145.053, 0, 1, 0.501818,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479483,-99) , 
3, 179.153, 1, 0, 0.49845,-99) , 
2, -1.0472, 1, 0, 0.501285,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.014353);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -2.74266, 1, 1, 0.505257,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491233,-99) , 
0, 81.9941, 0, 0, 0.503053,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521829,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496469,-99) , 
3, 193.189, 0, 0, 0.499531,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480015,-99) , 
2, 0.748008, 0, 0, 0.496101,-99) , 
2, -1.0472, 1, 0, 0.499149,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.0151537);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512517,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493871,-99) , 
3, 78.2817, 0, 0, 0.507877,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487576,-99) , 
0, 84.9637, 0, 0, 0.504021,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504423,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496436,-99) , 
2, -1.85931, 0, 0, 0.500219,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481525,-99) , 
3, 182.206, 1, 0, 0.497708,-99) , 
2, 2.24399, 0, 0, 0.499684,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.0128159);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521692,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507903,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49645,-99) , 
1, 150.375, 0, 0, 0.500755,-99) , 
3, 182.568, 0, 0, 0.50384,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510516,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498499,-99) , 
0, 84.4247, 1, 0, 0.500504,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479237,-99) , 
3, 179.153, 1, 0, 0.497361,-99) , 
2, -1.6456, 1, 0, 0.499895,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.0171142);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.71418, 0, 1, 0.509179,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489256,-99) , 
0, 84.9637, 0, 0, 0.505394,-99) , 
NN(
NN(
0, 
0, 
-1, 137.226, 0, 1, 0.506725,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502396,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469488,-99) , 
3, 134.398, 1, 0, 0.494523,-99) , 
2, -2.37222, 1, 0, 0.499538,-99) , 
2, 2.24399, 0, 0, 0.501372,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.013003);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512049,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512369,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49488,-99) , 
2, 2.5432, 1, 0, 0.499318,-99) , 
3, 155.34, 0, 0, 0.502741,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511736,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498451,-99) , 
3, 182.568, 0, 0, 0.500356,-99) , 
NN(
0, 
0, 
-1, 134.398, 1, -1, 0.489724,-99) , 
2, -1.08994, 1, 0, 0.496465,-99) , 
2, 2.24399, 0, 0, 0.49843,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.0122407);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518721,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499046,-99) , 
1, 124.943, 1, 0, 0.506069,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530065,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499817,-99) , 
1, 213.601, 0, 0, 0.502715,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459036,-99) , 
0, 137.503, 1, 0, 0.499399,-99) , 
0, 149.992, 0, 0, 0.50035,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.010773);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 227.724, 0, 1, 0.504539,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48551,-99) , 
1, 207.888, 1, 0, 0.503376,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490787,-99) , 
1, 241.847, 1, 0, 0.502634,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.017156);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 112.916, 0, 1, 0.511492,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502096,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462485,-99) , 
0, 171.33, 1, 0, 0.49895,-99) , 
1, 182.424, 0, 0, 0.501372,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524113,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477803,-99) , 
1, 115.628, 1, 0, 0.495748,-99) , 
3, 182.206, 1, 0, 0.500568,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.0165135);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516014,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498953,-99) , 
2, -1.6456, 1, 0, 0.505167,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526979,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496579,-99) , 
1, 213.601, 0, 0, 0.49949,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456509,-99) , 
0, 137.503, 1, 0, 0.496228,-99) , 
0, 149.992, 0, 0, 0.497501,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.0075031);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 227.724, 0, 1, 0.502448,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483791,-99) , 
1, 207.888, 1, 0, 0.501308,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488845,-99) , 
1, 241.847, 1, 0, 0.500575,-99)    );
   return;
};
 
// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
