// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.06/01       [394753]
Creator        : kskovpen
Date           : Fri Feb  3 15:22:36 2017
Host           : Linux vocms0301.cern.ch 2.6.32-642.11.1.el6.x86_64 #1 SMP Wed Nov 16 09:40:09 CET 2016 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /storage_mnt/storage/user/kskovpen/analysis/tHFCNC/CMSSW_8_0_25/src/TopKinFit/test/Validation/TopTopLepHbb/MVA
Training events: 40092
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
SeparationType: "giniindex" [Separation criterion for node splitting]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
MinNodeSize: "5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "2" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 4
HiggsRecMCSVv2T               HiggsRecMCSVv2T               HiggsRecMCSVv2T               HiggsRecMCSVv2T                                                 'F'    [18.1019706726,1164.46728516]
TopLepRecMCSVv2T              TopLepRecMCSVv2T              TopLepRecMCSVv2T              TopLepRecMCSVv2T                                                'F'    [43.0312232971,1453.359375]
HiggsTopLepRecDrCSVv2T        HiggsTopLepRecDrCSVv2T        HiggsTopLepRecDrCSVv2T        HiggsTopLepRecDrCSVv2T                                          'F'    [0.0304595902562,9.0174369812]
TopLepRecPtCSVv2T             TopLepRecPtCSVv2T             TopLepRecPtCSVv2T             TopLepRecPtCSVv2T                                               'F'    [0.859871923923,861.120666504]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTNode
   
#ifndef BDTNode__def
#define BDTNode__def
   
class BDTNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 4 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "HiggsRecMCSVv2T", "TopLepRecMCSVv2T", "HiggsTopLepRecDrCSVv2T", "TopLepRecPtCSVv2T" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[4];
   double fVmax[4];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[4];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadBDT::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(0.4444101661094);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.654357,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.208221,-99) , 
0, 150.674, 1, 0, 0.623092,-99) , 
NN(
0, 
0, 
-1, 2.5555, 0, -1, 0.283993,-99) , 
1, 244.507, 1, 0, 0.570265,-99) , 
NN(
0, 
0, 
-1, 231.391, 1, -1, 0.0650892,-99) , 
0, 181.868, 1, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.345163);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.599099,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.309878,-99) , 
0, 138.423, 1, 0, 0.550882,-99) , 
NN(
0, 
0, 
-1, 65.631, 0, -1, 0.25885,-99) , 
0, 80.489, 0, 0, 0.508594,-99) , 
NN(
0, 
0, 
-1, 231.391, 1, -1, 0.0979439,-99) , 
0, 181.868, 1, 0, 0.457694,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.290361);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.664173,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46152,-99) , 
3, 150.509, 0, 0, 0.541132,-99) , 
NN(
0, 
0, 
-1, 200.908, 1, -1, 0.342945,-99) , 
2, 2.60184, 0, 0, 0.470942,-99) , 
NN(
0, 
0, 
-1, 2.64298, 0, -1, 0.132951,-99) , 
0, 181.868, 1, 0, 0.432631,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.207702);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.630719,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473344,-99) , 
0, 90.6871, 0, 0, 0.599003,-99) , 
NN(
0, 
0, 
-1, 239.795, 1, -1, 0.44672,-99) , 
2, 3.02954, 0, 0, 0.506664,-99) , 
NN(
0, 
0, 
-1, 2.64298, 0, -1, 0.170123,-99) , 
0, 181.868, 1, 0, 0.471107,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.199221);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.559969,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.370056,-99) , 
0, 72.6906, 0, 0, 0.542701,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.280169,-99) , 
1, 311.665, 1, 0, 0.526291,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.201482,-99) , 
0, 181.868, 1, 0, 0.493624,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.164666);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549137,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457048,-99) , 
1, 197.897, 1, 0, 0.519825,-99) , 
NN(
0, 
0, 
-1, 199.118, 1, -1, 0.3803,-99) , 
2, 2.17413, 0, 0, 0.491186,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.235442,-99) , 
0, 181.868, 1, 0, 0.466507,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.133618);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532864,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449814,-99) , 
0, 101.281, 0, 0, 0.50184,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.368614,-99) , 
0, 142.876, 1, 0, 0.487628,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.26636,-99) , 
0, 181.868, 1, 0, 0.466928,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.124552);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532076,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.404321,-99) , 
2, 1.74799, 0, 0, 0.518815,-99) , 
NN(
0, 
0, 
-1, 135.078, 1, -1, 0.442482,-99) , 
3, 113.217, 0, 0, 0.483544,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.293271,-99) , 
0, 181.868, 1, 0, 0.466143,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.120344);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.586288,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502493,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.432315,-99) , 
0, 85.6857, 0, 0, 0.486271,-99) , 
2, 3.45725, 0, 0, 0.50244,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.555743,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.389661,-99) , 
3, 163.961, 0, 0, 0.439255,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.244897,-99) , 
1, 246.242, 1, 0, 0.39965,-99) , 
0, 127.28, 1, 0, 0.469766,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.104668);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.597303,-99) , 
NN(
0, 
0, 
-1, 1.68527, 0, -1, 0.463577,-99) , 
2, 3.88496, 0, 0, 0.474195,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.335128,-99) , 
0, 181.868, 1, 0, 0.461949,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.071566);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512939,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.423833,-99) , 
1, 132.569, 0, 0, 0.503739,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.387609,-99) , 
0, 181.868, 1, 0, 0.494877,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.341891,-99) , 
1, 311.665, 1, 0, 0.484219,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.103097);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548754,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530243,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451595,-99) , 
3, 184.744, 0, 0, 0.471075,-99) , 
2, 3.45407, 0, 0, 0.483101,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.358171,-99) , 
1, 311.665, 1, 0, 0.474475,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.0471328);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504099,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.444793,-99) , 
2, 1.74642, 0, 0, 0.497561,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.411914,-99) , 
0, 150.674, 1, 0, 0.491776,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.384838,-99) , 
0, 181.868, 1, 0, 0.482674,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.0469449);
  fForest.push_back( 
NN(
0, 
0, 
-1, 311.665, 1, -1, 0.476545,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.0580724);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51144,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.434537,-99) , 
1, 128.305, 0, 0, 0.504448,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5056,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.353434,-99) , 
2, 2.55866, 0, 0, 0.449525,-99) , 
1, 222.107, 1, 0, 0.495364,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.390966,-99) , 
1, 311.665, 1, 0, 0.488266,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.0412378);
  fForest.push_back( 
NN(
0, 
0, 
-1, 181.868, 1, -1, 0.479393,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.0370082);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505528,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472427,-99) , 
0, 131.688, 1, 0, 0.501111,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437471,-99) , 
0, 150.674, 1, 0, 0.496844,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.411695,-99) , 
0, 181.868, 1, 0, 0.489692,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.0593648);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 3.02612, 1, 1, 0.520668,-99) , 
NN(
0, 
0, 
-1, 111.163, 0, -1, 0.464573,-99) , 
1, 138.971, 0, 0, 0.505634,-99) , 
NN(
0, 
0, 
-1, 181.868, 1, -1, 0.465492,-99) , 
1, 177.348, 1, 0, 0.485231,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.0321626);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537605,-99) , 
NN(
0, 
0, 
-1, 1.50198, 0, -1, 0.491471,-99) , 
2, 3.88496, 0, 0, 0.495113,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.426122,-99) , 
0, 181.868, 1, 0, 0.489368,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.0319813);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507601,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463412,-99) , 
2, 1.31872, 0, 0, 0.50495,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459035,-99) , 
0, 150.674, 1, 0, 0.501884,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.434005,-99) , 
0, 181.868, 1, 0, 0.496243,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.0289821);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503656,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440802,-99) , 
2, 1.40135, 0, 0, 0.499129,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452683,-99) , 
3, 37.997, 0, 0, 0.495666,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.431523,-99) , 
1, 311.665, 1, 0, 0.491372,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.0376191);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53527,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491746,-99) , 
1, 244.507, 0, 0, 0.497962,-99) , 
NN(
0, 
0, 
-1, 113.217, 0, -1, 0.480055,-99) , 
0, 119.481, 1, 0, 0.491299,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.439436,-99) , 
0, 181.868, 1, 0, 0.487001,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.0375886);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508058,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465168,-99) , 
3, 37.997, 0, 0, 0.504979,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510093,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.392969,-99) , 
2, 2.55866, 0, 0, 0.467584,-99) , 
1, 222.107, 1, 0, 0.498861,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438826,-99) , 
1, 311.665, 1, 0, 0.494854,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.0344748);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521742,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517147,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487278,-99) , 
3, 262.49, 0, 0, 0.490254,-99) , 
2, 3.88496, 0, 0, 0.492734,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.445102,-99) , 
0, 181.868, 1, 0, 0.488799,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.0331696);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51139,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466576,-99) , 
0, 135.078, 1, 0, 0.504183,-99) , 
NN(
0, 
0, 
-1, 2.29359, 0, -1, 0.487971,-99) , 
3, 150.509, 1, 0, 0.498412,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453632,-99) , 
0, 181.868, 1, 0, 0.494717,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.048003);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 3.34358, 0, 1, 0.513418,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508748,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.393983,-99) , 
1, 215.959, 1, 0, 0.477528,-99) , 
2, 2.42953, 0, 0, 0.503932,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508502,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466032,-99) , 
2, 3.02975, 1, 0, 0.490951,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.388273,-99) , 
0, 143.962, 1, 0, 0.472489,-99) , 
3, 82.7895, 0, 0, 0.494783,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.0484605);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547856,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488381,-99) , 
0, 127.28, 0, 0, 0.506489,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458726,-99) , 
2, 2.0868, 0, 0, 0.498859,-99) , 
NN(
0, 
0, 
-1, 157.086, 1, -1, 0.477111,-99) , 
3, 123.754, 0, 0, 0.487616,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.0198511);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 244.507, 0, 1, 0.505767,-99) , 
NN(
0, 
0, 
-1, 1.97812, 0, -1, 0.489477,-99) , 
0, 119.481, 1, 0, 0.499715,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463259,-99) , 
0, 181.868, 1, 0, 0.496731,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.0196427);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543055,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49998,-99) , 
2, 3.98405, 0, 0, 0.518114,-99) , 
NN(
0, 
0, 
-1, 181.868, 1, -1, 0.491759,-99) , 
2, 3.45407, 0, 0, 0.495966,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.0373902);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512745,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487762,-99) , 
1, 145.359, 0, 0, 0.50704,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525322,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.442184,-99) , 
2, 2.91842, 0, 0, 0.480283,-99) , 
1, 222.107, 1, 0, 0.50269,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465387,-99) , 
1, 311.665, 1, 0, 0.500216,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.0268848);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521818,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503815,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45616,-99) , 
0, 64.4258, 0, 0, 0.500561,-99) , 
NN(
0, 
0, 
-1, 106.118, 0, -1, 0.447822,-99) , 
0, 157.086, 1, 0, 0.493827,-99) , 
3, 246.649, 0, 0, 0.496982,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.0279518);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522297,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525545,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495276,-99) , 
1, 170.95, 0, 0, 0.499685,-99) , 
NN(
0, 
0, 
-1, 127.28, 1, -1, 0.48122,-99) , 
1, 177.348, 1, 0, 0.490299,-99) , 
3, 287.613, 0, 0, 0.492492,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.0326203);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 172.917, 0, 1, 0.519596,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503106,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450931,-99) , 
1, 239.795, 1, 0, 0.494854,-99) , 
2, 3.11497, 0, 0, 0.50234,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515595,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487985,-99) , 
2, 2.60205, 1, 0, 0.498703,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.427118,-99) , 
0, 143.962, 1, 0, 0.48599,-99) , 
3, 82.7895, 0, 0, 0.497589,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.0213939);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534439,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49786,-99) , 
2, 3.98405, 0, 0, 0.51325,-99) , 
NN(
0, 
0, 
-1, 181.868, 1, -1, 0.490261,-99) , 
2, 3.45407, 0, 0, 0.493933,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.0131244);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 3.98405, 0, 1, 0.514103,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50043,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472039,-99) , 
0, 64.8922, 0, 0, 0.498527,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462695,-99) , 
0, 181.868, 1, 0, 0.495609,-99) , 
2, 3.45407, 0, 0, 0.498563,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.0148565);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525841,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499928,-99) , 
2, 3.98405, 0, 0, 0.510824,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500028,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488452,-99) , 
3, 150.636, 1, 0, 0.495686,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465959,-99) , 
0, 181.868, 1, 0, 0.493266,-99) , 
2, 3.45407, 0, 0, 0.49607,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.0320363);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.554179,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499887,-99) , 
1, 174.606, 1, 0, 0.523261,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52532,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487398,-99) , 
0, 80.4819, 1, 0, 0.493913,-99) , 
0, 127.28, 0, 0, 0.503002,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502722,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475086,-99) , 
0, 123.985, 1, 0, 0.495821,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.444376,-99) , 
0, 157.086, 1, 0, 0.488867,-99) , 
3, 123.754, 0, 0, 0.495701,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.0337367);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542901,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499254,-99) , 
0, 127.28, 0, 0, 0.512525,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477589,-99) , 
2, 2.0868, 0, 0, 0.506979,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51476,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486004,-99) , 
2, 3.45744, 0, 0, 0.491538,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44109,-99) , 
1, 271.373, 1, 0, 0.486476,-99) , 
3, 123.754, 0, 0, 0.496389,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0286608);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528726,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510974,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487702,-99) , 
2, 2.3805, 0, 0, 0.503283,-99) , 
2, 3.11497, 0, 0, 0.511104,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503178,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480973,-99) , 
0, 99.0726, 0, 0, 0.496724,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449423,-99) , 
1, 271.373, 1, 0, 0.491984,-99) , 
3, 123.754, 0, 0, 0.501229,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.0278314);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521579,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510959,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490376,-99) , 
2, 2.67425, 1, 0, 0.500854,-99) , 
2, 3.11497, 0, 0, 0.507223,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513164,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491896,-99) , 
0, 84.2789, 1, 0, 0.495674,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453562,-99) , 
0, 157.086, 1, 0, 0.489999,-99) , 
3, 123.754, 0, 0, 0.498327,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0200247);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 174.207, 0, 1, 0.51195,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507889,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494422,-99) , 
0, 110.75, 0, 0, 0.500849,-99) , 
NN(
0, 
0, 
-1, 2.64298, 1, -1, 0.470758,-99) , 
0, 157.086, 1, 0, 0.49699,-99) , 
3, 205.684, 0, 0, 0.49974,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0270537);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532523,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49351,-99) , 
1, 194.757, 0, 0, 0.506998,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485202,-99) , 
2, 2.0868, 0, 0, 0.503536,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505788,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484358,-99) , 
0, 123.985, 1, 0, 0.500441,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465447,-99) , 
0, 157.086, 1, 0, 0.495733,-99) , 
3, 123.754, 0, 0, 0.499506,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.0277537);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 133.79, 1, 1, 0.517483,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508287,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469014,-99) , 
2, 2.29041, 0, 0, 0.500756,-99) , 
3, 158.872, 1, 0, 0.506368,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506004,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472121,-99) , 
1, 136.912, 0, 0, 0.500877,-99) , 
NN(
0, 
0, 
-1, 114.382, 1, -1, 0.476323,-99) , 
1, 205.707, 1, 0, 0.493709,-99) , 
3, 123.754, 0, 0, 0.499829,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.0231237);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 133.79, 1, 1, 0.51055,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525361,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490443,-99) , 
1, 239.795, 0, 0, 0.496477,-99) , 
3, 158.872, 1, 0, 0.501199,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502559,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463044,-99) , 
0, 143.962, 1, 0, 0.49579,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466916,-99) , 
3, 112.046, 1, 0, 0.492306,-99) , 
3, 123.754, 0, 0, 0.496605,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.0277373);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.71693, 0, 1, 0.509245,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506967,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46187,-99) , 
0, 87.0491, 0, 0, 0.499405,-99) , 
NN(
0, 
0, 
-1, 2.01567, 0, -1, 0.480437,-99) , 
1, 192.834, 1, 0, 0.492426,-99) , 
3, 205.684, 0, 0, 0.495516,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.0304422);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5088,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510816,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489708,-99) , 
3, 150.509, 1, 0, 0.496591,-99) , 
3, 264.209, 0, 0, 0.498913,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531581,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486913,-99) , 
3, 76.3819, 1, 0, 0.495845,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504332,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459985,-99) , 
2, 2.60205, 1, 0, 0.47826,-99) , 
3, 65.2307, 0, 0, 0.489295,-99) , 
3, 123.754, 0, 0, 0.493945,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.0281687);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532372,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518354,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49357,-99) , 
0, 80.4749, 1, 0, 0.496922,-99) , 
0, 181.868, 0, 0, 0.499727,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527606,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469677,-99) , 
3, 73.4905, 1, 0, 0.500763,-99) , 
NN(
0, 
0, 
-1, 51.3739, 1, -1, 0.478703,-99) , 
3, 63.2722, 0, 0, 0.486953,-99) , 
3, 82.7895, 0, 0, 0.496017,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0134078);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525354,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527728,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499306,-99) , 
0, 142.848, 0, 0, 0.502059,-99) , 
0, 181.868, 0, 0, 0.503901,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501958,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486142,-99) , 
2, 3.02975, 1, 0, 0.495428,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471164,-99) , 
0, 143.962, 1, 0, 0.491162,-99) , 
3, 82.7895, 0, 0, 0.500202,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0185673);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 181.868, 0, 1, 0.506126,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506979,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507709,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470844,-99) , 
3, 51.8124, 1, 0, 0.486357,-99) , 
2, 3.45744, 0, 0, 0.491269,-99) , 
3, 82.7895, 0, 0, 0.501812,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0243768);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524092,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525481,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489456,-99) , 
0, 94.3779, 1, 0, 0.499251,-99) , 
0, 130.653, 0, 0, 0.505888,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503937,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48205,-99) , 
3, 63.5782, 0, 0, 0.49823,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470711,-99) , 
1, 262.627, 1, 0, 0.495112,-99) , 
3, 164.719, 0, 0, 0.498359,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.0273128);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527555,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5366,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490317,-99) , 
0, 130.653, 0, 0, 0.501814,-99) , 
1, 239.795, 0, 0, 0.5063,-99) , 
NN(
NN(
0, 
0, 
-1, 71.0066, 0, 1, 0.513373,-99) , 
NN(
0, 
0, 
-1, 150.769, 1, -1, 0.488744,-99) , 
2, 3.45407, 0, 0, 0.493215,-99) , 
3, 164.719, 0, 0, 0.497158,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.0161717);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 194.757, 0, 1, 0.512586,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488799,-99) , 
2, 2.29359, 0, 0, 0.507951,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526427,-99) , 
NN(
0, 
0, 
-1, 267.093, 1, -1, 0.495312,-99) , 
2, 1.31431, 1, 0, 0.497563,-99) , 
3, 164.719, 0, 0, 0.500692,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.0396073);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.557696,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531672,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492066,-99) , 
2, 1.74667, 1, 0, 0.496303,-99) , 
1, 244.507, 0, 0, 0.504781,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.553649,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49658,-99) , 
0, 176.67, 0, 0, 0.511539,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.430656,-99) , 
1, 246.242, 1, 0, 0.496882,-99) , 
0, 127.28, 1, 0, 0.502366,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.0281289);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.64262, 1, 1, 0.517732,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510094,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463251,-99) , 
1, 267.093, 1, 0, 0.505364,-99) , 
3, 164.719, 0, 0, 0.50914,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48922,-99) , 
2, 1.31431, 0, 0, 0.507807,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.0269094);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.91548, 0, 1, 0.532879,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507778,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485488,-99) , 
2, 3.02975, 1, 0, 0.499138,-99) , 
1, 244.507, 0, 0, 0.50391,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487904,-99) , 
0, 181.868, 1, 0, 0.502638,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.02235);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 201.19, 0, 1, 0.510933,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511115,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491441,-99) , 
3, 165.85, 0, 0, 0.497688,-99) , 
2, 3.12803, 0, 0, 0.502332,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514102,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474649,-99) , 
0, 113.138, 1, 0, 0.492075,-99) , 
2, 1.74226, 0, 0, 0.501102,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.0258603);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.552784,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479662,-99) , 
0, 115.468, 1, 0, 0.515065,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513906,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493554,-99) , 
0, 127.28, 0, 0, 0.499353,-99) , 
1, 244.507, 0, 0, 0.501698,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508518,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480225,-99) , 
0, 113.138, 1, 0, 0.492723,-99) , 
2, 1.74226, 0, 0, 0.500622,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.0291862);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536708,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504884,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480285,-99) , 
2, 3.45744, 1, 0, 0.501149,-99) , 
1, 244.507, 0, 0, 0.506041,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541545,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494117,-99) , 
0, 176.67, 0, 0, 0.506504,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.445496,-99) , 
1, 246.242, 1, 0, 0.495502,-99) , 
0, 127.28, 1, 0, 0.502822,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.0188027);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539139,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488887,-99) , 
0, 115.468, 1, 0, 0.513209,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511223,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4952,-99) , 
0, 127.28, 0, 0, 0.499764,-99) , 
1, 244.507, 0, 0, 0.501767,-99) , 
NN(
0, 
0, 
-1, 1.17161, 0, -1, 0.490001,-99) , 
2, 1.74226, 0, 0, 0.500356,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.0252715);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514047,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492141,-99) , 
0, 88.2874, 0, 0, 0.509635,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514737,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487329,-99) , 
0, 90.402, 1, 0, 0.492382,-99) , 
3, 150.509, 1, 0, 0.503493,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49036,-99) , 
0, 181.868, 1, 0, 0.502455,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.016848);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 3.98405, 0, 1, 0.509095,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515409,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496798,-99) , 
3, 165.588, 0, 0, 0.502838,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481733,-99) , 
2, 1.49769, 0, 0, 0.500685,-99) , 
2, 3.45407, 0, 0, 0.502025,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.0219765);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528043,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503229,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478561,-99) , 
0, 70.0855, 0, 0, 0.50076,-99) , 
1, 244.507, 0, 0, 0.50451,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538129,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496999,-99) , 
0, 176.67, 0, 0, 0.507726,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459276,-99) , 
1, 246.242, 1, 0, 0.499011,-99) , 
0, 127.28, 1, 0, 0.502831,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.0289046);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525188,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519921,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490128,-99) , 
0, 130.336, 0, 0, 0.497177,-99) , 
2, 2.17022, 1, 0, 0.502698,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513476,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493397,-99) , 
2, 2.91564, 0, 0, 0.504966,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469888,-99) , 
2, 2.01205, 0, 0, 0.498612,-99) , 
1, 177.348, 1, 0, 0.500634,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.0270621);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52563,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505193,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486211,-99) , 
2, 2.61175, 1, 0, 0.499667,-99) , 
2, 2.88346, 0, 0, 0.504049,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530863,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495622,-99) , 
0, 131.079, 0, 0, 0.504405,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521577,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471452,-99) , 
2, 3.17552, 0, 0, 0.490391,-99) , 
2, 3.31144, 0, 0, 0.497873,-99) , 
2, 3.02612, 1, 0, 0.501648,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.0184261);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522759,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502455,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478584,-99) , 
3, 38.175, 0, 0, 0.500766,-99) , 
0, 72.6908, 1, 0, 0.502695,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531489,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498736,-99) , 
1, 154.498, 1, 0, 0.511336,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456958,-99) , 
1, 199.118, 1, 0, 0.492244,-99) , 
2, 2.17022, 0, 0, 0.500518,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.0160507);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 80.489, 1, 1, 0.504104,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509546,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485162,-99) , 
1, 239.795, 0, 0, 0.48897,-99) , 
3, 150.509, 1, 0, 0.498716,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487376,-99) , 
0, 181.868, 1, 0, 0.497822,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.0196969);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509828,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504807,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489929,-99) , 
1, 156.089, 0, 0, 0.496655,-99) , 
2, 2.17022, 1, 0, 0.49925,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52028,-99) , 
NN(
0, 
0, 
-1, 1.5601, 0, -1, 0.489875,-99) , 
2, 3.59322, 0, 0, 0.494128,-99) , 
1, 177.348, 1, 0, 0.496662,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.0177118);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530058,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499512,-99) , 
2, 1.74408, 1, 0, 0.502787,-99) , 
NN(
0, 
0, 
-1, 156.93, 0, -1, 0.485243,-99) , 
1, 239.795, 1, 0, 0.499965,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527927,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485495,-99) , 
2, 2.60205, 1, 0, 0.503092,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500773,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455992,-99) , 
3, 63.4602, 0, 0, 0.486174,-99) , 
3, 51.5699, 1, 0, 0.493751,-99) , 
3, 82.7895, 0, 0, 0.498161,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.0195149);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 130.336, 0, 1, 0.506266,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503091,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47661,-99) , 
3, 156.93, 0, 0, 0.489668,-99) , 
1, 239.795, 1, 0, 0.503596,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523511,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489921,-99) , 
2, 2.60205, 1, 0, 0.503849,-99) , 
NN(
0, 
0, 
-1, 63.4602, 0, -1, 0.484629,-99) , 
3, 51.5699, 1, 0, 0.493236,-99) , 
3, 82.7895, 0, 0, 0.50059,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.010811);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529293,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495919,-99) , 
0, 115.468, 1, 0, 0.512082,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500223,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490043,-99) , 
2, 2.43516, 0, 0, 0.498317,-99) , 
1, 244.507, 0, 0, 0.500365,-99) , 
NN(
0, 
0, 
-1, 1.17161, 0, -1, 0.485483,-99) , 
2, 1.74226, 0, 0, 0.498581,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.013163);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526599,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498621,-99) , 
0, 115.468, 1, 0, 0.512169,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502411,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494825,-99) , 
3, 74.654, 1, 0, 0.496626,-99) , 
1, 244.507, 0, 0, 0.498938,-99) , 
NN(
0, 
0, 
-1, 1.17161, 0, -1, 0.488184,-99) , 
2, 1.74226, 0, 0, 0.497649,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.0120938);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.74408, 1, 1, 0.503382,-99) , 
NN(
0, 
0, 
-1, 296.032, 0, -1, 0.490955,-99) , 
1, 239.795, 1, 0, 0.501384,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503733,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479126,-99) , 
2, 2.17436, 0, 0, 0.497956,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477394,-99) , 
0, 143.962, 1, 0, 0.494381,-99) , 
3, 82.7895, 0, 0, 0.499352,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.0169079);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518575,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491201,-99) , 
2, 2.91548, 0, 0, 0.504327,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529679,-99) , 
NN(
0, 
0, 
-1, 215.721, 1, -1, 0.494056,-99) , 
0, 181.868, 0, 0, 0.49648,-99) , 
1, 244.507, 0, 0, 0.497664,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.013842);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514429,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49827,-99) , 
3, 165.588, 0, 0, 0.503433,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483718,-99) , 
2, 1.49771, 0, 0, 0.501601,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491212,-99) , 
2, 3.88202, 1, 0, 0.500791,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.0197134);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.93934, 1, 1, 0.507439,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487511,-99) , 
2, 1.59961, 0, 0, 0.504236,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525095,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499851,-99) , 
0, 131.079, 0, 0, 0.506133,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514841,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478027,-99) , 
2, 3.17552, 0, 0, 0.49194,-99) , 
2, 3.31144, 0, 0, 0.499518,-99) , 
2, 3.02612, 1, 0, 0.502402,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.0177264);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 114.851, 1, 1, 0.52132,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503652,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482488,-99) , 
3, 184.625, 1, 0, 0.498632,-99) , 
1, 244.507, 0, 0, 0.501833,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49238,-99) , 
0, 181.868, 1, 0, 0.50109,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.0186999);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514923,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513344,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495106,-99) , 
2, 3.31107, 0, 0, 0.498746,-99) , 
2, 1.74408, 1, 0, 0.500544,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522434,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490029,-99) , 
2, 2.60205, 1, 0, 0.503463,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501085,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462884,-99) , 
3, 63.4602, 0, 0, 0.488648,-99) , 
3, 51.5699, 1, 0, 0.495285,-99) , 
3, 82.7895, 0, 0, 0.499018,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.014206);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.74408, 1, 1, 0.504448,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501292,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483012,-99) , 
1, 296.032, 0, 0, 0.492456,-99) , 
1, 239.795, 1, 0, 0.502521,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517767,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494703,-99) , 
2, 2.60205, 1, 0, 0.504263,-99) , 
NN(
0, 
0, 
-1, 63.4602, 0, -1, 0.487014,-99) , 
3, 51.5699, 1, 0, 0.494741,-99) , 
3, 82.7895, 0, 0, 0.500265,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.00873015);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 115.468, 1, 1, 0.512027,-99) , 
NN(
0, 
0, 
-1, 2.43516, 0, -1, 0.497438,-99) , 
1, 244.507, 0, 0, 0.499606,-99) , 
NN(
0, 
0, 
-1, 1.17161, 0, -1, 0.492724,-99) , 
2, 1.74226, 0, 0, 0.498782,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.0118464);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.88006, 1, 1, 0.50983,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502409,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473693,-99) , 
0, 157.086, 1, 0, 0.499129,-99) , 
3, 205.684, 0, 0, 0.50114,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500096,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488199,-99) , 
2, 1.17161, 0, 0, 0.494907,-99) , 
2, 1.74226, 0, 0, 0.500394,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.0115877);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504565,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502317,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478804,-99) , 
1, 263.974, 1, 0, 0.499765,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501318,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465653,-99) , 
1, 215.959, 1, 0, 0.49206,-99) , 
2, 2.42953, 0, 0, 0.497608,-99) , 
3, 41.8247, 1, 0, 0.498225,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.017833);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511479,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491468,-99) , 
2, 2.91548, 0, 0, 0.501063,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529309,-99) , 
NN(
0, 
0, 
-1, 215.721, 1, -1, 0.492766,-99) , 
0, 181.868, 0, 0, 0.495248,-99) , 
1, 244.507, 0, 0, 0.496124,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.00831498);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51118,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500573,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466084,-99) , 
0, 66.7849, 0, 0, 0.498287,-99) , 
2, 3.33177, 0, 0, 0.499992,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49271,-99) , 
2, 3.88202, 1, 0, 0.499424,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.014712);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505041,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518206,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496784,-99) , 
2, 2.88346, 0, 0, 0.500385,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504161,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486489,-99) , 
2, 3.59674, 0, 0, 0.492293,-99) , 
2, 3.02612, 1, 0, 0.497231,-99) , 
0, 72.6908, 1, 0, 0.49789,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.0112163);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514165,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496891,-99) , 
3, 111.879, 0, 0, 0.506824,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503396,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49563,-99) , 
3, 165.234, 0, 0, 0.498041,-99) , 
2, 3.14837, 0, 0, 0.500095,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491111,-99) , 
2, 3.88202, 1, 0, 0.499394,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.0129562);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507359,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505181,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480196,-99) , 
1, 262.627, 1, 0, 0.50244,-99) , 
NN(
0, 
0, 
-1, 2.29041, 0, -1, 0.49433,-99) , 
3, 158.868, 1, 0, 0.499583,-99) , 
3, 41.8247, 1, 0, 0.500273,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.0119746);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522208,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49963,-99) , 
2, 3.33177, 0, 0, 0.502383,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508759,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483318,-99) , 
3, 52.174, 1, 0, 0.494218,-99) , 
3, 83.3654, 0, 0, 0.500147,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492285,-99) , 
2, 3.88202, 1, 0, 0.499533,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.0173953);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505744,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477378,-99) , 
0, 64.8922, 0, 0, 0.503849,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484722,-99) , 
0, 181.868, 1, 0, 0.502335,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513379,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484122,-99) , 
2, 3.98405, 0, 0, 0.496398,-99) , 
2, 3.45407, 1, 0, 0.501391,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.0121982);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509599,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497428,-99) , 
3, 123.754, 1, 0, 0.503591,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530428,-99) , 
NN(
0, 
0, 
-1, 215.721, 1, -1, 0.495679,-99) , 
0, 181.868, 0, 0, 0.498037,-99) , 
1, 244.507, 0, 0, 0.498874,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.013501);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515647,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505785,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496638,-99) , 
3, 156.918, 0, 0, 0.500956,-99) , 
2, 1.74408, 1, 0, 0.502589,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505289,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48483,-99) , 
2, 2.17436, 0, 0, 0.500488,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483144,-99) , 
0, 143.962, 1, 0, 0.497477,-99) , 
3, 82.7895, 0, 0, 0.501106,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.0102378);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.74408, 1, 1, 0.504523,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493259,-99) , 
3, 231.044, 1, 0, 0.502381,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503263,-99) , 
NN(
0, 
0, 
-1, 157.802, 0, -1, 0.493348,-99) , 
0, 102.009, 1, 0, 0.496583,-99) , 
3, 82.7895, 0, 0, 0.5007,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.0100594);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 3.33177, 0, 1, 0.50272,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505636,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485834,-99) , 
3, 52.174, 1, 0, 0.494318,-99) , 
3, 83.3654, 0, 0, 0.500419,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492886,-99) , 
2, 3.88202, 1, 0, 0.499831,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.010882);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503275,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513053,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499052,-99) , 
2, 2.88346, 0, 0, 0.501405,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503718,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487224,-99) , 
2, 3.59674, 0, 0, 0.49264,-99) , 
2, 3.02612, 1, 0, 0.49799,-99) , 
0, 72.6908, 1, 0, 0.498435,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.01683);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.35355, 0, 1, 0.511627,-99) , 
NN(
0, 
0, 
-1, 85.4836, 0, -1, 0.486925,-99) , 
0, 106.546, 0, 0, 0.50246,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521164,-99) , 
NN(
0, 
0, 
-1, 263.974, 1, -1, 0.49532,-99) , 
0, 76.2416, 1, 0, 0.497952,-99) , 
2, 2.59817, 1, 0, 0.499548,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.0115133);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.88006, 1, 1, 0.510322,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502552,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479895,-99) , 
0, 157.086, 1, 0, 0.499965,-99) , 
3, 205.684, 0, 0, 0.501912,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503581,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490208,-99) , 
2, 1.25312, 1, 0, 0.497036,-99) , 
2, 1.74226, 0, 0, 0.501328,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.0089763);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511832,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494751,-99) , 
1, 201.19, 1, 0, 0.506588,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500257,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493986,-99) , 
2, 2.70291, 1, 0, 0.497584,-99) , 
2, 3.14837, 0, 0, 0.49969,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494129,-99) , 
2, 3.88202, 1, 0, 0.499257,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.0068826);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 115.468, 1, 1, 0.509389,-99) , 
NN(
0, 
0, 
-1, 72.6908, 0, -1, 0.497886,-99) , 
1, 244.507, 0, 0, 0.499592,-99) , 
NN(
0, 
0, 
-1, 1.17161, 0, -1, 0.494731,-99) , 
2, 1.74226, 0, 0, 0.499011,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.0133102);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.88006, 1, 1, 0.50889,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508299,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494447,-99) , 
3, 78.8841, 1, 0, 0.498931,-99) , 
3, 205.684, 0, 0, 0.500803,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501141,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490395,-99) , 
2, 1.17161, 0, 0, 0.496452,-99) , 
2, 1.74226, 0, 0, 0.500282,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.0193321);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507642,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476049,-99) , 
1, 265.819, 1, 0, 0.504104,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492747,-99) , 
3, 231.044, 1, 0, 0.501945,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513349,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487376,-99) , 
3, 72.3762, 1, 0, 0.503331,-99) , 
NN(
0, 
0, 
-1, 42.4659, 1, -1, 0.490716,-99) , 
3, 55.4707, 0, 0, 0.497029,-99) , 
3, 82.7895, 0, 0, 0.50052,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.0104961);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509671,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49744,-99) , 
2, 2.91548, 0, 0, 0.503304,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529551,-99) , 
NN(
0, 
0, 
-1, 215.721, 1, -1, 0.496659,-99) , 
0, 181.868, 0, 0, 0.498891,-99) , 
1, 244.507, 0, 0, 0.499555,-99)    );
   return;
};
 
// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
