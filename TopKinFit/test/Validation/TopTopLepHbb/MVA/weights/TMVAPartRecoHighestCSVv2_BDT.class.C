// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.06/01       [394753]
Creator        : kskovpen
Date           : Fri Feb  3 16:00:19 2017
Host           : Linux vocms0301.cern.ch 2.6.32-642.11.1.el6.x86_64 #1 SMP Wed Nov 16 09:40:09 CET 2016 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /storage_mnt/storage/user/kskovpen/analysis/tHFCNC/CMSSW_8_0_25/src/TopKinFit/test/Validation/TopTopLepHbb/MVA
Training events: 393872
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
SeparationType: "giniindex" [Separation criterion for node splitting]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
MinNodeSize: "5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "2" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 4
HiggsRecMHighestCSVv2         HiggsRecMHighestCSVv2         HiggsRecMHighestCSVv2         HiggsRecMHighestCSVv2                                           'F'    [15.6451101303,2286.52832031]
TopLepRecMTHighestCSVv2       TopLepRecMTHighestCSVv2       TopLepRecMTHighestCSVv2       TopLepRecMTHighestCSVv2                                         'F'    [4.11086702347,1348.52087402]
HiggsTopLepRecDphiTHighestCSVv2 HiggsTopLepRecDphiTHighestCSVv2 HiggsTopLepRecDphiTHighestCSVv2 HiggsTopLepRecDphiTHighestCSVv2                                     'F'    [-3.14157414436,3.14157438278]
TopLepRecPtTHighestCSVv2      TopLepRecPtTHighestCSVv2      TopLepRecPtTHighestCSVv2      TopLepRecPtTHighestCSVv2                                        'F'    [0.132021471858,1259.89562988]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTNode
   
#ifndef BDTNode__def
#define BDTNode__def
   
class BDTNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 4 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "HiggsRecMHighestCSVv2", "TopLepRecMTHighestCSVv2", "HiggsTopLepRecDphiTHighestCSVv2", "TopLepRecPtTHighestCSVv2" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[4];
   double fVmax[4];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[4];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadBDT::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(0.41943666658404);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.659445,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.355702,-99) , 
0, 85.7744, 0, 0, 0.593997,-99) , 
NN(
0, 
0, 
-1, 120.24, 0, -1, 0.171104,-99) , 
0, 149.528, 1, 0, 0.535097,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0932962,-99) , 
0, 231.92, 1, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.248234);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -2.24398, 1, 1, 0.678835,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51922,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.399958,-99) , 
0, 114.045, 1, 0, 0.461606,-99) , 
3, 172.186, 0, 0, 0.52159,-99) , 
NN(
0, 
0, 
-1, 251.044, 1, -1, 0.228422,-99) , 
1, 196.169, 1, 0, 0.472618,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.246214);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.591419,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.430837,-99) , 
0, 98.0347, 0, 0, 0.530084,-99) , 
NN(
0, 
0, 
-1, 165.713, 1, -1, 0.295734,-99) , 
0, 139.23, 1, 0, 0.489707,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.149488,-99) , 
0, 231.92, 1, 0, 0.466465,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.197507);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -2.24398, 1, 1, 0.620354,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539719,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.436634,-99) , 
3, 131.22, 0, 0, 0.460014,-99) , 
3, 172.186, 0, 0, 0.503523,-99) , 
NN(
0, 
0, 
-1, 109.89, 1, -1, 0.284139,-99) , 
1, 196.169, 1, 0, 0.468395,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.168377);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543994,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.386964,-99) , 
1, 196.295, 1, 0, 0.522199,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.284373,-99) , 
0, 159.827, 1, 0, 0.500582,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.191649,-99) , 
0, 231.92, 1, 0, 0.481154,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.142595);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.576091,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463256,-99) , 
2, -2.54318, 1, 0, 0.490182,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.289798,-99) , 
0, 170.126, 1, 0, 0.47655,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.219094,-99) , 
0, 231.92, 1, 0, 0.46098,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.151822);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 172.299, 0, 1, 0.595139,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522566,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.421057,-99) , 
2, -2.05877, 1, 0, 0.465288,-99) , 
2, 2.54318, 0, 0, 0.496278,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.244464,-99) , 
0, 231.92, 1, 0, 0.48151,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.105799);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 172.299, 0, 1, 0.554053,-99) , 
NN(
0, 
0, 
-1, 186.761, 1, -1, 0.462898,-99) , 
2, 2.24398, 0, 0, 0.490615,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.256109,-99) , 
1, 260.189, 1, 0, 0.478464,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.111212);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528113,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.373255,-99) , 
0, 67.1383, 0, 0, 0.513768,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.332541,-99) , 
0, 170.126, 1, 0, 0.50183,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.284639,-99) , 
0, 231.92, 1, 0, 0.489595,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.0899761);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.571798,-99) , 
NN(
0, 
0, 
-1, 209.741, 1, -1, 0.470707,-99) , 
3, 229.538, 0, 0, 0.483794,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.268464,-99) , 
1, 260.189, 1, 0, 0.472771,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.10856);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540935,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.42613,-99) , 
0, 72.2882, 0, 0, 0.523374,-99) , 
NN(
0, 
0, 
-1, 174.828, 1, -1, 0.455083,-99) , 
0, 123.782, 1, 0, 0.500454,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.286498,-99) , 
1, 260.189, 1, 0, 0.489686,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.0532981);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.558256,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493399,-99) , 
2, 2.84238, 0, 0, 0.502429,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.399288,-99) , 
0, 170.126, 1, 0, 0.49586,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.345106,-99) , 
0, 231.92, 1, 0, 0.487747,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.0630395);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517626,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.430231,-99) , 
0, 59.7821, 0, 0, 0.51205,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.412138,-99) , 
0, 170.126, 1, 0, 0.505714,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.35725,-99) , 
0, 231.92, 1, 0, 0.497779,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.0736169);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519878,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471462,-99) , 
1, 103.406, 0, 0, 0.505949,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.421533,-99) , 
1, 177.878, 1, 0, 0.499374,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513955,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.34042,-99) , 
0, 109.89, 1, 0, 0.418057,-99) , 
1, 196.169, 1, 0, 0.487357,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.0708363);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -2.24398, 1, 1, 0.526376,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510596,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457323,-99) , 
0, 114.045, 0, 0, 0.481716,-99) , 
3, 172.186, 0, 0, 0.493591,-99) , 
NN(
0, 
0, 
-1, 251.044, 1, -1, 0.419433,-99) , 
1, 196.169, 1, 0, 0.482679,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.0603483);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518508,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484265,-99) , 
0, 109.805, 0, 0, 0.498529,-99) , 
NN(
0, 
0, 
-1, 120.24, 0, -1, 0.437035,-99) , 
0, 139.23, 1, 0, 0.488818,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.363281,-99) , 
0, 231.92, 1, 0, 0.482158,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.0464384);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524841,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497227,-99) , 
0, 112.747, 0, 0, 0.505278,-99) , 
NN(
0, 
0, 
-1, 176.604, 1, -1, 0.455843,-99) , 
0, 128.931, 1, 0, 0.493309,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.377352,-99) , 
0, 231.92, 1, 0, 0.487197,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.0510766);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538104,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472766,-99) , 
0, 58.8014, 0, 0, 0.526756,-99) , 
NN(
0, 
0, 
-1, 194.228, 1, -1, 0.486739,-99) , 
0, 98.0348, 1, 0, 0.499787,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.388323,-99) , 
0, 231.92, 1, 0, 0.493939,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.0594361);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547057,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524808,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479276,-99) , 
2, 1.71683, 0, 0, 0.499195,-99) , 
2, -2.84238, 1, 0, 0.50568,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.400522,-99) , 
0, 231.92, 1, 0, 0.500187,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.042611);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -1.34639, 1, 1, 0.513258,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50799,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.389051,-99) , 
1, 176.604, 1, 0, 0.480223,-99) , 
0, 128.931, 1, 0, 0.505281,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.414874,-99) , 
0, 231.92, 1, 0, 0.500579,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.0558998);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.570061,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543707,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.432897,-99) , 
2, 1.78806, 0, 0, 0.499377,-99) , 
2, -2.54317, 1, 0, 0.521171,-99) , 
NN(
NN(
0, 
0, 
-1, 86.9088, 0, -1, 0.491882,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507652,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.362308,-99) , 
0, 109.89, 1, 0, 0.431014,-99) , 
1, 195.356, 1, 0, 0.482879,-99) , 
3, 180.098, 0, 0, 0.492167,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.0525805);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517357,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477107,-99) , 
1, 74.6626, 0, 0, 0.513019,-99) , 
NN(
0, 
0, 
-1, 180.491, 1, -1, 0.47006,-99) , 
1, 168.732, 1, 0, 0.507407,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516519,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.351033,-99) , 
1, 251.044, 1, 0, 0.454662,-99) , 
1, 196.169, 1, 0, 0.499756,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.0422444);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527614,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483726,-99) , 
3, 91.4854, 0, 0, 0.513757,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500273,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468361,-99) , 
2, 1.43189, 0, 0, 0.490563,-99) , 
2, -1.34639, 1, 0, 0.500162,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50338,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.363103,-99) , 
1, 251.044, 1, 0, 0.451175,-99) , 
1, 196.169, 1, 0, 0.49307,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.0383412);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517946,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495418,-99) , 
0, 102.555, 0, 0, 0.509528,-99) , 
NN(
0, 
0, 
-1, 114.835, 1, -1, 0.485771,-99) , 
2, -1.04719, 1, 0, 0.496126,-99) , 
NN(
0, 
0, 
-1, 251.044, 1, -1, 0.44836,-99) , 
1, 196.169, 1, 0, 0.48922,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.0280988);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522427,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49844,-99) , 
0, 85.7741, 1, 0, 0.504653,-99) , 
NN(
0, 
0, 
-1, 176.604, 1, -1, 0.476301,-99) , 
0, 128.931, 1, 0, 0.497834,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.429653,-99) , 
0, 231.92, 1, 0, 0.494324,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.0450061);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521011,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489771,-99) , 
3, 137.125, 1, 0, 0.510112,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523823,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480938,-99) , 
3, 172.21, 0, 0, 0.495616,-99) , 
1, 113.858, 0, 0, 0.504919,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506521,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.385799,-99) , 
1, 251.044, 1, 0, 0.461959,-99) , 
1, 196.169, 1, 0, 0.498726,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.0315581);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518088,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49979,-99) , 
1, 122.568, 0, 0, 0.507967,-99) , 
NN(
0, 
0, 
-1, 180.491, 1, -1, 0.487873,-99) , 
1, 159.586, 1, 0, 0.504012,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516428,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.409849,-99) , 
0, 109.89, 1, 0, 0.458929,-99) , 
1, 196.169, 1, 0, 0.49752,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.0341153);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523272,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492604,-99) , 
3, 91.4854, 0, 0, 0.513586,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521953,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496659,-99) , 
2, 2.92786, 0, 0, 0.501051,-99) , 
2, -1.34639, 1, 0, 0.506239,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510267,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.41013,-99) , 
3, 120.306, 0, 0, 0.45948,-99) , 
1, 196.169, 1, 0, 0.499515,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.0302615);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511292,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494221,-99) , 
1, 70.3075, 0, 0, 0.50985,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488537,-99) , 
1, 177.878, 1, 0, 0.508205,-99) , 
NN(
0, 
0, 
-1, 251.044, 1, -1, 0.459533,-99) , 
1, 196.169, 1, 0, 0.501213,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.0399073);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511534,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479231,-99) , 
0, 74.9851, 0, 0, 0.50636,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533749,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467733,-99) , 
3, 180.222, 0, 0, 0.484079,-99) , 
0, 128.931, 1, 0, 0.501008,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.439023,-99) , 
0, 231.92, 1, 0, 0.49783,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.0384467);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511201,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486622,-99) , 
3, 137.125, 1, 0, 0.502107,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516767,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449334,-99) , 
3, 114.954, 0, 0, 0.491454,-99) , 
2, 2.54318, 1, 0, 0.499566,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501805,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.401276,-99) , 
1, 251.044, 1, 0, 0.464936,-99) , 
1, 196.169, 1, 0, 0.494598,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.0275751);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51171,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496858,-99) , 
2, 1.73104, 0, 0, 0.499608,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507161,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458864,-99) , 
3, 114.954, 0, 0, 0.489046,-99) , 
2, 2.54318, 1, 0, 0.497091,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509293,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.421876,-99) , 
0, 109.89, 1, 0, 0.462321,-99) , 
1, 196.169, 1, 0, 0.492105,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.0227429);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -2.87087, 1, 1, 0.503949,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500268,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465718,-99) , 
3, 114.954, 0, 0, 0.487317,-99) , 
2, 2.54318, 1, 0, 0.499986,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505679,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.420873,-99) , 
3, 120.306, 0, 0, 0.462788,-99) , 
1, 196.169, 1, 0, 0.494658,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.0311672);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517276,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489872,-99) , 
3, 137.148, 0, 0, 0.501451,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501615,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479394,-99) , 
3, 114.835, 1, 0, 0.490568,-99) , 
2, -1.04719, 1, 0, 0.495316,-99) , 
NN(
0, 
0, 
-1, 251.044, 1, -1, 0.462817,-99) , 
1, 196.169, 1, 0, 0.490664,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.0269262);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519881,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496907,-99) , 
3, 182.811, 0, 0, 0.50262,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50754,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483749,-99) , 
0, 87.7345, 1, 0, 0.488801,-99) , 
2, -1.34639, 1, 0, 0.494521,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449201,-99) , 
0, 231.92, 1, 0, 0.492205,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.0195);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510773,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495745,-99) , 
3, 91.4854, 0, 0, 0.506004,-99) , 
NN(
0, 
0, 
-1, 197.546, 1, -1, 0.492671,-99) , 
2, -1.34639, 1, 0, 0.498191,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455872,-99) , 
0, 231.92, 1, 0, 0.49603,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.033868);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516396,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493959,-99) , 
0, 114.045, 0, 0, 0.504202,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532632,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479616,-99) , 
0, 127.373, 0, 0, 0.495482,-99) , 
3, 172.186, 1, 0, 0.501884,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507409,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.423086,-99) , 
1, 251.044, 1, 0, 0.47671,-99) , 
1, 196.169, 1, 0, 0.498289,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.0233338);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 85.7741, 1, 1, 0.505932,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51041,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466696,-99) , 
3, 120.24, 0, 0, 0.487954,-99) , 
0, 128.931, 1, 0, 0.501621,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454183,-99) , 
0, 231.92, 1, 0, 0.499198,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0284396);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505984,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48442,-99) , 
2, 2.54318, 1, 0, 0.501454,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52047,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482245,-99) , 
0, 127.373, 0, 0, 0.49368,-99) , 
3, 172.186, 1, 0, 0.499388,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505644,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.436752,-99) , 
3, 120.306, 0, 0, 0.470901,-99) , 
1, 196.169, 1, 0, 0.495323,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.0168572);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507701,-99) , 
NN(
0, 
0, 
-1, 172.186, 1, -1, 0.495435,-99) , 
2, 2.84238, 0, 0, 0.497119,-99) , 
NN(
0, 
0, 
-1, 251.044, 1, -1, 0.470934,-99) , 
1, 196.169, 1, 0, 0.493385,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.011733);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 229.538, 0, 1, 0.501746,-99) , 
NN(
0, 
0, 
-1, 137.237, 1, -1, 0.493771,-99) , 
1, 159.586, 1, 0, 0.500176,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500374,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.430862,-99) , 
1, 251.044, 1, 0, 0.475136,-99) , 
1, 196.169, 1, 0, 0.496607,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0245585);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518774,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502055,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471154,-99) , 
0, 135.8, 1, 0, 0.496993,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.414961,-99) , 
0, 209.741, 1, 0, 0.491805,-99) , 
3, 240.087, 0, 0, 0.494967,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.018983);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500113,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500182,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486876,-99) , 
3, 114.835, 1, 0, 0.493635,-99) , 
2, -2.84238, 1, 0, 0.494518,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503778,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.442574,-99) , 
0, 109.89, 1, 0, 0.47104,-99) , 
1, 196.169, 1, 0, 0.491174,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.025854);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515071,-99) , 
NN(
0, 
0, 
-1, 209.741, 1, -1, 0.487361,-99) , 
3, 240.087, 0, 0, 0.490609,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.0234138);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503891,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488529,-99) , 
3, 172.186, 1, 0, 0.500213,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515022,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46813,-99) , 
3, 128.615, 0, 0, 0.494086,-99) , 
2, -2.54318, 0, 0, 0.498756,-99) , 
NN(
0, 
0, 
-1, 251.044, 1, -1, 0.476253,-99) , 
1, 196.169, 1, 0, 0.495555,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.030039);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515116,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483974,-99) , 
0, 74.4945, 0, 0, 0.503784,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518653,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487536,-99) , 
2, 2.84238, 0, 0, 0.491853,-99) , 
0, 98.0348, 1, 0, 0.495758,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466363,-99) , 
0, 231.92, 1, 0, 0.494264,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.0154652);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513865,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501268,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47497,-99) , 
0, 61.8584, 0, 0, 0.499454,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.433366,-99) , 
0, 209.741, 1, 0, 0.495296,-99) , 
3, 240.087, 0, 0, 0.497474,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0337457);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525299,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518029,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455257,-99) , 
2, -2.41499, 1, 0, 0.490683,-99) , 
2, 1.94476, 0, 0, 0.504677,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505831,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486852,-99) , 
0, 114.045, 0, 0, 0.495499,-99) , 
NN(
0, 
0, 
-1, 109.89, 1, -1, 0.465721,-99) , 
1, 195.356, 1, 0, 0.491214,-99) , 
3, 180.098, 0, 0, 0.494478,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0184252);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522018,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496557,-99) , 
0, 74.0036, 0, 0, 0.508227,-99) , 
NN(
0, 
0, 
-1, 194.228, 1, -1, 0.492804,-99) , 
0, 87.7361, 1, 0, 0.496111,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472178,-99) , 
0, 231.92, 1, 0, 0.494897,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.016461);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514426,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482072,-99) , 
2, 2.54314, 1, 0, 0.506876,-99) , 
NN(
0, 
0, 
-1, 194.228, 1, -1, 0.496374,-99) , 
0, 98.0348, 1, 0, 0.499811,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476773,-99) , 
0, 231.92, 1, 0, 0.498643,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.0115517);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504312,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493906,-99) , 
0, 133.344, 1, 0, 0.502813,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48746,-99) , 
0, 170.126, 1, 0, 0.501861,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480881,-99) , 
0, 231.92, 1, 0, 0.500798,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.0335342);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519421,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493931,-99) , 
3, 114.616, 0, 0, 0.510804,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508045,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478335,-99) , 
2, -1.93056, 1, 0, 0.495798,-99) , 
2, 1.94478, 0, 0, 0.501346,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522963,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478341,-99) , 
2, -1.77383, 0, 0, 0.504561,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455141,-99) , 
2, 1.64563, 1, 0, 0.489521,-99) , 
3, 60.1208, 0, 0, 0.499283,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.0201272);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 126.931, 0, 1, 0.507406,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472816,-99) , 
3, 57.6086, 0, 0, 0.502717,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506402,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491974,-99) , 
2, -2.07303, 0, 0, 0.498159,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474791,-99) , 
1, 194.228, 1, 0, 0.494611,-99) , 
2, 1.34639, 0, 0, 0.497954,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.0256604);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5332,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492257,-99) , 
3, 91.4854, 1, 0, 0.509166,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50901,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450344,-99) , 
3, 86.0131, 0, 0, 0.496434,-99) , 
2, -2.54318, 0, 0, 0.501947,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502585,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479479,-99) , 
3, 57.6086, 0, 0, 0.499382,-99) , 
NN(
0, 
0, 
-1, 120.11, 1, -1, 0.480098,-99) , 
2, 1.21818, 0, 0, 0.49396,-99) , 
2, -1.34639, 1, 0, 0.497248,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.0206688);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526283,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496583,-99) , 
3, 91.4854, 1, 0, 0.509191,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505958,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47628,-99) , 
3, 128.604, 0, 0, 0.492766,-99) , 
2, -2.54318, 0, 0, 0.500361,-99) , 
NN(
0, 
0, 
-1, 0.54853, 0, -1, 0.492108,-99) , 
2, -1.04719, 1, 0, 0.49569,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.0189235);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 104.327, 1, 1, 0.514493,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50273,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491203,-99) , 
3, 120.11, 1, 0, 0.497443,-99) , 
2, -1.73107, 1, 0, 0.500599,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518662,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493334,-99) , 
2, -2.88513, 1, 0, 0.506047,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47893,-99) , 
0, 112.337, 0, 0, 0.49219,-99) , 
2, -2.54318, 0, 0, 0.498637,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.0110578);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508838,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497521,-99) , 
2, -0.648259, 1, 0, 0.500885,-99) , 
NN(
0, 
0, 
-1, -2.74266, 1, -1, 0.493093,-99) , 
2, -2.54318, 0, 0, 0.499048,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483946,-99) , 
0, 231.92, 1, 0, 0.498283,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.0143268);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520213,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49673,-99) , 
2, 0.149586, 0, 0, 0.508469,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513158,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495732,-99) , 
0, 85.7744, 1, 0, 0.499584,-99) , 
0, 149.528, 0, 0, 0.500556,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486708,-99) , 
0, 231.92, 1, 0, 0.499855,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.0186055);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510289,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50559,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481981,-99) , 
0, 61.8584, 0, 0, 0.503963,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450092,-99) , 
0, 209.741, 1, 0, 0.500587,-99) , 
3, 240.087, 0, 0, 0.501726,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.0129234);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505639,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502353,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487684,-99) , 
0, 135.8, 1, 0, 0.499953,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454702,-99) , 
0, 209.741, 1, 0, 0.497119,-99) , 
3, 240.087, 0, 0, 0.498119,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.00889097);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502409,-99) , 
NN(
0, 
0, 
-1, 209.741, 1, -1, 0.495284,-99) , 
3, 240.087, 0, 0, 0.49612,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.0272085);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522813,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481432,-99) , 
3, 91.5909, 0, 0, 0.508405,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474646,-99) , 
1, 178.743, 1, 0, 0.500887,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509875,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49511,-99) , 
0, 108.334, 0, 0, 0.499815,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471397,-99) , 
3, 229.538, 1, 0, 0.496271,-99) , 
0, 123.782, 0, 0, 0.497821,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.0223693);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516767,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50646,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492593,-99) , 
2, 2.5717, 1, 0, 0.499482,-99) , 
1, 196.169, 0, 0, 0.501893,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522849,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494081,-99) , 
2, -2.03025, 0, 0, 0.504817,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506899,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477621,-99) , 
2, -2.40074, 1, 0, 0.491956,-99) , 
0, 109.89, 1, 0, 0.498025,-99) , 
2, 0.747994, 0, 0, 0.499788,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.013849);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 104.327, 1, 1, 0.510751,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500708,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486388,-99) , 
1, 196.169, 1, 0, 0.498617,-99) , 
2, -1.73107, 1, 0, 0.500863,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514847,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487607,-99) , 
3, 128.615, 0, 0, 0.503383,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47709,-99) , 
2, -2.74266, 1, 0, 0.496492,-99) , 
2, -2.54318, 0, 0, 0.499844,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.0247194);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512896,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503226,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483762,-99) , 
3, 85.4316, 0, 0, 0.498436,-99) , 
2, -2.07301, 0, 0, 0.50046,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521621,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475691,-99) , 
3, 126.604, 0, 0, 0.502454,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504773,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476202,-99) , 
3, 120.11, 1, 0, 0.493615,-99) , 
2, 2.68565, 0, 0, 0.496368,-99) , 
2, -1.64559, 1, 0, 0.497938,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.0264219);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515871,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494779,-99) , 
2, 2.71417, 0, 0, 0.505814,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517003,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477636,-99) , 
3, 93.1076, 0, 0, 0.488849,-99) , 
3, 114.954, 0, 0, 0.498107,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515517,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493445,-99) , 
3, 95.6023, 1, 0, 0.50235,-99) , 
NN(
0, 
0, 
-1, -1.85932, 1, -1, 0.48695,-99) , 
0, 109.89, 1, 0, 0.494177,-99) , 
2, 1.34639, 0, 0, 0.495799,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.0137471);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508716,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506092,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489259,-99) , 
0, 103.976, 0, 0, 0.499463,-99) , 
1, 175.353, 0, 0, 0.501382,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514163,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496445,-99) , 
1, 196.169, 0, 0, 0.498951,-99) , 
NN(
0, 
0, 
-1, -0.668697, 1, -1, 0.490238,-99) , 
2, 0.406056, 0, 0, 0.496985,-99) , 
2, -1.64559, 1, 0, 0.498673,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.0165827);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 126.931, 0, 1, 0.507991,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50176,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474696,-99) , 
2, 2.79963, 1, 0, 0.494226,-99) , 
3, 114.954, 0, 0, 0.501738,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512681,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495249,-99) , 
2, -2.50043, 0, 0, 0.505338,-99) , 
NN(
0, 
0, 
-1, 180.738, 1, -1, 0.492436,-99) , 
0, 109.89, 1, 0, 0.498491,-99) , 
2, 1.34639, 0, 0, 0.499831,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.0119145);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510996,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506519,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493041,-99) , 
0, 103.976, 0, 0, 0.501213,-99) , 
1, 175.353, 0, 0, 0.503219,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502207,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490516,-99) , 
3, 172.186, 1, 0, 0.49934,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488504,-99) , 
1, 196.169, 1, 0, 0.497757,-99) , 
2, -1.94478, 1, 0, 0.499665,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.0113711);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509008,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505622,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496075,-99) , 
2, -2.53096, 0, 0, 0.500065,-99) , 
2, -2.9706, 1, 0, 0.502105,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509236,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488075,-99) , 
2, 2.17273, 0, 0, 0.501392,-99) , 
NN(
0, 
0, 
-1, 195.479, 1, -1, 0.495594,-99) , 
3, 180.098, 0, 0, 0.496896,-99) , 
2, -1.94478, 1, 0, 0.498716,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.0119081);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 150.281, 0, 1, 0.502597,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483351,-99) , 
0, 204.135, 1, 0, 0.501182,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520569,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498735,-99) , 
0, 126.931, 0, 0, 0.505141,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502792,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465448,-99) , 
3, 76.7234, 0, 0, 0.485128,-99) , 
3, 114.954, 0, 0, 0.497079,-99) , 
2, 2.24398, 1, 0, 0.499942,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.0174018);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512981,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491697,-99) , 
3, 91.5909, 0, 0, 0.505568,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483082,-99) , 
1, 178.743, 1, 0, 0.500566,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50424,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495095,-99) , 
1, 132.282, 0, 0, 0.500022,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477908,-99) , 
3, 229.538, 1, 0, 0.497264,-99) , 
0, 123.782, 0, 0, 0.498373,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.00791773);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503038,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501273,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493621,-99) , 
0, 135.8, 1, 0, 0.500022,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466274,-99) , 
0, 209.741, 1, 0, 0.497916,-99) , 
3, 240.087, 0, 0, 0.498517,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.0146268);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50864,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496645,-99) , 
3, 91.5909, 0, 0, 0.504463,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487877,-99) , 
1, 178.743, 1, 0, 0.500774,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506188,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495152,-99) , 
3, 153.065, 0, 0, 0.497705,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480275,-99) , 
3, 229.538, 1, 0, 0.495532,-99) , 
0, 123.782, 0, 0, 0.497291,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.0121908);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509556,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504977,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481529,-99) , 
1, 162.072, 1, 0, 0.497612,-99) , 
3, 180.222, 0, 0, 0.500724,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501424,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487363,-99) , 
2, 2.84238, 1, 0, 0.49967,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483927,-99) , 
3, 229.538, 1, 0, 0.497708,-99) , 
0, 123.782, 0, 0, 0.49872,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.00732238);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50322,-99) , 
NN(
0, 
0, 
-1, 209.741, 1, -1, 0.49628,-99) , 
3, 240.087, 0, 0, 0.497094,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.0147135);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515123,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493777,-99) , 
3, 108.881, 0, 0, 0.50642,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513196,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489374,-99) , 
2, -2.71413, 1, 0, 0.496295,-99) , 
2, 1.3464, 0, 0, 0.500431,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510615,-99) , 
NN(
0, 
0, 
-1, 172.186, 1, -1, 0.495511,-99) , 
1, 196.295, 0, 0, 0.497518,-99) , 
0, 123.782, 0, 0, 0.498495,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.0184881);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516289,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504012,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471063,-99) , 
1, 198.152, 1, 0, 0.499611,-99) , 
3, 108.682, 0, 0, 0.501683,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519825,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503529,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484257,-99) , 
1, 132.149, 1, 0, 0.495799,-99) , 
1, 196.169, 0, 0, 0.499264,-99) , 
3, 120.11, 1, 0, 0.500503,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.0130389);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512375,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49773,-99) , 
1, 172.652, 0, 0, 0.50073,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45601,-99) , 
1, 251.043, 1, 0, 0.49831,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492964,-99) , 
1, 68.1304, 0, 0, 0.497982,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.0231088);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506148,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483502,-99) , 
1, 87.2568, 0, 0, 0.503418,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508612,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482865,-99) , 
1, 104.713, 1, 0, 0.492639,-99) , 
3, 172.186, 1, 0, 0.500554,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518224,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459246,-99) , 
1, 251.044, 1, 0, 0.497028,-99) , 
1, 196.169, 1, 0, 0.500056,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.00942006);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504296,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505391,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497436,-99) , 
3, 45.8367, 1, 0, 0.4984,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467288,-99) , 
0, 209.741, 1, 0, 0.49646,-99) , 
3, 240.087, 0, 0, 0.497379,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.0116224);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51512,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501441,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490439,-99) , 
1, 141.295, 1, 0, 0.4979,-99) , 
1, 196.169, 0, 0, 0.500383,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512392,-99) , 
NN(
0, 
0, 
-1, 198.152, 1, -1, 0.494947,-99) , 
3, 108.682, 0, 0, 0.497114,-99) , 
3, 120.11, 0, 0, 0.498709,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.0161336);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504866,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494195,-99) , 
3, 131.218, 1, 0, 0.501198,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489554,-99) , 
3, 229.538, 1, 0, 0.499649,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51382,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465304,-99) , 
1, 251.044, 1, 0, 0.4964,-99) , 
1, 196.169, 1, 0, 0.49919,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.0184664);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514181,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507394,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493027,-99) , 
2, -2.28673, 1, 0, 0.499012,-99) , 
2, 2.84238, 0, 0, 0.501661,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50536,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487538,-99) , 
2, -2.11576, 0, 0, 0.498715,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502373,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469212,-99) , 
3, 80.1592, 0, 0, 0.486478,-99) , 
2, 2.24398, 1, 0, 0.49559,-99) , 
3, 120.11, 0, 0, 0.498552,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.020624);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 132.15, 0, 1, 0.507755,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508593,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487976,-99) , 
2, -2.77114, 1, 0, 0.495989,-99) , 
2, 0.747994, 0, 0, 0.501491,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508244,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494056,-99) , 
1, 139.735, 0, 0, 0.49805,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506796,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45051,-99) , 
1, 206.744, 1, 0, 0.487021,-99) , 
1, 162.072, 1, 0, 0.494666,-99) , 
3, 120.11, 0, 0, 0.497996,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.0145789);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510455,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50573,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494644,-99) , 
0, 126.924, 0, 0, 0.49788,-99) , 
1, 196.169, 0, 0, 0.499691,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504691,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49536,-99) , 
2, 0.448801, 1, 0, 0.500303,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501641,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45562,-99) , 
1, 206.744, 1, 0, 0.485481,-99) , 
1, 162.072, 1, 0, 0.495757,-99) , 
3, 120.11, 0, 0, 0.497676,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.0117454);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508638,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49982,-99) , 
1, 132.15, 0, 0, 0.504049,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501701,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488349,-99) , 
2, -1.20396, 1, 0, 0.498157,-99) , 
2, 1.94478, 0, 0, 0.500465,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502575,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492986,-99) , 
2, -2.24397, 0, 0, 0.500086,-99) , 
NN(
0, 
0, 
-1, 206.744, 1, -1, 0.484392,-99) , 
1, 162.072, 1, 0, 0.495273,-99) , 
3, 120.11, 0, 0, 0.497806,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.0098667);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 171.748, 0, 1, 0.503942,-99) , 
NN(
0, 
0, 
-1, -1.84505, 1, -1, 0.495925,-99) , 
2, 0.747994, 0, 0, 0.499673,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500555,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489941,-99) , 
0, 85.2309, 0, 0, 0.498674,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500932,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462157,-99) , 
1, 206.744, 1, 0, 0.487326,-99) , 
1, 162.072, 1, 0, 0.495194,-99) , 
3, 120.11, 0, 0, 0.49738,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.0107165);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505253,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504702,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495733,-99) , 
1, 104.713, 1, 0, 0.498922,-99) , 
1, 196.169, 0, 0, 0.499833,-99) , 
NN(
0, 
0, 
-1, 162.072, 1, -1, 0.493864,-99) , 
3, 120.11, 0, 0, 0.496777,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.0107664);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504527,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49838,-99) , 
3, 171.748, 0, 0, 0.501776,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503751,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48848,-99) , 
2, -2.35801, 1, 0, 0.498479,-99) , 
2, 0.149599, 0, 0, 0.50011,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502065,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49459,-99) , 
1, 109.953, 0, 0, 0.499761,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501145,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467277,-99) , 
1, 206.744, 1, 0, 0.489266,-99) , 
1, 162.072, 1, 0, 0.496543,-99) , 
3, 120.11, 0, 0, 0.498283,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.0119818);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517976,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495585,-99) , 
3, 156.291, 0, 0, 0.501766,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501419,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488982,-99) , 
2, -2.54317, 0, 0, 0.497596,-99) , 
3, 174.385, 1, 0, 0.499549,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504979,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497104,-99) , 
3, 45.8372, 1, 0, 0.498728,-99) , 
NN(
0, 
0, 
-1, 206.744, 1, -1, 0.488461,-99) , 
1, 162.072, 1, 0, 0.49558,-99) , 
3, 120.11, 0, 0, 0.497517,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.0143756);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516875,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494765,-99) , 
0, 84.9648, 1, 0, 0.502572,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500505,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482442,-99) , 
3, 180.122, 1, 0, 0.496189,-99) , 
0, 112.693, 1, 0, 0.499461,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501208,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481283,-99) , 
3, 126.988, 0, 0, 0.493202,-99) , 
2, 2.84238, 1, 0, 0.498619,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.0119222);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513284,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498359,-99) , 
0, 84.9648, 1, 0, 0.503628,-99) , 
NN(
0, 
0, 
-1, 180.12, 1, -1, 0.494312,-99) , 
0, 112.693, 1, 0, 0.499089,-99) , 
NN(
0, 
0, 
-1, 126.988, 0, -1, 0.492495,-99) , 
2, 2.84238, 1, 0, 0.498201,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.00866654);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506883,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499341,-99) , 
1, 118.321, 0, 0, 0.504003,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501541,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49296,-99) , 
2, 0.477304, 0, 0, 0.499461,-99) , 
2, -1.94478, 1, 0, 0.501137,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507349,-99) , 
NN(
0, 
0, 
-1, -0.149613, 1, -1, 0.491148,-99) , 
1, 123.563, 1, 0, 0.496028,-99) , 
3, 60.1208, 0, 0, 0.500248,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.00925528);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507076,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497755,-99) , 
2, 1.41761, 1, 0, 0.504119,-99) , 
NN(
0, 
0, 
-1, 180.12, 1, -1, 0.496909,-99) , 
0, 112.693, 1, 0, 0.500606,-99) , 
NN(
0, 
0, 
-1, 126.988, 0, -1, 0.49358,-99) , 
2, 2.84238, 1, 0, 0.49966,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.00724123);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 84.9648, 1, 1, 0.503273,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501738,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489349,-99) , 
1, 180.12, 1, 0, 0.499222,-99) , 
0, 112.693, 1, 0, 0.501299,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500742,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488672,-99) , 
3, 126.988, 0, 0, 0.495894,-99) , 
2, 2.84238, 1, 0, 0.500572,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.00705263);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507271,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498295,-99) , 
0, 84.9648, 1, 0, 0.501463,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500804,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489684,-99) , 
3, 180.122, 1, 0, 0.498147,-99) , 
0, 112.693, 1, 0, 0.499847,-99) , 
NN(
0, 
0, 
-1, 126.988, 0, -1, 0.495538,-99) , 
2, 2.84238, 1, 0, 0.499267,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.00821367);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504669,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498271,-99) , 
2, -2.68566, 1, 0, 0.501908,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502599,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495689,-99) , 
1, 132.15, 1, 0, 0.498952,-99) , 
2, -1.94478, 1, 0, 0.500043,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505214,-99) , 
NN(
0, 
0, 
-1, -0.747882, 1, -1, 0.491991,-99) , 
3, 31.5544, 1, 0, 0.49604,-99) , 
3, 60.1208, 0, 0, 0.499346,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.00670135);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507683,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499399,-99) , 
3, 128.027, 1, 0, 0.504054,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501222,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496762,-99) , 
1, 132.15, 1, 0, 0.498798,-99) , 
2, -1.70257, 1, 0, 0.500284,-99) , 
NN(
0, 
0, 
-1, -2.98485, 1, -1, 0.494094,-99) , 
2, -2.84238, 0, 0, 0.499458,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.00605067);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507578,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499741,-99) , 
0, 112.663, 1, 0, 0.503847,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501669,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497711,-99) , 
2, 2.68023, 0, 0, 0.498944,-99) , 
2, -1.70257, 1, 0, 0.50033,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501054,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489294,-99) , 
2, -2.98485, 1, 0, 0.495769,-99) , 
2, -2.84238, 0, 0, 0.499722,-99)    );
   return;
};
 
// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
