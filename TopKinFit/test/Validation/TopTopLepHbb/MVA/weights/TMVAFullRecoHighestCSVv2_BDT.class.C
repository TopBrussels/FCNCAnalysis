// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.06/01       [394753]
Creator        : kskovpen
Date           : Fri Feb  3 15:19:24 2017
Host           : Linux vocms0301.cern.ch 2.6.32-642.11.1.el6.x86_64 #1 SMP Wed Nov 16 09:40:09 CET 2016 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /storage_mnt/storage/user/kskovpen/analysis/tHFCNC/CMSSW_8_0_25/src/TopKinFit/test/Validation/TopTopLepHbb/MVA
Training events: 363164
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
SeparationType: "giniindex" [Separation criterion for node splitting]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
MinNodeSize: "5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "2" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 4
HiggsRecMHighestCSVv2         HiggsRecMHighestCSVv2         HiggsRecMHighestCSVv2         HiggsRecMHighestCSVv2                                           'F'    [16.1375598907,2286.52832031]
TopLepRecMHighestCSVv2        TopLepRecMHighestCSVv2        TopLepRecMHighestCSVv2        TopLepRecMHighestCSVv2                                          'F'    [43.9322471619,2432.68847656]
HiggsTopLepRecDrHighestCSVv2  HiggsTopLepRecDrHighestCSVv2  HiggsTopLepRecDrHighestCSVv2  HiggsTopLepRecDrHighestCSVv2                                    'F'    [0.00311985425651,9.79217910767]
TopLepRecPtHighestCSVv2       TopLepRecPtHighestCSVv2       TopLepRecPtHighestCSVv2       TopLepRecPtHighestCSVv2                                         'F'    [0.132021471858,1259.89562988]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTNode
   
#ifndef BDTNode__def
#define BDTNode__def
   
class BDTNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 4 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "HiggsRecMHighestCSVv2", "TopLepRecMHighestCSVv2", "HiggsTopLepRecDrHighestCSVv2", "TopLepRecPtHighestCSVv2" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[4];
   double fVmax[4];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[4];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadBDT::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(0.315150555147329);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 172.186, 0, 1, 0.630887,-99) , 
NN(
0, 
0, 
-1, 132.196, 1, -1, 0.388981,-99) , 
2, 2.54316, 0, 0, 0.553452,-99) , 
NN(
0, 
0, 
-1, 2.79999, 0, -1, 0.179222,-99) , 
1, 271.433, 1, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.430497);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.693907,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.422478,-99) , 
1, 251.882, 1, 0, 0.660936,-99) , 
NN(
0, 
0, 
-1, 70.3169, 0, -1, 0.315638,-99) , 
0, 83.065, 0, 0, 0.575509,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.587885,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.172698,-99) , 
0, 148.766, 1, 0, 0.405866,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0956239,-99) , 
0, 227.217, 1, 0, 0.337229,-99) , 
0, 124.251, 1, 0, 0.486414,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.274647);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 162.403, 0, 1, 0.612592,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.559235,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.392754,-99) , 
3, 172.186, 0, 0, 0.433027,-99) , 
0, 93.3615, 0, 0, 0.544775,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532095,-99) , 
NN(
0, 
0, 
-1, 216.128, 1, -1, 0.271003,-99) , 
3, 180.128, 0, 0, 0.333603,-99) , 
0, 124.251, 1, 0, 0.467164,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.197491);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542122,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.369219,-99) , 
0, 69.0907, 0, 0, 0.522995,-99) , 
NN(
0, 
0, 
-1, 166.172, 1, -1, 0.289865,-99) , 
0, 139.696, 1, 0, 0.482888,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.152154,-99) , 
0, 232.365, 1, 0, 0.460321,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.177451);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532675,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.422921,-99) , 
3, 114.835, 0, 0, 0.479745,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.25852,-99) , 
0, 160.289, 1, 0, 0.458984,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.179415,-99) , 
0, 232.365, 1, 0, 0.440867,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.172852);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.552088,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457911,-99) , 
2, 2.96542, 0, 0, 0.499119,-99) , 
NN(
0, 
0, 
-1, 2.88732, 0, -1, 0.364427,-99) , 
1, 206.433, 1, 0, 0.469943,-99) , 
NN(
0, 
0, 
-1, 2.79999, 0, -1, 0.283548,-99) , 
1, 271.433, 1, 0, 0.445439,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.105265);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510096,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.398519,-99) , 
1, 251.882, 1, 0, 0.493874,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.313466,-99) , 
0, 160.289, 1, 0, 0.477744,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.223064,-99) , 
0, 232.365, 1, 0, 0.462323,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.130945);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.555014,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459031,-99) , 
2, 3.49161, 0, 0, 0.473957,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.313513,-99) , 
0, 170.585, 1, 0, 0.462967,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.241838,-99) , 
0, 232.365, 1, 0, 0.449895,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.0841727);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.57402,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486021,-99) , 
3, 240.087, 0, 0, 0.49646,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.342359,-99) , 
0, 170.585, 1, 0, 0.48609,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.26665,-99) , 
0, 232.365, 1, 0, 0.473448,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.0900945);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522582,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438964,-99) , 
2, 1.74736, 0, 0, 0.512523,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.361553,-99) , 
0, 170.585, 1, 0, 0.502473,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.283429,-99) , 
0, 232.365, 1, 0, 0.490058,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.092785);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528934,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470519,-99) , 
0, 104.393, 0, 0, 0.500817,-99) , 
NN(
0, 
0, 
-1, 120.141, 0, -1, 0.419496,-99) , 
0, 139.696, 1, 0, 0.487979,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.302079,-99) , 
0, 232.365, 1, 0, 0.477606,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.0983817);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524051,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437281,-99) , 
1, 134.726, 0, 0, 0.511939,-99) , 
NN(
0, 
0, 
-1, 2.88732, 0, -1, 0.412288,-99) , 
1, 217.266, 1, 0, 0.496342,-99) , 
NN(
0, 
0, 
-1, 2.79999, 0, -1, 0.376283,-99) , 
1, 271.433, 1, 0, 0.481587,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.0555541);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501885,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.429443,-99) , 
0, 59.2845, 0, 0, 0.496379,-99) , 
NN(
0, 
0, 
-1, 120.141, 0, -1, 0.443652,-99) , 
0, 129.399, 1, 0, 0.483717,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.319879,-99) , 
0, 232.365, 1, 0, 0.474754,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.0904414);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550371,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454135,-99) , 
2, 2.74676, 0, 0, 0.517476,-99) , 
NN(
0, 
0, 
-1, 209.966, 1, -1, 0.465412,-99) , 
3, 180.098, 0, 0, 0.478081,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.332084,-99) , 
0, 232.365, 1, 0, 0.470162,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.0454239);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.558516,-99) , 
NN(
0, 
0, 
-1, 251.882, 1, -1, 0.487969,-99) , 
2, 3.92767, 0, 0, 0.493416,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.35244,-99) , 
0, 232.365, 1, 0, 0.485854,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.042098);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510006,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468244,-99) , 
2, 1.3113, 0, 0, 0.50731,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440653,-99) , 
0, 170.585, 1, 0, 0.503019,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.362875,-99) , 
0, 232.365, 1, 0, 0.495545,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.0696012);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516942,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458479,-99) , 
1, 192.468, 1, 0, 0.501128,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520602,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.373562,-99) , 
0, 119.103, 1, 0, 0.460695,-99) , 
1, 251.882, 1, 0, 0.495119,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.372663,-99) , 
0, 232.365, 1, 0, 0.48862,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.0788928);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540357,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454464,-99) , 
1, 206.428, 1, 0, 0.521343,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505862,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.442077,-99) , 
3, 114.835, 0, 0, 0.477344,-99) , 
2, 2.54316, 1, 0, 0.49177,-99) , 
NN(
0, 
0, 
-1, 2.79999, 0, -1, 0.415207,-99) , 
1, 271.433, 1, 0, 0.482611,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.0514771);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542429,-99) , 
NN(
0, 
0, 
-1, 147.907, 0, -1, 0.480818,-99) , 
2, 3.92767, 0, 0, 0.485583,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.388523,-99) , 
0, 232.365, 1, 0, 0.480504,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.0341837);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506042,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463018,-99) , 
0, 160.289, 1, 0, 0.502415,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500984,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451951,-99) , 
3, 137.711, 0, 0, 0.472447,-99) , 
1, 147.907, 0, 0, 0.496455,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.40082,-99) , 
0, 232.365, 1, 0, 0.491473,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.0335261);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524154,-99) , 
NN(
0, 
0, 
-1, 251.882, 1, -1, 0.488268,-99) , 
2, 3.92767, 0, 0, 0.491039,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.409057,-99) , 
0, 232.365, 1, 0, 0.48678,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.0311794);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507805,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47999,-99) , 
1, 246.932, 1, 0, 0.502303,-99) , 
NN(
0, 
0, 
-1, 128.102, 0, -1, 0.48127,-99) , 
1, 147.907, 0, 0, 0.498124,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.417186,-99) , 
0, 232.365, 1, 0, 0.49393,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.0240351);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502836,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472501,-99) , 
3, 57.4835, 0, 0, 0.498076,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465181,-99) , 
2, 1.3113, 0, 0, 0.495897,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.424786,-99) , 
0, 232.365, 1, 0, 0.492219,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.0538728);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.30186, 0, 1, 0.523378,-99) , 
NN(
0, 
0, 
-1, 57.4835, 0, -1, 0.480168,-99) , 
2, 2.54316, 1, 0, 0.494347,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520293,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.36732,-99) , 
2, 2.79999, 0, 0, 0.451312,-99) , 
1, 271.433, 1, 0, 0.489254,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.0456908);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51371,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449248,-99) , 
1, 124.408, 0, 0, 0.507411,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505279,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471078,-99) , 
3, 137.502, 0, 0, 0.484612,-99) , 
1, 184.766, 1, 0, 0.498974,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506836,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.379927,-99) , 
2, 2.79999, 0, 0, 0.449799,-99) , 
1, 271.433, 1, 0, 0.493168,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.0579125);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.551281,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47522,-99) , 
3, 137.155, 0, 0, 0.506536,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508449,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469483,-99) , 
3, 114.835, 1, 0, 0.488395,-99) , 
0, 125.134, 0, 0, 0.494062,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509906,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.402137,-99) , 
0, 110.359, 1, 0, 0.448508,-99) , 
1, 271.433, 1, 0, 0.488692,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.0466571);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526361,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464249,-99) , 
1, 198.276, 1, 0, 0.50911,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506886,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480195,-99) , 
2, 2.55905, 1, 0, 0.488806,-99) , 
0, 125.134, 0, 0, 0.495145,-99) , 
NN(
0, 
0, 
-1, 2.79999, 0, -1, 0.450354,-99) , 
1, 271.433, 1, 0, 0.489875,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.0390019);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525795,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496032,-99) , 
2, 3.1613, 0, 0, 0.505426,-99) , 
NN(
0, 
0, 
-1, 2.99977, 1, -1, 0.464538,-99) , 
3, 57.4835, 0, 0, 0.499245,-99) , 
NN(
0, 
0, 
-1, 121.795, 1, -1, 0.451616,-99) , 
2, 1.8677, 0, 0, 0.492321,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.038768);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 221.346, 0, 1, 0.523911,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506628,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473563,-99) , 
3, 73.8694, 0, 0, 0.495922,-99) , 
3, 172.186, 0, 0, 0.503772,-99) , 
NN(
0, 
0, 
-1, 121.795, 1, -1, 0.461292,-99) , 
2, 1.8677, 0, 0, 0.497604,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.0375102);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512794,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491234,-99) , 
0, 109.336, 0, 0, 0.502331,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51426,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.428052,-99) , 
3, 121.112, 1, 0, 0.480487,-99) , 
2, 2.18342, 0, 0, 0.497749,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.435724,-99) , 
0, 232.365, 1, 0, 0.494583,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.0246513);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527927,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498076,-99) , 
2, 2.51566, 1, 0, 0.502056,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504886,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437259,-99) , 
3, 121.112, 1, 0, 0.478427,-99) , 
2, 2.18342, 0, 0, 0.497103,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.444968,-99) , 
0, 232.365, 1, 0, 0.494447,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.0337951);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529663,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505537,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.401154,-99) , 
1, 312.264, 1, 0, 0.498359,-99) , 
3, 229.538, 0, 0, 0.502807,-99) , 
NN(
0, 
0, 
-1, 121.795, 1, -1, 0.468814,-99) , 
2, 1.8677, 0, 0, 0.497883,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.0310547);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541274,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493658,-99) , 
1, 251.882, 0, 0, 0.500223,-99) , 
NN(
0, 
0, 
-1, 120.141, 0, -1, 0.478733,-99) , 
0, 129.399, 1, 0, 0.495154,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.447512,-99) , 
0, 232.365, 1, 0, 0.492731,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.0268965);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507921,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487268,-99) , 
1, 231.195, 1, 0, 0.505668,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478821,-99) , 
1, 130.599, 0, 0, 0.503195,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508253,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.415143,-99) , 
2, 2.79999, 0, 0, 0.466766,-99) , 
1, 271.433, 1, 0, 0.498941,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.0269809);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517755,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522192,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493417,-99) , 
2, 3.80992, 0, 0, 0.496142,-99) , 
3, 229.538, 0, 0, 0.499042,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512335,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.430387,-99) , 
0, 110.359, 1, 0, 0.465995,-99) , 
1, 271.433, 1, 0, 0.495186,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.0253858);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.30186, 0, 1, 0.512737,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503612,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464949,-99) , 
3, 57.4835, 0, 0, 0.49806,-99) , 
2, 2.54316, 1, 0, 0.502871,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502393,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.422476,-99) , 
2, 2.79999, 0, 0, 0.466838,-99) , 
1, 271.433, 1, 0, 0.498671,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.0256472);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542487,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493734,-99) , 
2, 2.30186, 0, 0, 0.506393,-99) , 
NN(
0, 
0, 
-1, 57.4835, 0, -1, 0.493535,-99) , 
2, 2.54316, 1, 0, 0.49775,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504879,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.436266,-99) , 
0, 110.359, 1, 0, 0.466108,-99) , 
1, 271.433, 1, 0, 0.494064,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.0385011);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517168,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482248,-99) , 
1, 195.597, 1, 0, 0.507428,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536584,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487363,-99) , 
1, 206.919, 0, 0, 0.497413,-99) , 
2, 2.96542, 1, 0, 0.503071,-99) , 
NN(
0, 
0, 
-1, 2.79999, 0, -1, 0.46691,-99) , 
1, 271.433, 1, 0, 0.498861,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0281332);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508692,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481441,-99) , 
0, 68.3261, 0, 0, 0.506257,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509172,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452316,-99) , 
3, 121.112, 1, 0, 0.486998,-99) , 
2, 2.18342, 0, 0, 0.502224,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459076,-99) , 
0, 232.365, 1, 0, 0.500046,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.0163478);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506221,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497656,-99) , 
1, 172.385, 1, 0, 0.501071,-99) , 
NN(
0, 
0, 
-1, 103.331, 0, -1, 0.486918,-99) , 
1, 141.432, 0, 0, 0.498722,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502109,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.436965,-99) , 
2, 2.79999, 0, 0, 0.473214,-99) , 
1, 271.433, 1, 0, 0.495756,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0210124);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509047,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499871,-99) , 
2, 2.54316, 1, 0, 0.502897,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523294,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477542,-99) , 
3, 158.813, 0, 0, 0.492352,-99) , 
1, 152.266, 0, 0, 0.500091,-99) , 
NN(
0, 
0, 
-1, 2.79999, 0, -1, 0.47274,-99) , 
1, 271.433, 1, 0, 0.496912,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0325897);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 126.229, 0, 1, 0.516615,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53647,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493472,-99) , 
3, 147.607, 0, 0, 0.499255,-99) , 
3, 172.186, 0, 0, 0.504334,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525758,-99) , 
NN(
0, 
0, 
-1, 118.261, 1, -1, 0.471459,-99) , 
3, 61.1755, 1, 0, 0.483818,-99) , 
2, 2.33385, 0, 0, 0.499118,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.0255009);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520302,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506699,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483398,-99) , 
3, 57.6209, 0, 0, 0.503929,-99) , 
2, 3.7545, 0, 0, 0.506166,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51424,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48485,-99) , 
3, 81.1509, 1, 0, 0.502439,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46654,-99) , 
3, 121.112, 1, 0, 0.488245,-99) , 
2, 2.33385, 0, 0, 0.501611,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.0285576);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516648,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493695,-99) , 
0, 114.045, 1, 0, 0.506078,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514114,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488624,-99) , 
0, 126.229, 0, 0, 0.496213,-99) , 
3, 114.835, 1, 0, 0.501,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510132,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45236,-99) , 
0, 110.359, 1, 0, 0.477575,-99) , 
1, 271.433, 1, 0, 0.49828,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.0185466);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510738,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499421,-99) , 
3, 114.835, 1, 0, 0.504991,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511927,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48623,-99) , 
3, 158.813, 0, 0, 0.494547,-99) , 
1, 152.266, 0, 0, 0.502214,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500432,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450809,-99) , 
2, 2.79999, 0, 0, 0.478463,-99) , 
1, 271.433, 1, 0, 0.499457,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.0139939);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51553,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502848,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488261,-99) , 
1, 130.599, 0, 0, 0.501463,-99) , 
2, 3.80992, 0, 0, 0.502702,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502466,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458891,-99) , 
0, 110.359, 1, 0, 0.477923,-99) , 
1, 271.433, 1, 0, 0.499827,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.0135231);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512034,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504923,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496202,-99) , 
3, 172.31, 0, 0, 0.498629,-99) , 
2, 3.80992, 0, 0, 0.499809,-99) , 
NN(
0, 
0, 
-1, 2.79999, 0, -1, 0.478358,-99) , 
1, 271.433, 1, 0, 0.497321,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0182279);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538849,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498775,-99) , 
1, 251.882, 0, 0, 0.504292,-99) , 
NN(
0, 
0, 
-1, 149.012, 0, -1, 0.486711,-99) , 
0, 129.399, 1, 0, 0.500158,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470288,-99) , 
0, 232.365, 1, 0, 0.498659,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0203644);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.30186, 0, 1, 0.50991,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507359,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487801,-99) , 
2, 2.84478, 0, 0, 0.502875,-99) , 
2, 2.54316, 1, 0, 0.50518,-99) , 
NN(
0, 
0, 
-1, 2.79999, 0, -1, 0.480362,-99) , 
1, 271.433, 1, 0, 0.502304,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0153374);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537249,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499844,-99) , 
1, 251.882, 0, 0, 0.504991,-99) , 
NN(
0, 
0, 
-1, 149.012, 0, -1, 0.488875,-99) , 
0, 129.399, 1, 0, 0.501203,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47284,-99) , 
0, 232.365, 1, 0, 0.499781,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.0235696);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511985,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486459,-99) , 
1, 217.263, 1, 0, 0.508049,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527039,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495188,-99) , 
1, 206.919, 0, 0, 0.501683,-99) , 
2, 2.96542, 1, 0, 0.505279,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502029,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461917,-99) , 
2, 2.79999, 0, 0, 0.484291,-99) , 
1, 271.433, 1, 0, 0.502849,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.0140349);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 125.134, 0, 1, 0.505483,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489598,-99) , 
2, 1.27641, 0, 0, 0.504497,-99) , 
NN(
0, 
0, 
-1, 2.79999, 0, -1, 0.483603,-99) , 
1, 271.433, 1, 0, 0.502078,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.0147288);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534963,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499785,-99) , 
1, 251.882, 0, 0, 0.504623,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500674,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479911,-99) , 
0, 149.012, 0, 0, 0.489727,-99) , 
0, 129.399, 1, 0, 0.501122,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474067,-99) , 
0, 232.365, 1, 0, 0.499767,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.0108683);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 3.80992, 0, 1, 0.504167,-99) , 
NN(
0, 
0, 
-1, 2.79999, 0, -1, 0.484884,-99) , 
1, 271.433, 1, 0, 0.501936,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.0191394);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548066,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499239,-99) , 
1, 253.422, 0, 0, 0.505638,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506098,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485806,-99) , 
3, 108.514, 0, 0, 0.497763,-99) , 
0, 125.134, 1, 0, 0.503187,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512594,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49266,-99) , 
2, 1.44957, 1, 0, 0.499224,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475972,-99) , 
3, 121.112, 1, 0, 0.490039,-99) , 
2, 2.33385, 0, 0, 0.499848,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.019729);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 251.882, 0, 1, 0.508296,-99) , 
NN(
0, 
0, 
-1, 173.527, 1, -1, 0.488136,-99) , 
0, 129.399, 1, 0, 0.503558,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476302,-99) , 
0, 232.365, 1, 0, 0.502195,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.0113599);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511049,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499121,-99) , 
0, 125.134, 0, 0, 0.50279,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489826,-99) , 
2, 1.27641, 0, 0, 0.501986,-99) , 
NN(
0, 
0, 
-1, 2.79999, 0, -1, 0.484446,-99) , 
1, 271.433, 1, 0, 0.499959,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.016444);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 134.879, 1, 1, 0.510842,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533868,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498299,-99) , 
1, 251.882, 0, 0, 0.502948,-99) , 
NN(
0, 
0, 
-1, 1.87047, 0, -1, 0.489506,-99) , 
0, 124.251, 1, 0, 0.498481,-99) , 
2, 3.26614, 0, 0, 0.501349,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.0143298);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 125.227, 0, 1, 0.506202,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493685,-99) , 
1, 238.933, 1, 0, 0.505283,-99) , 
NN(
0, 
0, 
-1, 2.79999, 0, -1, 0.485531,-99) , 
1, 271.433, 1, 0, 0.503002,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.0130006);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506586,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49577,-99) , 
3, 172.186, 1, 0, 0.503745,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5062,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494357,-99) , 
0, 97.805, 1, 0, 0.498037,-99) , 
1, 152.266, 0, 0, 0.502227,-99) , 
NN(
0, 
0, 
-1, 2.79999, 0, -1, 0.489111,-99) , 
1, 271.433, 1, 0, 0.500712,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.0159596);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 3.23743, 0, 1, 0.504315,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515827,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471415,-99) , 
3, 38.3663, 0, 0, 0.494344,-99) , 
3, 57.4835, 0, 0, 0.502862,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5086,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494072,-99) , 
3, 64.027, 1, 0, 0.499993,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482457,-99) , 
3, 121.112, 1, 0, 0.493068,-99) , 
2, 2.33385, 0, 0, 0.500375,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.0288051);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53464,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517057,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48797,-99) , 
0, 83.4554, 1, 0, 0.494948,-99) , 
1, 251.882, 0, 0, 0.500426,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512777,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498961,-99) , 
1, 143.748, 0, 0, 0.506582,-99) , 
NN(
0, 
0, 
-1, 3.2705, 0, -1, 0.487495,-99) , 
1, 165.343, 1, 0, 0.494098,-99) , 
0, 124.251, 1, 0, 0.498331,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.0129888);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.30186, 0, 1, 0.508214,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503309,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490248,-99) , 
2, 2.84478, 0, 0, 0.500314,-99) , 
2, 2.54316, 1, 0, 0.502902,-99) , 
NN(
0, 
0, 
-1, 2.79999, 0, -1, 0.489025,-99) , 
1, 271.433, 1, 0, 0.501301,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.0192102);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5094,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50465,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.425203,-99) , 
1, 310.805, 1, 0, 0.49918,-99) , 
3, 229.538, 0, 0, 0.5006,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488771,-99) , 
2, 1.40156, 0, 0, 0.499689,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.0163863);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501849,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502543,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450443,-99) , 
1, 304.515, 1, 0, 0.498882,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.442993,-99) , 
0, 210.187, 1, 0, 0.495374,-99) , 
3, 240.087, 0, 0, 0.496151,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.0223264);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523996,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490585,-99) , 
1, 256.242, 0, 0, 0.496671,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500158,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485622,-99) , 
2, 3.2705, 0, 0, 0.489065,-99) , 
0, 124.251, 1, 0, 0.4941,-99) , 
NN(
0, 
0, 
-1, 80.9085, 0, -1, 0.490205,-99) , 
1, 157.683, 0, 0, 0.492981,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.01361);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504241,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484485,-99) , 
1, 228.097, 1, 0, 0.502057,-99) , 
NN(
0, 
0, 
-1, 89.9633, 0, -1, 0.492053,-99) , 
2, 2.96542, 1, 0, 0.497702,-99) , 
NN(
0, 
0, 
-1, 2.79999, 0, -1, 0.491298,-99) , 
1, 271.433, 1, 0, 0.496965,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.00971691);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504107,-99) , 
NN(
0, 
0, 
-1, 229.538, 1, -1, 0.497622,-99) , 
1, 253.422, 0, 0, 0.498554,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513058,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492709,-99) , 
2, 1.44957, 1, 0, 0.499405,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485162,-99) , 
3, 121.112, 1, 0, 0.493781,-99) , 
2, 2.33385, 0, 0, 0.497343,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.0111669);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505523,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499362,-99) , 
2, 3.23743, 0, 0, 0.501215,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512445,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47604,-99) , 
3, 38.3663, 0, 0, 0.494832,-99) , 
3, 57.4835, 0, 0, 0.500285,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51063,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495138,-99) , 
2, 1.44957, 1, 0, 0.500235,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487589,-99) , 
3, 121.112, 1, 0, 0.495243,-99) , 
2, 2.33385, 0, 0, 0.499005,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.0170407);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508956,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504291,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.433956,-99) , 
1, 310.805, 1, 0, 0.499462,-99) , 
3, 229.538, 0, 0, 0.500781,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492334,-99) , 
2, 1.40156, 0, 0, 0.500131,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.0145994);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502381,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502424,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457629,-99) , 
1, 304.515, 1, 0, 0.499282,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450983,-99) , 
0, 210.187, 1, 0, 0.496256,-99) , 
3, 240.087, 0, 0, 0.496991,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.0116691);
  fForest.push_back( 
NN(
0, 
0, 
-1, 240.087, 0, -1, 0.494166,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.0118176);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501649,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501692,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464156,-99) , 
1, 304.515, 1, 0, 0.499061,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457495,-99) , 
0, 210.187, 1, 0, 0.49646,-99) , 
3, 240.087, 0, 0, 0.497083,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.0164557);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523241,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494487,-99) , 
3, 154.387, 0, 0, 0.49779,-99) , 
NN(
0, 
0, 
-1, 2.74676, 0, -1, 0.490149,-99) , 
3, 180.098, 1, 0, 0.495932,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5005,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48381,-99) , 
0, 97.805, 0, 0, 0.495218,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483364,-99) , 
3, 80.9085, 0, 0, 0.491977,-99) , 
1, 157.683, 0, 0, 0.494795,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.0122605);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519135,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498601,-99) , 
3, 154.387, 0, 0, 0.500959,-99) , 
NN(
0, 
0, 
-1, 2.74676, 0, -1, 0.494262,-99) , 
3, 180.098, 1, 0, 0.49933,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506203,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486974,-99) , 
3, 137.711, 0, 0, 0.49508,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486168,-99) , 
1, 146.849, 1, 0, 0.492003,-99) , 
1, 157.683, 0, 0, 0.497224,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.0113642);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529377,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498116,-99) , 
1, 256.242, 0, 0, 0.503804,-99) , 
NN(
0, 
0, 
-1, 180.364, 1, -1, 0.498058,-99) , 
0, 124.251, 1, 0, 0.501863,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500234,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489231,-99) , 
1, 146.849, 1, 0, 0.495487,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484918,-99) , 
1, 125.182, 0, 0, 0.493375,-99) , 
1, 157.683, 0, 0, 0.499423,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.0146918);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507649,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490493,-99) , 
3, 42.9807, 0, 0, 0.505476,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505125,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488504,-99) , 
2, 2.74676, 0, 0, 0.499489,-99) , 
3, 180.098, 1, 0, 0.50402,-99) , 
NN(
0, 
0, 
-1, 125.182, 0, -1, 0.493631,-99) , 
1, 157.683, 0, 0, 0.501034,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.0124643);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507714,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478803,-99) , 
0, 72.7685, 0, 0, 0.503208,-99) , 
NN(
0, 
0, 
-1, 120.39, 0, -1, 0.498616,-99) , 
0, 124.251, 1, 0, 0.501657,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502324,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495742,-99) , 
2, 2.80621, 1, 0, 0.49877,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491429,-99) , 
1, 125.182, 0, 0, 0.497303,-99) , 
1, 157.683, 0, 0, 0.500406,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.0148475);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50507,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504292,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468951,-99) , 
1, 304.515, 1, 0, 0.501817,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468562,-99) , 
0, 210.187, 1, 0, 0.49974,-99) , 
3, 240.087, 0, 0, 0.50038,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.0222142);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505341,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496716,-99) , 
2, 2.2638, 0, 0, 0.503287,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487607,-99) , 
3, 60.1543, 0, 0, 0.500521,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526868,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505248,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486641,-99) , 
0, 83.4554, 1, 0, 0.491101,-99) , 
1, 251.882, 0, 0, 0.496015,-99) , 
0, 124.251, 0, 0, 0.497505,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.0161422);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515601,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489932,-99) , 
2, 2.81506, 1, 0, 0.502736,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514498,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491158,-99) , 
3, 95.4883, 0, 0, 0.500083,-99) , 
NN(
0, 
0, 
-1, 3.33393, 1, -1, 0.495432,-99) , 
3, 117.253, 1, 0, 0.49724,-99) , 
3, 60.1208, 1, 0, 0.498195,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.0164171);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50527,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505398,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481922,-99) , 
0, 136.263, 1, 0, 0.501643,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473644,-99) , 
0, 210.187, 1, 0, 0.499894,-99) , 
3, 240.087, 0, 0, 0.500539,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.0158639);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511182,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499048,-99) , 
2, 2.63949, 1, 0, 0.503614,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494306,-99) , 
3, 60.1543, 0, 0, 0.501973,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519632,-99) , 
NN(
0, 
0, 
-1, 63.0575, 0, -1, 0.492229,-99) , 
1, 251.882, 0, 0, 0.495992,-99) , 
0, 124.251, 0, 0, 0.497969,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.0144694);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511539,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509875,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494517,-99) , 
2, 2.49409, 1, 0, 0.501108,-99) , 
2, 3.2705, 0, 0, 0.50348,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53326,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499322,-99) , 
0, 82.575, 1, 0, 0.502686,-99) , 
NN(
0, 
0, 
-1, 2.81517, 1, -1, 0.478141,-99) , 
0, 72.7685, 0, 0, 0.498868,-99) , 
0, 124.251, 0, 0, 0.500393,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.0135116);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 47.8778, 0, 1, 0.512101,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488907,-99) , 
3, 31.5544, 0, 0, 0.505183,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511574,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497333,-99) , 
3, 144.239, 0, 0, 0.504431,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509126,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496731,-99) , 
2, 2.75095, 0, 0, 0.498924,-99) , 
2, 2.88835, 0, 0, 0.501656,-99) , 
3, 60.1208, 1, 0, 0.502268,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.0213785);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 247.262, 0, 1, 0.507234,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458275,-99) , 
1, 310.805, 1, 0, 0.503931,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511768,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507946,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471748,-99) , 
3, 204.585, 0, 0, 0.495204,-99) , 
3, 282.938, 0, 0, 0.499918,-99) , 
3, 180.098, 1, 0, 0.502945,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.00732071);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502031,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506461,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50043,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478416,-99) , 
0, 152.559, 1, 0, 0.497261,-99) , 
3, 240.204, 0, 0, 0.498425,-99) , 
2, 3.73229, 0, 0, 0.498806,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.0155661);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516357,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495524,-99) , 
2, 2.62722, 1, 0, 0.501104,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488575,-99) , 
2, 1.87299, 0, 0, 0.499075,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524502,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497508,-99) , 
0, 82.575, 1, 0, 0.50018,-99) , 
NN(
0, 
0, 
-1, 2.81517, 1, -1, 0.476871,-99) , 
0, 72.7685, 0, 0, 0.496553,-99) , 
0, 124.251, 0, 0, 0.497387,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.00865253);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50367,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507704,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50155,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481938,-99) , 
0, 152.559, 1, 0, 0.498728,-99) , 
3, 240.204, 0, 0, 0.499864,-99) , 
2, 3.73229, 0, 0, 0.500265,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.0174948);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509787,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513056,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490777,-99) , 
0, 134.057, 1, 0, 0.498764,-99) , 
0, 227.217, 0, 0, 0.500528,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527011,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498104,-99) , 
1, 251.882, 0, 0, 0.501778,-99) , 
NN(
0, 
0, 
-1, 140.488, 1, -1, 0.480496,-99) , 
0, 77.9167, 0, 0, 0.497631,-99) , 
0, 124.251, 0, 0, 0.498589,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.00716105);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509381,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495404,-99) , 
3, 121.795, 1, 0, 0.503961,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522449,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499435,-99) , 
2, 4.042, 0, 0, 0.501396,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492606,-99) , 
2, 2.24506, 0, 0, 0.500535,-99) , 
2, 1.8677, 1, 0, 0.50103,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.0150745);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 247.262, 0, 1, 0.505575,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463821,-99) , 
1, 310.805, 1, 0, 0.502758,-99) , 
NN(
NN(
0, 
0, 
-1, 231.522, 0, 1, 0.506263,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491093,-99) , 
2, 3.08844, 1, 0, 0.500764,-99) , 
3, 180.098, 1, 0, 0.502268,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.014999);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512001,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496563,-99) , 
3, 172.564, 0, 0, 0.501437,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516481,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484589,-99) , 
2, 4.00819, 0, 0, 0.496625,-99) , 
2, 3.39934, 1, 0, 0.500259,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501835,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49395,-99) , 
2, 1.20812, 0, 0, 0.499556,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490486,-99) , 
2, 2.11187, 1, 0, 0.497484,-99) , 
2, 2.33385, 0, 0, 0.499554,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.0108907);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505665,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494916,-99) , 
3, 76.5991, 0, 0, 0.502649,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495152,-99) , 
3, 229.538, 1, 0, 0.501528,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504855,-99) , 
NN(
0, 
0, 
-1, 2.00089, 0, -1, 0.494164,-99) , 
2, 1.33496, 1, 0, 0.497119,-99) , 
2, 2.33385, 0, 0, 0.500409,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.0128494);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 247.262, 0, 1, 0.503343,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468642,-99) , 
1, 310.805, 1, 0, 0.501004,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508421,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50354,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475987,-99) , 
3, 204.585, 0, 0, 0.493841,-99) , 
3, 282.938, 0, 0, 0.497989,-99) , 
3, 180.098, 1, 0, 0.500263,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.0117713);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520727,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495994,-99) , 
3, 98.4481, 0, 0, 0.500995,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501288,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477231,-99) , 
2, 3.37028, 1, 0, 0.496363,-99) , 
3, 114.835, 1, 0, 0.498453,-99) , 
NN(
0, 
0, 
-1, 2.00088, 0, -1, 0.495783,-99) , 
2, 2.33385, 0, 0, 0.497775,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.0171004);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516418,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502541,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470025,-99) , 
0, 152.559, 1, 0, 0.497655,-99) , 
2, 3.73817, 0, 0, 0.500229,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50747,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491506,-99) , 
2, 2.8581, 0, 0, 0.498792,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485762,-99) , 
2, 3.33393, 1, 0, 0.496501,-99) , 
3, 120.11, 1, 0, 0.498401,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.0134723);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510806,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488559,-99) , 
0, 110.359, 0, 0, 0.500985,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504981,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494893,-99) , 
2, 2.54316, 1, 0, 0.498175,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479793,-99) , 
1, 238.933, 1, 0, 0.496831,-99) , 
1, 271.433, 0, 0, 0.497306,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.0146401);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516838,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499431,-99) , 
2, 3.88767, 0, 0, 0.506919,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493137,-99) , 
3, 134.879, 1, 0, 0.501785,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511046,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511348,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493718,-99) , 
3, 194.75, 0, 0, 0.495501,-99) , 
3, 240.444, 0, 0, 0.497437,-99) , 
2, 3.26614, 0, 0, 0.498445,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.0105569);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 247.262, 0, 1, 0.503682,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474406,-99) , 
1, 310.805, 1, 0, 0.501709,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503907,-99) , 
NN(
0, 
0, 
-1, 204.585, 0, -1, 0.493663,-99) , 
3, 282.938, 0, 0, 0.496576,-99) , 
3, 180.098, 1, 0, 0.500448,-99)    );
   return;
};
 
// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
