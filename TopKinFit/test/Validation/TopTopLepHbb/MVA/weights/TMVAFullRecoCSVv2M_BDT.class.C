// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.06/01       [394753]
Creator        : kskovpen
Date           : Thu Aug 18 17:23:51 2016
Host           : Linux vocms0315.cern.ch 2.6.32-573.26.1.el6.x86_64 #1 SMP Wed May 4 09:23:05 CEST 2016 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /grid_mnt/home-pbs/kskovpen/tHFCNC2016/CMSSW_8_0_12/src/TopKinFit/test/Validation/TopTopLepHbb/MVA
Training events: 86566
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
SeparationType: "giniindex" [Separation criterion for node splitting]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
MinNodeSize: "5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "2" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 4
HiggsRecMCSVv2M               HiggsRecMCSVv2M               HiggsRecMCSVv2M               HiggsRecMCSVv2M                                                 'F'    [19.5441493988,2303.81420898]
TopLepRecMCSVv2M              TopLepRecMCSVv2M              TopLepRecMCSVv2M              TopLepRecMCSVv2M                                                'F'    [53.5424499512,2109.66748047]
HiggsTopLepRecDrCSVv2M        HiggsTopLepRecDrCSVv2M        HiggsTopLepRecDrCSVv2M        HiggsTopLepRecDrCSVv2M                                          'F'    [0.00895412359387,9.44036483765]
TopLepRecPtCSVv2M             TopLepRecPtCSVv2M             TopLepRecPtCSVv2M             TopLepRecPtCSVv2M                                               'F'    [0.44776520133,896.635620117]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTNode
   
#ifndef BDTNode__def
#define BDTNode__def
   
class BDTNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 4 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "HiggsRecMCSVv2M", "TopLepRecMCSVv2M", "HiggsTopLepRecDrCSVv2M", "TopLepRecPtCSVv2M" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[4];
   double fVmax[4];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[4];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadBDT::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(0.438408619103083);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.659676,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.230133,-99) , 
0, 154.213, 1, 0, 0.605582,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.12321,-99) , 
0, 237.094, 1, 0, 0.574573,-99) , 
NN(
0, 
0, 
-1, 177.691, 1, -1, 0.220616,-99) , 
1, 249.364, 1, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.286538);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 215.152, 1, 1, 0.679633,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544214,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.183635,-99) , 
0, 153.017, 1, 0, 0.475631,-99) , 
3, 171.15, 0, 0, 0.553173,-99) , 
NN(
0, 
0, 
-1, 176.492, 1, -1, 0.344356,-99) , 
2, 2.70364, 0, 0, 0.465526,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.290198);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.584834,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.324703,-99) , 
0, 140.903, 1, 0, 0.523334,-99) , 
NN(
0, 
0, 
-1, 111.75, 0, -1, 0.269046,-99) , 
0, 81.7006, 0, 0, 0.489143,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.141041,-99) , 
0, 237.094, 1, 0, 0.462345,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.223594);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.604513,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.397523,-99) , 
2, 2.14149, 0, 0, 0.569206,-99) , 
NN(
0, 
0, 
-1, 164.688, 1, -1, 0.411636,-99) , 
3, 171.15, 0, 0, 0.464707,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.179982,-99) , 
0, 237.094, 1, 0, 0.444222,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.159685);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535088,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.378424,-99) , 
0, 92.0601, 0, 0, 0.504797,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.254816,-99) , 
0, 237.094, 1, 0, 0.489936,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.212946,-99) , 
1, 347.275, 1, 0, 0.470297,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.138998);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.88367, 0, 1, 0.560527,-99) , 
NN(
0, 
0, 
-1, 140.913, 1, -1, 0.460406,-99) , 
3, 207.15, 0, 0, 0.483417,-99) , 
NN(
0, 
0, 
-1, 337.95, 1, -1, 0.328214,-99) , 
1, 249.364, 1, 0, 0.453383,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.13415);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534477,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.444109,-99) , 
0, 100.934, 0, 0, 0.50713,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.274533,-99) , 
0, 174.935, 1, 0, 0.489853,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.258616,-99) , 
0, 237.094, 1, 0, 0.474976,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.118206);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.568726,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48889,-99) , 
2, 3.14894, 0, 0, 0.511572,-99) , 
NN(
0, 
0, 
-1, 228.047, 1, -1, 0.399689,-99) , 
1, 212.061, 1, 0, 0.493607,-99) , 
NN(
0, 
0, 
-1, 337.95, 1, -1, 0.357443,-99) , 
1, 249.364, 1, 0, 0.467719,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.135219);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550367,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47677,-99) , 
1, 249.364, 1, 0, 0.539095,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.426389,-99) , 
0, 71.3408, 0, 0, 0.52572,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520861,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.415994,-99) , 
3, 124.623, 0, 0, 0.472711,-99) , 
NN(
0, 
0, 
-1, 297.126, 1, -1, 0.300486,-99) , 
1, 223.986, 1, 0, 0.418347,-99) , 
0, 128.319, 1, 0, 0.485735,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.0736412);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.568634,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493971,-99) , 
2, 3.60187, 0, 0, 0.503623,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.34729,-99) , 
0, 164.576, 1, 0, 0.489086,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.312016,-99) , 
0, 237.094, 1, 0, 0.478366,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.089379);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535026,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469093,-99) , 
0, 71.3408, 0, 0, 0.527581,-99) , 
NN(
0, 
0, 
-1, 1.81125, 0, -1, 0.460947,-99) , 
0, 128.319, 1, 0, 0.503599,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.330898,-99) , 
1, 347.275, 1, 0, 0.492694,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.0805641);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52393,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461554,-99) , 
3, 83.1288, 0, 0, 0.508846,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.400326,-99) , 
2, 1.35466, 0, 0, 0.500572,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.350977,-99) , 
1, 347.275, 1, 0, 0.491232,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.0561866);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507945,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443266,-99) , 
2, 1.3563, 0, 0, 0.503369,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.36235,-99) , 
0, 174.935, 1, 0, 0.493671,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.344415,-99) , 
0, 237.094, 1, 0, 0.484877,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.0605577);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528365,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487637,-99) , 
2, 3.60187, 0, 0, 0.49288,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.388313,-99) , 
0, 164.576, 1, 0, 0.483391,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.35721,-99) , 
0, 237.094, 1, 0, 0.47601,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.0903798);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534161,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453555,-99) , 
1, 140.129, 0, 0, 0.516764,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515871,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449163,-99) , 
3, 223.824, 0, 0, 0.461368,-99) , 
1, 193.413, 1, 0, 0.495223,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.374018,-99) , 
1, 347.275, 1, 0, 0.487787,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.0529779);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513626,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48801,-99) , 
0, 109.325, 0, 0, 0.502748,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.404246,-99) , 
0, 164.576, 1, 0, 0.4939,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.373972,-99) , 
0, 237.094, 1, 0, 0.486983,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.0461949);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514411,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489768,-99) , 
2, 2.70364, 1, 0, 0.499705,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.40393,-99) , 
0, 174.935, 1, 0, 0.493266,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.386455,-99) , 
0, 237.094, 1, 0, 0.487138,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.0433305);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508147,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469653,-99) , 
2, 1.80541, 0, 0, 0.503048,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.425449,-99) , 
0, 164.576, 1, 0, 0.496124,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.397464,-99) , 
0, 237.094, 1, 0, 0.490487,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.0437544);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502644,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.444487,-99) , 
1, 125.474, 0, 0, 0.498267,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533203,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440891,-99) , 
2, 3.2258, 0, 0, 0.463927,-99) , 
1, 221.387, 1, 0, 0.490648,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.399994,-99) , 
1, 347.275, 1, 0, 0.485166,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.0506751);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518739,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483186,-99) , 
1, 249.364, 0, 0, 0.489084,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.421823,-99) , 
0, 174.935, 1, 0, 0.484605,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.406355,-99) , 
0, 237.094, 1, 0, 0.480158,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.0313332);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529335,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495643,-99) , 
3, 289.831, 0, 0, 0.498776,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437816,-99) , 
1, 277.335, 1, 0, 0.494563,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.403998,-99) , 
1, 347.275, 1, 0, 0.48911,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.0346355);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513564,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49501,-99) , 
1, 181.422, 1, 0, 0.505153,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.445542,-99) , 
1, 277.335, 1, 0, 0.501041,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.411565,-99) , 
1, 347.275, 1, 0, 0.495667,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.023145);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 245.361, 0, 1, 0.504347,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454114,-99) , 
1, 277.335, 1, 0, 0.500886,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.419978,-99) , 
1, 347.275, 1, 0, 0.496039,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.0315671);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.55912,-99) , 
NN(
0, 
0, 
-1, 314.504, 1, -1, 0.487145,-99) , 
2, 4.05099, 0, 0, 0.491693,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.0343076);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 249.354, 0, 1, 0.508587,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516116,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455984,-99) , 
0, 117.902, 1, 0, 0.484576,-99) , 
2, 2.2518, 0, 0, 0.502849,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.431439,-99) , 
1, 347.275, 1, 0, 0.498586,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.0306374);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528628,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495109,-99) , 
1, 249.364, 0, 0, 0.500663,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.442889,-99) , 
0, 174.935, 1, 0, 0.496858,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.428883,-99) , 
0, 237.094, 1, 0, 0.493052,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.0334719);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511038,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487022,-99) , 
1, 149.452, 0, 0, 0.505903,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455438,-99) , 
1, 277.335, 1, 0, 0.502437,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.43581,-99) , 
1, 347.275, 1, 0, 0.498472,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.0266746);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505288,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466624,-99) , 
3, 43.1234, 0, 0, 0.50246,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448091,-99) , 
0, 174.935, 1, 0, 0.498887,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.434922,-99) , 
0, 237.094, 1, 0, 0.495313,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.0287469);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543194,-99) , 
NN(
0, 
0, 
-1, 314.504, 1, -1, 0.487569,-99) , 
2, 4.05099, 0, 0, 0.491074,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.0297826);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518305,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496893,-99) , 
2, 2.70037, 1, 0, 0.505563,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505868,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453268,-99) , 
1, 251.36, 0, 0, 0.482782,-99) , 
1, 221.387, 1, 0, 0.500554,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.446553,-99) , 
1, 347.275, 1, 0, 0.497354,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.019869);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 249.364, 0, 1, 0.50498,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46677,-99) , 
0, 164.576, 1, 0, 0.501623,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448217,-99) , 
0, 237.094, 1, 0, 0.498646,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.0365319);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 128.319, 0, 1, 0.50882,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505957,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464122,-99) , 
1, 168.397, 1, 0, 0.478675,-99) , 
3, 85.799, 0, 0, 0.501554,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522158,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487125,-99) , 
1, 164.463, 0, 0, 0.502179,-99) , 
NN(
0, 
0, 
-1, 117.902, 1, -1, 0.444499,-99) , 
1, 189.694, 1, 0, 0.474578,-99) , 
2, 2.25453, 0, 0, 0.495056,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.0258231);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535086,-99) , 
NN(
0, 
0, 
-1, 314.504, 1, -1, 0.488582,-99) , 
2, 4.05099, 0, 0, 0.491511,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.0149921);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 245.361, 0, 1, 0.502651,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460599,-99) , 
1, 277.335, 1, 0, 0.499775,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455361,-99) , 
1, 347.275, 1, 0, 0.497152,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.0301008);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527192,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504116,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482527,-99) , 
3, 171.14, 1, 0, 0.498013,-99) , 
NN(
0, 
0, 
-1, 2.70744, 0, -1, 0.438956,-99) , 
0, 176.492, 1, 0, 0.491306,-99) , 
3, 299.177, 0, 0, 0.494329,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.0231074);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505467,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49131,-99) , 
0, 128.319, 0, 0, 0.496288,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462265,-99) , 
1, 277.335, 1, 0, 0.493963,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457603,-99) , 
1, 347.275, 1, 0, 0.491819,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.0374695);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541658,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493556,-99) , 
1, 249.364, 0, 0, 0.501201,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512355,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440645,-99) , 
2, 2.71072, 0, 0, 0.482014,-99) , 
0, 133.498, 1, 0, 0.496192,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4572,-99) , 
0, 237.094, 1, 0, 0.494033,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.0235421);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507458,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49032,-99) , 
1, 213.391, 1, 0, 0.503977,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462724,-99) , 
1, 277.335, 1, 0, 0.501161,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458551,-99) , 
1, 347.275, 1, 0, 0.498655,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0404272);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 129.266, 0, 1, 0.539259,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502868,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464329,-99) , 
3, 237.566, 1, 0, 0.496782,-99) , 
1, 249.364, 0, 0, 0.503586,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547544,-99) , 
NN(
0, 
0, 
-1, 223.986, 1, -1, 0.470295,-99) , 
3, 248.519, 0, 0, 0.483543,-99) , 
0, 128.319, 1, 0, 0.496313,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.0271463);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521441,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505942,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489343,-99) , 
2, 2.70364, 1, 0, 0.496137,-99) , 
NN(
0, 
0, 
-1, 2.70744, 0, -1, 0.454783,-99) , 
0, 176.492, 1, 0, 0.491467,-99) , 
3, 299.177, 0, 0, 0.493987,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0286832);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529404,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506063,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485858,-99) , 
3, 125.353, 0, 0, 0.496936,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443298,-99) , 
1, 314.504, 1, 0, 0.492813,-99) , 
2, 4.05099, 0, 0, 0.495117,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0164436);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522253,-99) , 
NN(
0, 
0, 
-1, 314.504, 1, -1, 0.492722,-99) , 
2, 4.05099, 0, 0, 0.494581,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.0175077);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521551,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497658,-99) , 
2, 3.38207, 0, 0, 0.502137,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473924,-99) , 
3, 43.1234, 0, 0, 0.500103,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474732,-99) , 
2, 1.3563, 0, 0, 0.498174,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.0147521);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 245.361, 0, 1, 0.504854,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474754,-99) , 
1, 277.335, 1, 0, 0.502808,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47436,-99) , 
1, 347.275, 1, 0, 0.501144,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.0200042);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506176,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486654,-99) , 
2, 2.36922, 0, 0, 0.502065,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47552,-99) , 
3, 43.1234, 0, 0, 0.500152,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476573,-99) , 
2, 1.3563, 0, 0, 0.498359,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.0179623);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507764,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493545,-99) , 
2, 2.70037, 1, 0, 0.499357,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477041,-99) , 
1, 277.335, 1, 0, 0.497841,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476443,-99) , 
1, 347.275, 1, 0, 0.49659,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.0193976);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523453,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498841,-99) , 
2, 3.57447, 1, 0, 0.508737,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517227,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493164,-99) , 
3, 257.238, 0, 0, 0.496517,-99) , 
2, 3.28112, 0, 0, 0.499452,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478485,-99) , 
2, 1.3563, 0, 0, 0.497858,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0147676);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51971,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503633,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468935,-99) , 
1, 314.504, 1, 0, 0.501068,-99) , 
2, 4.05102, 0, 0, 0.502338,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483327,-99) , 
2, 1.3563, 0, 0, 0.500894,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0149272);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516023,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521656,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496755,-99) , 
1, 252.362, 0, 0, 0.499199,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470944,-99) , 
1, 314.504, 1, 0, 0.497037,-99) , 
2, 4.05099, 0, 0, 0.498233,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0290932);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514569,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485548,-99) , 
0, 153.017, 1, 0, 0.509458,-99) , 
NN(
0, 
0, 
-1, 137.466, 0, -1, 0.48188,-99) , 
1, 151.453, 0, 0, 0.504,-99) , 
NN(
NN(
0, 
0, 
-1, 240.245, 1, 1, 0.507054,-99) , 
NN(
0, 
0, 
-1, 234.18, 0, -1, 0.478874,-99) , 
2, 2.85233, 0, 0, 0.49481,-99) , 
3, 171.15, 1, 0, 0.500861,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.0412359);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 80.8821, 1, 1, 0.513173,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478113,-99) , 
1, 230.864, 1, 0, 0.504774,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523184,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480602,-99) , 
1, 229.461, 1, 0, 0.511898,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535854,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476296,-99) , 
1, 249.364, 0, 0, 0.485467,-99) , 
0, 128.319, 0, 0, 0.494938,-99) , 
2, 2.70364, 1, 0, 0.498995,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.0199145);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522072,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498729,-99) , 
1, 249.364, 0, 0, 0.502732,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472258,-99) , 
3, 43.1234, 0, 0, 0.500624,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523385,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500978,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454911,-99) , 
2, 1.61291, 0, 0, 0.480746,-99) , 
3, 74.748, 1, 0, 0.491575,-99) , 
2, 2.25453, 0, 0, 0.498449,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.0202588);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 249.364, 0, 1, 0.506003,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477224,-99) , 
3, 43.1234, 0, 0, 0.504014,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518415,-99) , 
NN(
0, 
0, 
-1, 1.61291, 0, -1, 0.480132,-99) , 
3, 74.748, 1, 0, 0.489854,-99) , 
2, 2.25453, 0, 0, 0.50061,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.0288016);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530452,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501497,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474035,-99) , 
3, 198.046, 1, 0, 0.49476,-99) , 
1, 249.364, 0, 0, 0.500464,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510877,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478778,-99) , 
1, 227.645, 1, 0, 0.502306,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.445142,-99) , 
2, 1.81343, 0, 0, 0.49337,-99) , 
0, 128.319, 1, 0, 0.497894,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.0181952);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50834,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508505,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493576,-99) , 
1, 249.364, 0, 0, 0.496025,-99) , 
NN(
0, 
0, 
-1, 2.70744, 0, -1, 0.47184,-99) , 
0, 176.492, 1, 0, 0.493311,-99) , 
3, 299.177, 0, 0, 0.494575,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.00942043);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501142,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484192,-99) , 
1, 128.139, 0, 0, 0.499869,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473039,-99) , 
1, 277.335, 1, 0, 0.49805,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482491,-99) , 
1, 347.275, 1, 0, 0.497145,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.015322);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507745,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501901,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489238,-99) , 
3, 207.936, 1, 0, 0.498829,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50199,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471716,-99) , 
3, 172.065, 0, 0, 0.48195,-99) , 
1, 227.517, 1, 0, 0.494864,-99) , 
2, 4.05099, 0, 0, 0.495675,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.0160574);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504268,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506009,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493826,-99) , 
1, 249.364, 0, 0, 0.495824,-99) , 
NN(
0, 
0, 
-1, 2.70744, 0, -1, 0.474003,-99) , 
0, 176.492, 1, 0, 0.493376,-99) , 
3, 299.177, 0, 0, 0.494292,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.00701601);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500042,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488038,-99) , 
1, 128.139, 0, 0, 0.49914,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473531,-99) , 
1, 277.335, 1, 0, 0.497405,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482886,-99) , 
1, 347.275, 1, 0, 0.49656,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.0114679);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501583,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494666,-99) , 
1, 170.765, 1, 0, 0.49765,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475281,-99) , 
1, 277.335, 1, 0, 0.496134,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484638,-99) , 
1, 347.275, 1, 0, 0.495466,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.0115602);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506305,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501207,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492504,-99) , 
3, 125.353, 0, 0, 0.497277,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473706,-99) , 
1, 314.504, 1, 0, 0.495479,-99) , 
2, 4.05099, 0, 0, 0.49616,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.0199273);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507221,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486971,-99) , 
2, 2.25773, 0, 0, 0.501796,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47723,-99) , 
0, 86.4484, 0, 0, 0.498065,-99) , 
NN(
0, 
0, 
-1, 2.85233, 0, -1, 0.491849,-99) , 
3, 171.15, 1, 0, 0.495943,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.0316398);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525464,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507435,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479657,-99) , 
3, 120.462, 1, 0, 0.493324,-99) , 
0, 98.0179, 1, 0, 0.501355,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50815,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493769,-99) , 
2, 2.97712, 0, 0, 0.503976,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506384,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462858,-99) , 
2, 3.34525, 0, 0, 0.480746,-99) , 
3, 128.475, 0, 0, 0.493688,-99) , 
2, 2.70364, 1, 0, 0.49685,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.0146629);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511887,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497856,-99) , 
2, 1.89089, 1, 0, 0.500221,-99) , 
NN(
0, 
0, 
-1, 2.06364, 0, -1, 0.486593,-99) , 
1, 227.517, 1, 0, 0.497045,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483726,-99) , 
2, 3.60187, 1, 0, 0.495352,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.0137644);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 128.319, 0, 1, 0.510384,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500818,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463891,-99) , 
0, 176.796, 1, 0, 0.496668,-99) , 
3, 214.611, 0, 0, 0.499762,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487388,-99) , 
2, 3.60187, 1, 0, 0.49819,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.013901);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513928,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492583,-99) , 
0, 128.319, 0, 0, 0.501231,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500566,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482546,-99) , 
1, 151.453, 0, 0, 0.496914,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477147,-99) , 
0, 176.796, 1, 0, 0.494722,-99) , 
3, 213.826, 0, 0, 0.496146,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.0133968);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510455,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496058,-99) , 
0, 128.319, 0, 0, 0.50189,-99) , 
NN(
0, 
0, 
-1, 249.364, 1, -1, 0.493269,-99) , 
3, 213.826, 0, 0, 0.495156,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.00957545);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509435,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498706,-99) , 
1, 249.364, 0, 0, 0.500559,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48225,-99) , 
2, 1.61607, 0, 0, 0.498622,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489012,-99) , 
3, 43.1234, 0, 0, 0.497911,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.0195766);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532212,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500013,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478787,-99) , 
1, 137.466, 0, 0, 0.48898,-99) , 
3, 171.862, 0, 0, 0.504478,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526214,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498345,-99) , 
3, 146.761, 0, 0, 0.502304,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505212,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485225,-99) , 
1, 233.784, 0, 0, 0.49061,-99) , 
3, 171.15, 1, 0, 0.498371,-99) , 
1, 151.453, 1, 0, 0.49962,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.0136436);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506814,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496911,-99) , 
2, 3.14894, 1, 0, 0.503996,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480503,-99) , 
1, 277.335, 1, 0, 0.502406,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490951,-99) , 
1, 347.275, 1, 0, 0.501741,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.0126472);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50975,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50492,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496021,-99) , 
3, 249.227, 1, 0, 0.503537,-99) , 
NN(
0, 
0, 
-1, 2.32028, 0, -1, 0.489604,-99) , 
1, 227.517, 1, 0, 0.500268,-99) , 
2, 4.05099, 0, 0, 0.500866,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.023646);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 128.319, 0, 1, 0.505564,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507088,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484571,-99) , 
2, 2.25773, 0, 0, 0.501284,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516389,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46452,-99) , 
2, 2.74742, 1, 0, 0.488953,-99) , 
0, 98.3377, 0, 0, 0.498185,-99) , 
3, 213.826, 0, 0, 0.499799,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.0253813);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52372,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510574,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490138,-99) , 
2, 2.01785, 1, 0, 0.493577,-99) , 
1, 249.364, 0, 0, 0.498389,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517612,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493478,-99) , 
2, 3.26631, 0, 0, 0.499858,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463976,-99) , 
2, 1.81343, 0, 0, 0.49427,-99) , 
0, 128.319, 1, 0, 0.496897,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.00884982);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502725,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493847,-99) , 
2, 3.59751, 1, 0, 0.501646,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481564,-99) , 
1, 277.335, 1, 0, 0.500287,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49154,-99) , 
1, 347.275, 1, 0, 0.49978,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.00703095);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505223,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510014,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499658,-99) , 
2, 3.4735, 0, 0, 0.500693,-99) , 
NN(
0, 
0, 
-1, 86.8211, 0, -1, 0.489767,-99) , 
1, 227.517, 1, 0, 0.498131,-99) , 
2, 4.05099, 0, 0, 0.498578,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.00800136);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 3.2424, 0, 1, 0.502332,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483705,-99) , 
2, 1.61607, 0, 0, 0.500364,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493589,-99) , 
3, 43.1234, 0, 0, 0.499862,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.0228276);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526608,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514709,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489599,-99) , 
3, 80.8566, 1, 0, 0.496398,-99) , 
2, 2.57532, 0, 0, 0.500784,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511316,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499552,-99) , 
3, 165.056, 1, 0, 0.502845,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50884,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476149,-99) , 
2, 3.34525, 0, 0, 0.489602,-99) , 
3, 128.475, 0, 0, 0.496982,-99) , 
2, 2.70364, 1, 0, 0.49855,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.0178017);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.5752, 0, 1, 0.512223,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504446,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48303,-99) , 
1, 216.032, 1, 0, 0.498352,-99) , 
3, 214.611, 0, 0, 0.501482,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491519,-99) , 
2, 3.60187, 1, 0, 0.500216,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.00995607);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513608,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506142,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490942,-99) , 
2, 2.55687, 1, 0, 0.499045,-99) , 
2, 3.15556, 0, 0, 0.503579,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501172,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492636,-99) , 
2, 3.14894, 1, 0, 0.498742,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480034,-99) , 
1, 230.71, 1, 0, 0.497542,-99) , 
1, 249.364, 0, 0, 0.498608,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.0106412);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50717,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498612,-99) , 
0, 128.319, 0, 0, 0.50208,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501631,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476163,-99) , 
0, 176.796, 1, 0, 0.498764,-99) , 
NN(
0, 
0, 
-1, 122.375, 0, -1, 0.487736,-99) , 
1, 151.453, 0, 0, 0.496547,-99) , 
3, 213.826, 0, 0, 0.497757,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.014381);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505884,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498986,-99) , 
3, 278.856, 1, 0, 0.502584,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501893,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480258,-99) , 
1, 249.364, 1, 0, 0.498091,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505515,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471495,-99) , 
2, 2.74742, 1, 0, 0.48752,-99) , 
0, 98.3377, 0, 0, 0.495434,-99) , 
3, 213.826, 0, 0, 0.496998,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.0182372);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513658,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496741,-99) , 
3, 317.505, 0, 0, 0.505185,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508119,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480163,-99) , 
3, 73.5821, 0, 0, 0.500477,-99) , 
NN(
0, 
0, 
-1, 176.492, 1, -1, 0.491612,-99) , 
2, 3.15556, 0, 0, 0.494134,-99) , 
3, 256.501, 0, 0, 0.495641,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.0104774);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531457,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491923,-99) , 
1, 274.673, 1, 0, 0.509715,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498307,-99) , 
1, 337.95, 1, 0, 0.505582,-99) , 
NN(
0, 
0, 
-1, 230.71, 1, -1, 0.496314,-99) , 
1, 249.364, 0, 0, 0.497951,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.00941846);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.70664, 1, 1, 0.506699,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502402,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493881,-99) , 
2, 3.14894, 1, 0, 0.499976,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483719,-99) , 
1, 230.71, 1, 0, 0.498933,-99) , 
1, 249.364, 0, 0, 0.500305,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.0167228);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 128.319, 0, 1, 0.506561,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503721,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487259,-99) , 
3, 171.126, 1, 0, 0.499798,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517332,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482839,-99) , 
3, 159.143, 0, 0, 0.492756,-99) , 
0, 98.0179, 0, 0, 0.498075,-99) , 
3, 256.501, 0, 0, 0.499232,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.0133545);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506843,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498386,-99) , 
3, 278.856, 1, 0, 0.502798,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510179,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488274,-99) , 
2, 3.45489, 0, 0, 0.501475,-99) , 
NN(
0, 
0, 
-1, 176.796, 1, -1, 0.494045,-99) , 
2, 3.15556, 0, 0, 0.496157,-99) , 
3, 213.826, 0, 0, 0.49761,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.00728085);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510543,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499619,-99) , 
2, 2.70664, 1, 0, 0.504312,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501133,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492253,-99) , 
3, 207.15, 1, 0, 0.49903,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48634,-99) , 
1, 230.71, 1, 0, 0.498216,-99) , 
1, 249.364, 0, 0, 0.499292,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.0168706);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513579,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499963,-99) , 
2, 2.98057, 1, 0, 0.506808,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498314,-99) , 
3, 246.341, 0, 0, 0.504231,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508561,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491431,-99) , 
2, 2.82422, 0, 0, 0.500263,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503699,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483973,-99) , 
2, 2.71224, 1, 0, 0.493172,-99) , 
3, 102.055, 0, 0, 0.497146,-99) , 
3, 213.826, 0, 0, 0.498696,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.0134361);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.68341, 0, 1, 0.505495,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502919,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486343,-99) , 
2, 2.02106, 0, 0, 0.500131,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510031,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489961,-99) , 
2, 3.60932, 0, 0, 0.493455,-99) , 
3, 102.055, 0, 0, 0.497197,-99) , 
3, 213.826, 0, 0, 0.499012,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.0142284);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526461,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492146,-99) , 
1, 274.673, 1, 0, 0.507587,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497794,-99) , 
1, 337.95, 1, 0, 0.504038,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504603,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494088,-99) , 
3, 166.644, 0, 0, 0.49801,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487776,-99) , 
2, 3.59751, 1, 0, 0.496769,-99) , 
1, 249.364, 0, 0, 0.498053,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.0136841);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.70664, 1, 1, 0.505555,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504176,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48618,-99) , 
1, 146.789, 0, 0, 0.500576,-99) , 
NN(
0, 
0, 
-1, 185.308, 1, -1, 0.489585,-99) , 
3, 207.15, 1, 0, 0.497994,-99) , 
1, 249.364, 0, 0, 0.499329,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.0118503);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509956,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505763,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495106,-99) , 
3, 214.611, 0, 0, 0.49745,-99) , 
2, 3.25957, 0, 0, 0.498939,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492294,-99) , 
2, 3.60187, 1, 0, 0.498094,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.0197434);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521102,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498462,-99) , 
0, 121.018, 1, 0, 0.510592,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510892,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488787,-99) , 
2, 3.67343, 0, 0, 0.494751,-99) , 
2, 2.71224, 1, 0, 0.502072,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504551,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490404,-99) , 
3, 274.793, 1, 0, 0.501477,-99) , 
NN(
0, 
0, 
-1, 1.73077, 0, -1, 0.483631,-99) , 
2, 2.41963, 0, 0, 0.49701,-99) , 
3, 128.475, 1, 0, 0.499438,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.0186832);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521598,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518004,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496641,-99) , 
2, 1.81515, 1, 0, 0.500287,-99) , 
3, 116.279, 0, 0, 0.503132,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532289,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493398,-99) , 
1, 230.864, 0, 0, 0.501948,-99) , 
NN(
0, 
0, 
-1, 142.411, 0, -1, 0.490876,-99) , 
3, 201.635, 0, 0, 0.496152,-99) , 
3, 128.475, 1, 0, 0.499501,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.00953426);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.23306, 1, 1, 0.504631,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494099,-99) , 
2, 1.54872, 0, 0, 0.503438,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495288,-99) , 
2, 3.60187, 1, 0, 0.502401,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.0151385);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.45586, 0, 1, 0.50952,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509138,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492678,-99) , 
2, 3.35305, 0, 0, 0.499441,-99) , 
2, 2.71224, 1, 0, 0.504099,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50842,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497361,-99) , 
3, 201.642, 0, 0, 0.502988,-99) , 
NN(
0, 
0, 
-1, 230.864, 1, -1, 0.492345,-99) , 
2, 2.82141, 0, 0, 0.498326,-99) , 
3, 128.475, 1, 0, 0.501096,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.0147178);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 3.03868, 1, 1, 0.510452,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502224,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484119,-99) , 
2, 2.71788, 1, 0, 0.499462,-99) , 
2, 2.85333, 0, 0, 0.502818,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50832,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488819,-99) , 
3, 65.473, 0, 0, 0.502524,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487612,-99) , 
3, 171.15, 1, 0, 0.497453,-99) , 
2, 3.15276, 1, 0, 0.501274,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.0146034);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526367,-99) , 
NN(
0, 
0, 
-1, 2.86297, 0, -1, 0.490806,-99) , 
3, 171.862, 0, 0, 0.503545,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513164,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499835,-99) , 
3, 138.633, 0, 0, 0.502443,-99) , 
NN(
0, 
0, 
-1, 240.245, 0, -1, 0.489791,-99) , 
3, 171.15, 1, 0, 0.498189,-99) , 
1, 151.453, 1, 0, 0.499285,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.00830717);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 116.279, 0, 1, 0.504056,-99) , 
NN(
NN(
0, 
0, 
-1, 99.2802, 1, 1, 0.503264,-99) , 
NN(
0, 
0, 
-1, 230.864, 1, -1, 0.4945,-99) , 
2, 2.82141, 0, 0, 0.499425,-99) , 
3, 128.475, 1, 0, 0.501647,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.0270986);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507705,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546562,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488401,-99) , 
2, 2.68595, 0, 0, 0.5196,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528483,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491547,-99) , 
1, 249.364, 0, 0, 0.497501,-99) , 
0, 154.217, 0, 0, 0.500104,-99) , 
0, 237.094, 0, 0, 0.500516,-99)    );
   return;
};
 
// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
