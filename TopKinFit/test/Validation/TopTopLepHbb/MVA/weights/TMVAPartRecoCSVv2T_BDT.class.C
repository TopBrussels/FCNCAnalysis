// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.06/01       [394753]
Creator        : kskovpen
Date           : Tue Jan 10 12:38:29 2017
Host           : Linux vocms0315.cern.ch 2.6.32-573.26.1.el6.x86_64 #1 SMP Wed May 4 09:23:05 CEST 2016 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /storage_mnt/storage/user/kskovpen/analysis/tHFCNC/CMSSW_8_0_12/src/TopKinFit/test/Validation/TopTopLepHbb/MVA
Training events: 53936
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
SeparationType: "giniindex" [Separation criterion for node splitting]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
MinNodeSize: "5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "2" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 4
HiggsRecMCSVv2T               HiggsRecMCSVv2T               HiggsRecMCSVv2T               HiggsRecMCSVv2T                                                 'F'    [20.7445049286,1676.4675293]
TopLepRecMTCSVv2T             TopLepRecMTCSVv2T             TopLepRecMTCSVv2T             TopLepRecMTCSVv2T                                               'F'    [5.85457658768,1033.75878906]
HiggsTopLepRecDphiTCSVv2T     HiggsTopLepRecDphiTCSVv2T     HiggsTopLepRecDphiTCSVv2T     HiggsTopLepRecDphiTCSVv2T                                       'F'    [-3.141507864,3.14151191711]
TopLepRecPtTCSVv2T            TopLepRecPtTCSVv2T            TopLepRecPtTCSVv2T            TopLepRecPtTCSVv2T                                              'F'    [0.583574056625,1667.81005859]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTNode
   
#ifndef BDTNode__def
#define BDTNode__def
   
class BDTNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 4 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "HiggsRecMCSVv2T", "TopLepRecMTCSVv2T", "HiggsTopLepRecDphiTCSVv2T", "TopLepRecPtTCSVv2T" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[4];
   double fVmax[4];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[4];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadBDT::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(0.463858131887429);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.662615,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.251328,-99) , 
0, 150.536, 1, 0, 0.622347,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.302848,-99) , 
0, 80.813, 0, 0, 0.584398,-99) , 
NN(
0, 
0, 
-1, 187.647, 1, -1, 0.0639734,-99) , 
0, 178.432, 1, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.269398);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 180.161, 0, 1, 0.562068,-99) , 
NN(
0, 
0, 
-1, 241.283, 1, -1, 0.285694,-99) , 
1, 201.646, 1, 0, 0.518674,-99) , 
NN(
0, 
0, 
-1, 187.647, 1, -1, 0.098029,-99) , 
0, 178.432, 1, 0, 0.458026,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.243969);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -2.24384, 1, 1, 0.602293,-99) , 
NN(
0, 
0, 
-1, 140.869, 1, -1, 0.427325,-99) , 
3, 191.413, 0, 0, 0.472109,-99) , 
NN(
0, 
0, 
-1, 143.19, 1, -1, 0.124562,-99) , 
0, 178.432, 1, 0, 0.425761,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.208689);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547976,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.415973,-99) , 
0, 95.8301, 0, 0, 0.518486,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.248705,-99) , 
1, 250.594, 1, 0, 0.501766,-99) , 
NN(
0, 
0, 
-1, 143.19, 1, -1, 0.153689,-99) , 
0, 178.432, 1, 0, 0.458317,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.160505);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516202,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.36279,-99) , 
0, 66.5063, 0, 0, 0.505323,-99) , 
NN(
0, 
0, 
-1, 127.171, 0, -1, 0.329788,-99) , 
0, 140.881, 1, 0, 0.477697,-99) , 
NN(
0, 
0, 
-1, 249.827, 1, -1, 0.182834,-99) , 
0, 178.432, 1, 0, 0.442794,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.181863);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541694,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.442732,-99) , 
2, -2.54313, 1, 0, 0.466344,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.272989,-99) , 
1, 250.594, 1, 0, 0.454699,-99) , 
NN(
0, 
0, 
-1, 249.827, 1, -1, 0.208044,-99) , 
0, 178.432, 1, 0, 0.426628,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.153827);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.603024,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492767,-99) , 
3, 115.111, 0, 0, 0.567091,-99) , 
NN(
0, 
0, 
-1, 148.39, 1, -1, 0.452024,-99) , 
2, 2.54313, 0, 0, 0.479468,-99) , 
NN(
0, 
0, 
-1, -0.44862, 1, -1, 0.239596,-99) , 
0, 178.432, 1, 0, 0.453186,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.1288);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53073,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.432585,-99) , 
1, 201.646, 1, 0, 0.516684,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.320208,-99) , 
0, 155.899, 1, 0, 0.505553,-99) , 
NN(
0, 
0, 
-1, -0.149465, 1, -1, 0.268731,-99) , 
0, 178.432, 1, 0, 0.480347,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.0965461);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.561863,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485747,-99) , 
2, 2.84232, 0, 0, 0.496243,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.379914,-99) , 
0, 148.39, 1, 0, 0.485642,-99) , 
NN(
0, 
0, 
-1, -0.149465, 1, -1, 0.294782,-99) , 
0, 178.432, 1, 0, 0.465768,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.0946337);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531025,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485132,-99) , 
0, 105.83, 0, 0, 0.513737,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.402907,-99) , 
0, 148.39, 1, 0, 0.503725,-99) , 
NN(
0, 
0, 
-1, -0.149465, 1, -1, 0.315242,-99) , 
0, 178.432, 1, 0, 0.484398,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.0950712);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524998,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449268,-99) , 
1, 221.876, 1, 0, 0.517955,-99) , 
NN(
0, 
0, 
-1, 127.803, 0, -1, 0.442983,-99) , 
0, 133.373, 1, 0, 0.500559,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.336018,-99) , 
0, 178.432, 1, 0, 0.483907,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.0905804);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.571499,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485181,-99) , 
2, -2.24393, 1, 0, 0.515655,-99) , 
NN(
0, 
0, 
-1, 133.361, 1, -1, 0.466145,-99) , 
3, 127.803, 0, 0, 0.491194,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.357549,-99) , 
0, 178.432, 1, 0, 0.47782,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.0916564);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.552354,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495009,-99) , 
3, 85.301, 0, 0, 0.540512,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517692,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440579,-99) , 
2, -1.68831, 1, 0, 0.486631,-99) , 
2, 1.94475, 0, 0, 0.505758,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.378613,-99) , 
0, 178.432, 1, 0, 0.493146,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.0657393);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545992,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496823,-99) , 
1, 110.723, 0, 0, 0.531218,-99) , 
NN(
0, 
0, 
-1, 178.432, 1, -1, 0.477483,-99) , 
2, 1.94474, 0, 0, 0.496512,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.372825,-99) , 
1, 250.594, 1, 0, 0.488485,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.0683041);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523834,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.428377,-99) , 
1, 236.616, 1, 0, 0.515457,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503036,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.433703,-99) , 
3, 137.276, 0, 0, 0.475555,-99) , 
1, 103.75, 0, 0, 0.506767,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.410265,-99) , 
0, 178.432, 1, 0, 0.497297,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.0475356);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -1.34633, 1, 1, 0.537128,-99) , 
NN(
0, 
0, 
-1, 154.877, 1, -1, 0.485002,-99) , 
3, 225.056, 0, 0, 0.494056,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.404663,-99) , 
1, 250.594, 1, 0, 0.488321,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.0491663);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 153.167, 0, 1, 0.519797,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507278,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.447212,-99) , 
2, -1.43186, 1, 0, 0.489139,-99) , 
2, 1.34636, 0, 0, 0.501812,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.416165,-99) , 
1, 250.594, 1, 0, 0.496336,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.0537701);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513428,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451046,-99) , 
1, 92.2633, 0, 0, 0.503929,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503179,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.432536,-99) , 
3, 127.803, 0, 0, 0.469462,-99) , 
0, 133.373, 1, 0, 0.496037,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.430436,-99) , 
0, 178.432, 1, 0, 0.489681,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.0479312);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509456,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47866,-99) , 
1, 114.618, 0, 0, 0.496855,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502399,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440701,-99) , 
1, 203.968, 0, 0, 0.463154,-99) , 
1, 169.006, 1, 0, 0.488498,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.422942,-99) , 
1, 250.594, 1, 0, 0.484327,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.0488288);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.553137,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481929,-99) , 
3, 136.356, 0, 0, 0.52462,-99) , 
NN(
0, 
0, 
-1, 178.605, 1, -1, 0.477927,-99) , 
2, -2.84232, 1, 0, 0.484296,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.0511817);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537772,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508498,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475783,-99) , 
0, 142.505, 1, 0, 0.501895,-99) , 
2, 2.92781, 0, 0, 0.511427,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51525,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451998,-99) , 
3, 80.9558, 0, 0, 0.503064,-99) , 
NN(
0, 
0, 
-1, 127.803, 1, -1, 0.459351,-99) , 
2, -2.00191, 1, 0, 0.483916,-99) , 
2, 1.64555, 0, 0, 0.494498,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.025488);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529276,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497904,-99) , 
3, 270.02, 0, 0, 0.50132,-99) , 
NN(
0, 
0, 
-1, 200.083, 0, -1, 0.475558,-99) , 
1, 169.006, 1, 0, 0.494947,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.444329,-99) , 
1, 250.594, 1, 0, 0.491754,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.0294098);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516576,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49748,-99) , 
2, 0.747976, 0, 0, 0.506305,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505444,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465367,-99) , 
1, 200.083, 0, 0, 0.481919,-99) , 
1, 169.006, 1, 0, 0.500274,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450631,-99) , 
1, 250.594, 1, 0, 0.497146,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.0481089);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517492,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459825,-99) , 
0, 140.869, 1, 0, 0.50945,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51205,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460655,-99) , 
2, -2.24384, 1, 0, 0.479322,-99) , 
3, 191.413, 1, 0, 0.501819,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465016,-99) , 
0, 178.432, 1, 0, 0.498298,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.0271971);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -1.04716, 1, 1, 0.519779,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501535,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467639,-99) , 
1, 93.8391, 0, 0, 0.496596,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.422958,-99) , 
0, 178.432, 1, 0, 0.489874,-99) , 
3, 238.759, 0, 0, 0.49434,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.030465);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507255,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489844,-99) , 
3, 135.35, 0, 0, 0.498221,-99) , 
NN(
0, 
0, 
-1, 200.64, 0, -1, 0.467588,-99) , 
1, 180.66, 1, 0, 0.492647,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45246,-99) , 
1, 250.594, 1, 0, 0.490125,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.0220076);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524091,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496148,-99) , 
3, 45.5707, 1, 0, 0.498508,-99) , 
NN(
0, 
0, 
-1, 200.64, 0, -1, 0.475179,-99) , 
1, 180.66, 1, 0, 0.494265,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460018,-99) , 
1, 250.594, 1, 0, 0.492118,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.0238178);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -2.98479, 0, 1, 0.517481,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502809,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452736,-99) , 
2, -2.55733, 0, 0, 0.497217,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440587,-99) , 
1, 250.594, 1, 0, 0.493651,-99) , 
2, -2.84232, 1, 0, 0.496907,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.0209561);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -2.98479, 0, 1, 0.511531,-99) , 
NN(
0, 
0, 
-1, 250.594, 1, -1, 0.48969,-99) , 
2, -2.84232, 1, 0, 0.492674,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.0264972);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530841,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498191,-99) , 
2, -1.04716, 1, 0, 0.512933,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504084,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462562,-99) , 
3, 193.367, 1, 0, 0.499139,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437955,-99) , 
0, 178.432, 1, 0, 0.493591,-99) , 
3, 238.759, 0, 0, 0.496481,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.0217743);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529583,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499939,-99) , 
2, 1.04703, 0, 0, 0.513581,-99) , 
NN(
0, 
0, 
-1, 178.432, 1, -1, 0.489599,-99) , 
3, 238.759, 0, 0, 0.493182,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.0212986);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -1.04716, 1, 1, 0.514018,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503064,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461747,-99) , 
0, 73.3044, 0, 0, 0.499535,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44987,-99) , 
0, 178.432, 1, 0, 0.495042,-99) , 
3, 238.759, 0, 0, 0.497876,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.0228862);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534525,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476724,-99) , 
3, 138.774, 0, 0, 0.510463,-99) , 
NN(
0, 
0, 
-1, 251.915, 1, -1, 0.491476,-99) , 
2, 2.84232, 0, 0, 0.494074,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.0364043);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540235,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512576,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485525,-99) , 
0, 116.551, 0, 0, 0.498389,-99) , 
0, 154.877, 0, 0, 0.503826,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525954,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494611,-99) , 
2, -2.57143, 0, 0, 0.508468,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503077,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.40909,-99) , 
0, 142.505, 1, 0, 0.481649,-99) , 
2, -1.64532, 1, 0, 0.491659,-99) , 
1, 152.698, 1, 0, 0.498881,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.0296011);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531181,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505719,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478649,-99) , 
2, -2.54313, 0, 0, 0.498833,-99) , 
0, 154.877, 0, 0, 0.503033,-99) , 
NN(
NN(
0, 
0, 
-1, 188.92, 0, 1, 0.509527,-99) , 
NN(
0, 
0, 
-1, 142.505, 1, -1, 0.476679,-99) , 
2, -1.64532, 1, 0, 0.488941,-99) , 
1, 152.698, 1, 0, 0.497306,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.0157685);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -2.98479, 0, 1, 0.512812,-99) , 
NN(
0, 
0, 
-1, 250.594, 1, -1, 0.492897,-99) , 
2, -2.84232, 1, 0, 0.495618,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.0302397);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534227,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535722,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487679,-99) , 
1, 181.824, 0, 0, 0.497315,-99) , 
0, 142.505, 0, 0, 0.504817,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504305,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484081,-99) , 
0, 99.5885, 0, 0, 0.499461,-99) , 
NN(
0, 
0, 
-1, 0.61364, 0, -1, 0.46934,-99) , 
2, -0.363328, 1, 0, 0.49404,-99) , 
2, 1.34636, 0, 0, 0.498483,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.0321468);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 142.505, 0, 1, 0.514397,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501864,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470646,-99) , 
3, 65.237, 0, 0, 0.485546,-99) , 
3, 90.9637, 0, 0, 0.506892,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540057,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481786,-99) , 
2, -2.07298, 0, 0, 0.506495,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500907,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457636,-99) , 
2, -1.432, 1, 0, 0.487672,-99) , 
0, 99.5885, 1, 0, 0.492168,-99) , 
2, 1.34636, 0, 0, 0.498237,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0328996);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531074,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528904,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490942,-99) , 
2, 2.99906, 0, 0, 0.496459,-99) , 
0, 81.7203, 1, 0, 0.500619,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514389,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482655,-99) , 
3, 160.517, 0, 0, 0.495817,-99) , 
NN(
0, 
0, 
-1, 123.378, 1, -1, 0.477494,-99) , 
2, -2.2012, 1, 0, 0.488791,-99) , 
2, 0.149598, 0, 0, 0.494598,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.0220034);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522873,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509687,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487737,-99) , 
2, 2.14435, 0, 0, 0.502294,-99) , 
0, 81.7203, 1, 0, 0.504765,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503486,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488868,-99) , 
2, -2.55985, 0, 0, 0.495745,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475365,-99) , 
2, -1.10417, 1, 0, 0.492804,-99) , 
2, 0.149598, 0, 0, 0.498678,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0158599);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 45.5707, 1, 1, 0.503311,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505199,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455048,-99) , 
1, 200.64, 0, 0, 0.482474,-99) , 
1, 180.66, 1, 0, 0.499528,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47683,-99) , 
1, 250.594, 1, 0, 0.498123,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0309724);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516367,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460241,-99) , 
0, 142.505, 1, 0, 0.504566,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509193,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467964,-99) , 
3, 138.774, 0, 0, 0.491385,-99) , 
2, 2.71415, 1, 0, 0.499642,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501706,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475333,-99) , 
3, 81.1858, 0, 0, 0.496846,-99) , 
NN(
0, 
0, 
-1, 123.378, 1, -1, 0.481683,-99) , 
2, -2.2012, 1, 0, 0.491033,-99) , 
2, 0.149598, 0, 0, 0.49526,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.0504307);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513291,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457362,-99) , 
3, 191.413, 1, 0, 0.50042,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539197,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.414042,-99) , 
2, 1.78786, 0, 0, 0.470624,-99) , 
0, 155.049, 1, 0, 0.496025,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51133,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485053,-99) , 
2, -2.97735, 0, 0, 0.497415,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468448,-99) , 
2, -2.82808, 1, 0, 0.485981,-99) , 
2, -2.54312, 0, 0, 0.49366,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.0224413);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513704,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49571,-99) , 
2, -1.04716, 1, 0, 0.503856,-99) , 
NN(
0, 
0, 
-1, 178.432, 1, -1, 0.488315,-99) , 
3, 238.759, 0, 0, 0.490628,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.0330525);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507903,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520076,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486988,-99) , 
3, 114.886, 1, 0, 0.50155,-99) , 
NN(
0, 
0, 
-1, 1.64554, 0, -1, 0.480131,-99) , 
0, 125.864, 1, 0, 0.494203,-99) , 
0, 178.432, 0, 0, 0.495481,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.0215553);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524073,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498708,-99) , 
2, 0.747861, 0, 0, 0.510762,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504335,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481977,-99) , 
0, 133.373, 1, 0, 0.49942,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456959,-99) , 
0, 178.432, 1, 0, 0.495616,-99) , 
3, 238.759, 0, 0, 0.497869,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.0146074);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -1.04716, 1, 1, 0.511032,-99) , 
NN(
0, 
0, 
-1, 178.432, 1, -1, 0.493348,-99) , 
3, 238.759, 0, 0, 0.495978,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0155275);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -1.04716, 1, 1, 0.507381,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5029,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469528,-99) , 
0, 73.3044, 0, 0, 0.500052,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465946,-99) , 
0, 178.432, 1, 0, 0.497,-99) , 
3, 238.759, 0, 0, 0.498544,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0232925);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508971,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505784,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482244,-99) , 
2, 2.24394, 1, 0, 0.499032,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500906,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46917,-99) , 
0, 111.308, 1, 0, 0.480776,-99) , 
3, 191.413, 1, 0, 0.494411,-99) , 
0, 178.432, 0, 0, 0.495766,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0158323);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513494,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497075,-99) , 
2, -1.04716, 1, 0, 0.504506,-99) , 
NN(
0, 
0, 
-1, 178.432, 1, -1, 0.492048,-99) , 
3, 238.759, 0, 0, 0.4939,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.0176988);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527175,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501761,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485962,-99) , 
2, -1.64555, 0, 0, 0.49556,-99) , 
0, 178.432, 0, 0, 0.498249,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48329,-99) , 
1, 250.594, 1, 0, 0.497325,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.0309838);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 156.752, 0, 1, 0.507237,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486375,-99) , 
3, 81.1858, 0, 0, 0.503449,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504441,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476204,-99) , 
3, 191.413, 1, 0, 0.497906,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542278,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.390471,-99) , 
2, 1.8591, 0, 0, 0.466269,-99) , 
0, 155.049, 1, 0, 0.49333,-99) , 
2, -2.24393, 1, 0, 0.496428,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.0319573);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521116,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502708,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455086,-99) , 
2, -1.34626, 1, 0, 0.487895,-99) , 
2, 2.24396, 0, 0, 0.499885,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502816,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472462,-99) , 
2, 1.94474, 1, 0, 0.492804,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461264,-99) , 
0, 154.877, 1, 0, 0.488253,-99) , 
3, 159.367, 0, 0, 0.492446,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.0329302);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505655,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53614,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4705,-99) , 
0, 118.368, 1, 0, 0.508487,-99) , 
NN(
0, 
0, 
-1, 182.975, 1, -1, 0.485037,-99) , 
1, 201.646, 0, 0, 0.488353,-99) , 
0, 178.432, 0, 0, 0.489956,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.026594);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527063,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502478,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48511,-99) , 
2, -1.64555, 0, 0, 0.495459,-99) , 
0, 154.877, 0, 0, 0.499483,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513996,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4853,-99) , 
1, 168.681, 1, 0, 0.494984,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466212,-99) , 
1, 236.609, 1, 0, 0.489521,-99) , 
1, 152.698, 1, 0, 0.495437,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.0145186);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515567,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496819,-99) , 
2, 0.747861, 0, 0, 0.505731,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500422,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477418,-99) , 
1, 93.8391, 0, 0, 0.497061,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459582,-99) , 
0, 178.432, 1, 0, 0.493713,-99) , 
3, 238.759, 0, 0, 0.495496,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.0159793);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513362,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499748,-99) , 
2, -1.04716, 1, 0, 0.505911,-99) , 
NN(
0, 
0, 
-1, 178.432, 1, -1, 0.491697,-99) , 
3, 238.759, 0, 0, 0.493805,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.0200043);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516625,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50497,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487249,-99) , 
2, -2.77127, 1, 0, 0.499569,-99) , 
2, -2.54329, 0, 0, 0.503503,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518459,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494953,-99) , 
1, 201.646, 0, 0, 0.498476,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470902,-99) , 
0, 155.049, 1, 0, 0.494507,-99) , 
2, -2.24393, 1, 0, 0.497263,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.0225059);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527743,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506337,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491588,-99) , 
0, 116.551, 0, 0, 0.498604,-99) , 
0, 154.877, 0, 0, 0.50231,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509505,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490539,-99) , 
1, 176.672, 1, 0, 0.499518,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471604,-99) , 
1, 236.609, 1, 0, 0.494225,-99) , 
1, 152.698, 1, 0, 0.499028,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.0278727);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 137.831, 1, 1, 0.520156,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514151,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473686,-99) , 
2, -2.71424, 1, 0, 0.491253,-99) , 
2, 1.34641, 0, 0, 0.504101,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504433,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473846,-99) , 
1, 93.832, 0, 0, 0.500876,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47088,-99) , 
0, 154.877, 1, 0, 0.496557,-99) , 
3, 159.367, 0, 0, 0.499276,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.0214295);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.24371, 0, 1, 0.510586,-99) , 
NN(
0, 
0, 
-1, 0.448922, 0, -1, 0.485717,-99) , 
1, 152.698, 1, 0, 0.501514,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514217,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493558,-99) , 
3, 75.121, 1, 0, 0.496386,-99) , 
NN(
0, 
0, 
-1, -1.34656, 0, -1, 0.48144,-99) , 
3, 61.068, 0, 0, 0.492981,-99) , 
3, 159.367, 0, 0, 0.496056,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.0176552);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510003,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535113,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489013,-99) , 
0, 118.368, 1, 0, 0.515711,-99) , 
NN(
0, 
0, 
-1, 182.975, 1, -1, 0.493968,-99) , 
1, 201.646, 0, 0, 0.497041,-99) , 
0, 178.432, 0, 0, 0.498236,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.0228018);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533842,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522377,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495634,-99) , 
0, 140.881, 0, 0, 0.499495,-99) , 
0, 178.432, 0, 0, 0.502684,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523864,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490748,-99) , 
2, -1.43233, 0, 0, 0.505639,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479142,-99) , 
2, 1.34586, 1, 0, 0.496382,-99) , 
3, 79.9753, 0, 0, 0.50118,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.0162976);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 178.432, 0, 1, 0.505834,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516284,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504606,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467533,-99) , 
3, 49.5469, 1, 0, 0.490533,-99) , 
3, 64.8495, 0, 0, 0.498747,-99) , 
3, 79.9753, 0, 0, 0.504143,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.0133185);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 154.877, 0, 1, 0.503775,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50888,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473532,-99) , 
2, 0.448855, 0, 0, 0.490245,-99) , 
1, 180.66, 1, 0, 0.501326,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489049,-99) , 
1, 250.594, 1, 0, 0.500571,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.0249707);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.556014,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49377,-99) , 
0, 80.2817, 1, 0, 0.510855,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469297,-99) , 
0, 65.7967, 0, 0, 0.502089,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511569,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481668,-99) , 
3, 90.9637, 0, 0, 0.504711,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500063,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472202,-99) , 
2, -0.477291, 1, 0, 0.492809,-99) , 
2, 1.94475, 0, 0, 0.497001,-99) , 
0, 99.5885, 1, 0, 0.498247,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.021627);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 80.2817, 1, 1, 0.513677,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47552,-99) , 
0, 65.7967, 0, 0, 0.505631,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51393,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495742,-99) , 
2, 2.91358, 0, 0, 0.501332,-99) , 
NN(
0, 
0, 
-1, 174.682, 1, -1, 0.489815,-99) , 
2, 1.94475, 0, 0, 0.493872,-99) , 
0, 99.5885, 1, 0, 0.496751,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.0195265);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529687,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496948,-99) , 
0, 80.8119, 1, 0, 0.511214,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500619,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473633,-99) , 
0, 174.682, 1, 0, 0.497015,-99) , 
0, 99.5885, 1, 0, 0.500487,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528446,-99) , 
NN(
0, 
0, 
-1, 109.282, 0, -1, 0.483208,-99) , 
0, 135.831, 0, 0, 0.494969,-99) , 
2, 2.54313, 1, 0, 0.499184,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.0194759);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53002,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499234,-99) , 
2, -0.705688, 0, 0, 0.511814,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479505,-99) , 
2, 2.54213, 1, 0, 0.504142,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50719,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490038,-99) , 
3, 90.9637, 0, 0, 0.503256,-99) , 
NN(
0, 
0, 
-1, 174.682, 1, -1, 0.491641,-99) , 
2, 1.94475, 0, 0, 0.495731,-99) , 
0, 99.5885, 1, 0, 0.49779,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.025308);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 80.2817, 1, 1, 0.512821,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480361,-99) , 
0, 65.7967, 0, 0, 0.505978,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509401,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456583,-99) , 
0, 162.903, 1, 0, 0.500819,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500648,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487186,-99) , 
2, 1.34645, 0, 0, 0.493146,-99) , 
3, 159.367, 1, 0, 0.497957,-99) , 
0, 99.5885, 1, 0, 0.49992,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.0241455);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -2.43331, 1, 1, 0.510484,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504102,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48647,-99) , 
2, -2.89733, 1, 0, 0.495915,-99) , 
2, -2.62869, 0, 0, 0.501892,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5108,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487576,-99) , 
2, 1.93061, 1, 0, 0.497888,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475059,-99) , 
0, 155.049, 1, 0, 0.494614,-99) , 
2, -1.94474, 1, 0, 0.497205,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.0186142);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510591,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530435,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489585,-99) , 
0, 118.368, 1, 0, 0.513245,-99) , 
NN(
0, 
0, 
-1, 269.95, 1, -1, 0.492936,-99) , 
1, 201.646, 0, 0, 0.495805,-99) , 
0, 178.432, 0, 0, 0.497163,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.0203592);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543709,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490853,-99) , 
0, 66.5094, 0, 0, 0.517272,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506484,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483043,-99) , 
0, 91.5418, 0, 0, 0.495168,-99) , 
0, 80.8141, 1, 0, 0.504814,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523253,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497871,-99) , 
0, 174.681, 0, 0, 0.500726,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513658,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462755,-99) , 
2, -0.448609, 1, 0, 0.487652,-99) , 
1, 201.646, 1, 0, 0.498798,-99) , 
0, 99.5885, 1, 0, 0.50027,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.0120727);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 178.432, 0, 1, 0.504992,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480607,-99) , 
1, 215.621, 1, 0, 0.503594,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490618,-99) , 
1, 250.594, 1, 0, 0.502799,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.0135517);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51489,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510594,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497108,-99) , 
3, 180.984, 0, 0, 0.501177,-99) , 
2, 1.14718, 1, 0, 0.502947,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507172,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496872,-99) , 
2, -2.72366, 0, 0, 0.502081,-99) , 
NN(
0, 
0, 
-1, 82.4468, 1, -1, 0.488221,-99) , 
2, -1.88776, 1, 0, 0.498092,-99) , 
2, 0.149598, 0, 0, 0.500475,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.0221193);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52198,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532417,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491391,-99) , 
1, 181.824, 0, 0, 0.499618,-99) , 
0, 142.505, 0, 0, 0.504088,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529211,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491013,-99) , 
0, 80.8119, 1, 0, 0.507301,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501301,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476513,-99) , 
2, -0.363555, 1, 0, 0.496876,-99) , 
0, 99.5885, 1, 0, 0.499369,-99) , 
2, 1.34636, 0, 0, 0.501318,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.0175663);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517165,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50734,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48508,-99) , 
1, 201.646, 1, 0, 0.504092,-99) , 
0, 81.7203, 1, 0, 0.505652,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506157,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494258,-99) , 
3, 160.517, 0, 0, 0.499183,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501194,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478191,-99) , 
1, 146.488, 1, 0, 0.489534,-99) , 
2, -2.2012, 1, 0, 0.495496,-99) , 
2, 0.149598, 0, 0, 0.500481,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.0124461);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512738,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50336,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49016,-99) , 
2, 2.00207, 0, 0, 0.500857,-99) , 
2, 1.14718, 1, 0, 0.50239,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504483,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495393,-99) , 
1, 136.954, 0, 0, 0.499939,-99) , 
NN(
0, 
0, 
-1, 146.488, 1, -1, 0.489593,-99) , 
2, -2.2012, 1, 0, 0.495986,-99) , 
2, 0.149598, 0, 0, 0.499129,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.0231058);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -0.962238, 0, 1, 0.510912,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489829,-99) , 
2, 1.94386, 1, 0, 0.50339,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507101,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476699,-99) , 
3, 191.413, 1, 0, 0.498895,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485646,-99) , 
0, 174.681, 1, 0, 0.497196,-99) , 
0, 99.5885, 1, 0, 0.498711,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.0147263);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 119.264, 0, 1, 0.508293,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486522,-99) , 
0, 73.3054, 0, 0, 0.501736,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506052,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496146,-99) , 
1, 137.831, 1, 0, 0.501196,-99) , 
NN(
0, 
0, 
-1, 203.049, 1, -1, 0.492585,-99) , 
2, 1.94475, 0, 0, 0.495618,-99) , 
0, 99.5885, 1, 0, 0.497115,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.0140692);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510912,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499075,-99) , 
2, -1.04716, 1, 0, 0.50444,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50395,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491587,-99) , 
0, 125.864, 1, 0, 0.499867,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473306,-99) , 
0, 178.432, 1, 0, 0.497513,-99) , 
3, 238.759, 0, 0, 0.498539,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.0142623);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507037,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53681,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49497,-99) , 
2, 1.34645, 0, 0, 0.511674,-99) , 
NN(
0, 
0, 
-1, 182.975, 1, -1, 0.494598,-99) , 
1, 201.646, 0, 0, 0.497007,-99) , 
0, 178.432, 0, 0, 0.497925,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.0126899);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.747861, 0, 1, 0.507231,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503291,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486078,-99) , 
0, 73.3044, 0, 0, 0.501832,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473258,-99) , 
0, 178.432, 1, 0, 0.4993,-99) , 
3, 238.759, 0, 0, 0.500473,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.0139678);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509432,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49919,-99) , 
2, 0.747861, 0, 0, 0.504058,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504408,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493015,-99) , 
2, -1.04717, 0, 0, 0.499419,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473733,-99) , 
1, 229.084, 1, 0, 0.497179,-99) , 
3, 238.759, 0, 0, 0.498197,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.0146669);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -2.79967, 0, 1, 0.506274,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494069,-99) , 
0, 99.5885, 0, 0, 0.503324,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502519,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478479,-99) , 
0, 135.865, 1, 0, 0.499018,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476779,-99) , 
0, 155.049, 1, 0, 0.495853,-99) , 
2, -2.24393, 1, 0, 0.498145,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.0158984);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507154,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528374,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493905,-99) , 
0, 66.5094, 0, 0, 0.511108,-99) , 
NN(
0, 
0, 
-1, 255.022, 1, -1, 0.493193,-99) , 
0, 80.813, 1, 0, 0.495296,-99) , 
0, 178.432, 0, 0, 0.49638,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.0169115);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 138.227, 1, 1, 0.508251,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505654,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49371,-99) , 
1, 129.756, 0, 0, 0.500369,-99) , 
2, -2.79967, 0, 0, 0.504309,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50672,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492464,-99) , 
2, 2.11573, 1, 0, 0.499889,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479211,-99) , 
0, 155.049, 1, 0, 0.496946,-99) , 
2, -2.24393, 1, 0, 0.499205,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.00912241);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.747861, 0, 1, 0.505558,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501297,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490624,-99) , 
3, 57.2845, 0, 0, 0.499686,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476352,-99) , 
0, 178.432, 1, 0, 0.497619,-99) , 
3, 238.759, 0, 0, 0.498794,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.0143298);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506853,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53229,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494383,-99) , 
2, 1.34645, 0, 0, 0.509516,-99) , 
NN(
0, 
0, 
-1, 182.975, 1, -1, 0.494294,-99) , 
1, 201.646, 0, 0, 0.496441,-99) , 
0, 178.432, 0, 0, 0.497392,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.0159207);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521286,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502259,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483553,-99) , 
2, 2.84231, 1, 0, 0.499484,-99) , 
0, 154.877, 0, 0, 0.502228,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505847,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487969,-99) , 
0, 103.008, 0, 0, 0.500648,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479309,-99) , 
1, 236.609, 1, 0, 0.496623,-99) , 
1, 152.698, 1, 0, 0.499953,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.0188781);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534859,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504668,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486442,-99) , 
3, 115.111, 1, 0, 0.492799,-99) , 
0, 140.574, 0, 0, 0.50185,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502568,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493558,-99) , 
0, 99.5885, 0, 0, 0.500419,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50134,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448982,-99) , 
0, 155.049, 1, 0, 0.493437,-99) , 
2, -2.37217, 1, 0, 0.496249,-99) , 
2, 2.24394, 0, 0, 0.497958,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.0221218);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530159,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501143,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487337,-99) , 
2, 2.79962, 1, 0, 0.494225,-99) , 
0, 140.574, 0, 0, 0.501955,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518767,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487202,-99) , 
0, 80.8119, 1, 0, 0.500895,-99) , 
NN(
0, 
0, 
-1, -0.0642354, 1, -1, 0.490834,-99) , 
0, 99.5885, 1, 0, 0.493287,-99) , 
2, 2.24394, 0, 0, 0.495931,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.00839552);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.747861, 0, 1, 0.505441,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500836,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486134,-99) , 
0, 73.3044, 0, 0, 0.499591,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474994,-99) , 
0, 178.432, 1, 0, 0.497414,-99) , 
3, 238.759, 0, 0, 0.498601,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.0109078);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508748,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49845,-99) , 
2, 0.747861, 0, 0, 0.503342,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501595,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493582,-99) , 
1, 137.831, 0, 0, 0.497848,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477088,-99) , 
0, 178.432, 1, 0, 0.49601,-99) , 
3, 238.759, 0, 0, 0.497095,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.0191254);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520601,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506284,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492359,-99) , 
0, 103.777, 1, 0, 0.496872,-99) , 
0, 154.877, 0, 0, 0.499853,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513032,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49227,-99) , 
1, 160.689, 1, 0, 0.496029,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481432,-99) , 
1, 236.609, 1, 0, 0.493276,-99) , 
1, 152.698, 1, 0, 0.497183,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.0162108);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507463,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515905,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491506,-99) , 
0, 127.942, 0, 0, 0.500297,-99) , 
3, 160.517, 0, 0, 0.503281,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513388,-99) , 
NN(
0, 
0, 
-1, 155.049, 1, -1, 0.493816,-99) , 
2, 2.88507, 0, 0, 0.497207,-99) , 
2, -2.24393, 1, 0, 0.499071,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.00867167);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506791,-99) , 
NN(
NN(
0, 
0, 
-1, 1.34645, 0, 1, 0.514389,-99) , 
NN(
0, 
0, 
-1, 182.975, 1, -1, 0.497602,-99) , 
1, 201.646, 0, 0, 0.49997,-99) , 
0, 178.432, 0, 0, 0.500591,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.017222);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518019,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504351,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486415,-99) , 
1, 102.751, 0, 0, 0.500711,-99) , 
1, 82.7661, 1, 0, 0.503905,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506094,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486829,-99) , 
3, 185.178, 1, 0, 0.501742,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485812,-99) , 
1, 236.609, 1, 0, 0.49874,-99) , 
1, 152.698, 1, 0, 0.501808,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.00966958);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.747861, 0, 1, 0.506009,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508558,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498746,-99) , 
3, 170.686, 0, 0, 0.500744,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475873,-99) , 
0, 178.432, 1, 0, 0.498546,-99) , 
3, 238.759, 0, 0, 0.499649,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.0144592);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516632,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503835,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484675,-99) , 
3, 135.387, 1, 0, 0.493663,-99) , 
1, 80.44, 1, 0, 0.504432,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502793,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486854,-99) , 
1, 236.616, 1, 0, 0.501186,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507799,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486003,-99) , 
2, 2.79964, 1, 0, 0.493917,-99) , 
2, 2.54313, 1, 0, 0.499536,-99) , 
1, 103.75, 1, 0, 0.500587,-99)    );
   return;
};
 
// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
