// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.06/01       [394753]
Creator        : kskovpen
Date           : Tue Jan 10 11:58:30 2017
Host           : Linux vocms0315.cern.ch 2.6.32-573.26.1.el6.x86_64 #1 SMP Wed May 4 09:23:05 CEST 2016 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /storage_mnt/storage/user/kskovpen/analysis/tHFCNC/CMSSW_8_0_12/src/TopKinFit/test/Validation/TopTopLepHbb/MVA
Training events: 114940
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
SeparationType: "giniindex" [Separation criterion for node splitting]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
MinNodeSize: "5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "2" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 4
HiggsRecMTruth                HiggsRecMTruth                HiggsRecMTruth                HiggsRecMTruth                                                  'F'    [20.4077758789,1838.04516602]
TopLepRecMTruth               TopLepRecMTruth               TopLepRecMTruth               TopLepRecMTruth                                                 'F'    [55.0707855225,1885.03088379]
HiggsTopLepRecDrTruth         HiggsTopLepRecDrTruth         HiggsTopLepRecDrTruth         HiggsTopLepRecDrTruth                                           'F'    [0.007962083444,11.0282821655]
TopLepRecPtTruth              TopLepRecPtTruth              TopLepRecPtTruth              TopLepRecPtTruth                                                'F'    [0.301320105791,904.994628906]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTNode
   
#ifndef BDTNode__def
#define BDTNode__def
   
class BDTNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 4 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "HiggsRecMTruth", "TopLepRecMTruth", "HiggsTopLepRecDrTruth", "TopLepRecPtTruth" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[4];
   double fVmax[4];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[4];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadBDT::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(0.527082543862132);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.706755,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.256154,-99) , 
0, 152.379, 1, 0, 0.660959,-99) , 
NN(
0, 
0, 
-1, 308.199, 1, -1, 0.320176,-99) , 
1, 229.353, 1, 0, 0.580145,-99) , 
NN(
0, 
0, 
-1, 271.833, 1, -1, 0.0369886,-99) , 
0, 193.516, 1, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.319283);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.77168, 0, 1, 0.776012,-99) , 
NN(
0, 
0, 
-1, 78.1102, 0, -1, 0.447742,-99) , 
3, 172.651, 0, 0, 0.536194,-99) , 
NN(
0, 
0, 
-1, 271.833, 1, -1, 0.06109,-99) , 
0, 193.516, 1, 0, 0.475225,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.452869);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.680788,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.356385,-99) , 
0, 144.059, 1, 0, 0.622766,-99) , 
NN(
0, 
0, 
-1, 61.6206, 0, -1, 0.236638,-99) , 
0, 78.1105, 0, 0, 0.575376,-99) , 
NN(
0, 
0, 
-1, 205.438, 1, -1, 0.08218,-99) , 
0, 193.516, 1, 0, 0.518079,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.300933);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 120.005, 0, 1, 0.78562,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.635857,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.42586,-99) , 
2, 3.15663, 0, 0, 0.486694,-99) , 
3, 215.73, 0, 0, 0.528678,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.123443,-99) , 
0, 193.516, 1, 0, 0.486361,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.255502);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 129.572, 0, 1, 0.597341,-99) , 
NN(
0, 
0, 
-1, 66.3339, 0, -1, 0.383054,-99) , 
0, 94.5969, 0, 0, 0.546855,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.159858,-99) , 
0, 193.516, 1, 0, 0.509352,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.243409);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.642735,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47049,-99) , 
3, 124.563, 0, 0, 0.54794,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.243315,-99) , 
0, 176.059, 1, 0, 0.514952,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.182503,-99) , 
1, 316.494, 1, 0, 0.484682,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.180068);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 248.792, 0, 1, 0.555111,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.290867,-99) , 
0, 176.059, 1, 0, 0.527612,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.22165,-99) , 
1, 316.494, 1, 0, 0.501131,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.172825);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.724211,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.653635,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462608,-99) , 
2, 3.69234, 0, 0, 0.482985,-99) , 
NN(
0, 
0, 
-1, 203.517, 1, -1, 0.248494,-99) , 
0, 169.687, 1, 0, 0.453372,-99) , 
3, 258.785, 0, 0, 0.472096,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.15269);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 213.062, 0, 1, 0.566744,-99) , 
NN(
0, 
0, 
-1, 157.956, 1, -1, 0.445722,-99) , 
2, 2.63185, 0, 0, 0.522288,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.271728,-99) , 
1, 316.494, 1, 0, 0.501784,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.143529);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542507,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.334526,-99) , 
0, 164.076, 1, 0, 0.528425,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.340019,-99) , 
0, 69.8672, 0, 0, 0.51295,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.298724,-99) , 
0, 193.516, 1, 0, 0.49557,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.1014);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.716646,-99) , 
NN(
0, 
0, 
-1, 162.824, 1, -1, 0.475539,-99) , 
3, 255.615, 0, 0, 0.490865,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.290893,-99) , 
1, 316.494, 1, 0, 0.474802,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.105261);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.695611,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517929,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.380908,-99) , 
0, 162.824, 1, 0, 0.50087,-99) , 
3, 255.615, 0, 0, 0.513022,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.312244,-99) , 
1, 316.494, 1, 0, 0.497154,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.0781674);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.672876,-99) , 
NN(
0, 
0, 
-1, 266.697, 1, -1, 0.481065,-99) , 
3, 255.615, 0, 0, 0.492838,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.335283,-99) , 
1, 316.494, 1, 0, 0.480565,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.111007);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 213.062, 0, 1, 0.535035,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.345986,-99) , 
0, 68.2005, 0, 0, 0.522124,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519926,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.369914,-99) , 
1, 266.898, 1, 0, 0.465104,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.348092,-99) , 
1, 308.199, 1, 0, 0.424726,-99) , 
1, 229.353, 1, 0, 0.497879,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.0986979);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.758604,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.394893,-99) , 
2, 2.87694, 0, 0, 0.579971,-99) , 
NN(
0, 
0, 
-1, 169.687, 1, -1, 0.468143,-99) , 
3, 215.704, 0, 0, 0.480949,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.120296);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.576949,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467047,-99) , 
0, 102.84, 0, 0, 0.529872,-99) , 
NN(
0, 
0, 
-1, 2.76451, 0, -1, 0.452841,-99) , 
0, 135.813, 1, 0, 0.512128,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.387712,-99) , 
0, 193.516, 1, 0, 0.502744,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.0898512);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.62504,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526681,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.427904,-99) , 
1, 142.212, 0, 0, 0.512449,-99) , 
NN(
0, 
0, 
-1, 111.064, 0, -1, 0.409788,-99) , 
0, 169.687, 1, 0, 0.500894,-99) , 
3, 258.785, 0, 0, 0.508404,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.0769727);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.625925,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511486,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.404375,-99) , 
1, 130.801, 0, 0, 0.500573,-99) , 
3, 213.062, 0, 0, 0.514203,-99) , 
NN(
0, 
0, 
-1, 106.962, 1, -1, 0.440673,-99) , 
1, 229.353, 1, 0, 0.496082,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.0851346);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.678672,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.581915,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477764,-99) , 
2, 3.83141, 0, 0, 0.487309,-99) , 
3, 255.615, 0, 0, 0.498379,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.402294,-99) , 
2, 1.58229, 0, 0, 0.488928,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.110955);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 240.261, 0, 1, 0.544779,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.399505,-99) , 
2, 1.99193, 0, 0, 0.524,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545123,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458906,-99) , 
2, 2.66284, 1, 0, 0.495627,-99) , 
NN(
0, 
0, 
-1, 57.7385, 0, -1, 0.401695,-99) , 
0, 132.753, 1, 0, 0.466109,-99) , 
3, 86.4626, 0, 0, 0.504685,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.0603407);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 213.062, 0, 1, 0.520059,-99) , 
NN(
0, 
0, 
-1, 225.795, 0, -1, 0.4622,-99) , 
1, 204.454, 1, 0, 0.501867,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.414102,-99) , 
1, 316.494, 1, 0, 0.495318,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.0561719);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.557771,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537305,-99) , 
NN(
0, 
0, 
-1, 169.687, 1, -1, 0.476881,-99) , 
3, 215.946, 0, 0, 0.483867,-99) , 
2, 3.6814, 0, 0, 0.491248,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.048286);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.624444,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507789,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449967,-99) , 
0, 84.9984, 0, 0, 0.498701,-99) , 
3, 255.615, 0, 0, 0.505695,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.442776,-99) , 
2, 1.58229, 0, 0, 0.49956,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.0593213);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521026,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478151,-99) , 
1, 200.901, 1, 0, 0.505318,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.41746,-99) , 
1, 129.762, 0, 0, 0.498329,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.427834,-99) , 
1, 316.494, 1, 0, 0.49307,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.0465248);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.578629,-99) , 
NN(
0, 
0, 
-1, 142.212, 0, -1, 0.487687,-99) , 
2, 3.55801, 0, 0, 0.497395,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.441735,-99) , 
3, 43.382, 0, 0, 0.491878,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.0451043);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.567246,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507957,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449845,-99) , 
1, 142.212, 0, 0, 0.499316,-99) , 
2, 3.55801, 0, 0, 0.506547,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453237,-99) , 
3, 43.382, 0, 0, 0.501272,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.0234109);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.564909,-99) , 
NN(
0, 
0, 
-1, 67.8798, 0, -1, 0.495427,-99) , 
3, 255.615, 0, 0, 0.499259,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.441046,-99) , 
1, 316.494, 1, 0, 0.494923,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.0475249);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519531,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483076,-99) , 
0, 130.71, 1, 0, 0.508525,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.43267,-99) , 
0, 61.624, 0, 0, 0.504412,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44593,-99) , 
0, 193.516, 1, 0, 0.500178,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.0244817);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 213.062, 0, 1, 0.505712,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45405,-99) , 
1, 129.762, 0, 0, 0.501638,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.445919,-99) , 
1, 316.494, 1, 0, 0.497504,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.084322);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 202.34, 0, 1, 0.562318,-99) , 
NN(
0, 
0, 
-1, 203.399, 1, -1, 0.435446,-99) , 
2, 2.77936, 0, 0, 0.508223,-99) , 
NN(
NN(
0, 
0, 
-1, 80.9395, 0, 1, 0.513181,-99) , 
NN(
0, 
0, 
-1, 55.6902, 0, -1, 0.462819,-99) , 
2, 2.63185, 1, 0, 0.482929,-99) , 
3, 129.543, 0, 0, 0.493184,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.0720174);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.628549,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52663,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479716,-99) , 
3, 152.259, 0, 0, 0.490176,-99) , 
3, 213.062, 0, 0, 0.505832,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5402,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484327,-99) , 
0, 96.3734, 1, 0, 0.497206,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.384277,-99) , 
3, 173.969, 1, 0, 0.475407,-99) , 
2, 2.63185, 0, 0, 0.494429,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.0891681);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542148,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.425215,-99) , 
1, 276.903, 1, 0, 0.527848,-99) , 
NN(
0, 
0, 
-1, 1.4073, 0, -1, 0.456474,-99) , 
2, 2.10707, 0, 0, 0.513623,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.553144,-99) , 
NN(
0, 
0, 
-1, 90.5392, 0, -1, 0.461111,-99) , 
1, 227.787, 0, 0, 0.48385,-99) , 
0, 106.962, 0, 0, 0.502928,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.0236495);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537512,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535488,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497057,-99) , 
2, 3.33133, 0, 0, 0.50067,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452584,-99) , 
0, 193.516, 1, 0, 0.497195,-99) , 
2, 3.6814, 0, 0, 0.501191,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.034349);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516347,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4926,-99) , 
0, 136.991, 1, 0, 0.510939,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46001,-99) , 
0, 61.624, 0, 0, 0.508185,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463796,-99) , 
0, 193.516, 1, 0, 0.505004,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.0241938);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540945,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549027,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496993,-99) , 
2, 3.55801, 0, 0, 0.502803,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46257,-99) , 
3, 37.2253, 0, 0, 0.49968,-99) , 
3, 258.785, 0, 0, 0.501946,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.0373855);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515484,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463616,-99) , 
1, 125.613, 0, 0, 0.512046,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468211,-99) , 
1, 266.697, 1, 0, 0.508847,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472151,-99) , 
1, 316.494, 1, 0, 0.506154,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.0284636);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545173,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505987,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484527,-99) , 
0, 106.962, 0, 0, 0.498149,-99) , 
2, 3.55801, 0, 0, 0.503125,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476715,-99) , 
3, 43.382, 0, 0, 0.500509,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.0496552);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54702,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454497,-99) , 
0, 135.813, 1, 0, 0.524607,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.557389,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487368,-99) , 
0, 152.379, 0, 0, 0.494261,-99) , 
1, 229.353, 0, 0, 0.501514,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46622,-99) , 
0, 193.516, 1, 0, 0.49899,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0278014);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 213.062, 0, 1, 0.511681,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474989,-99) , 
1, 254.248, 1, 0, 0.507875,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47556,-99) , 
1, 316.494, 1, 0, 0.505507,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.0322978);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53723,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469417,-99) , 
0, 135.813, 1, 0, 0.520818,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503561,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438775,-99) , 
1, 212.753, 1, 0, 0.497282,-99) , 
1, 229.353, 0, 0, 0.502899,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475062,-99) , 
0, 193.516, 1, 0, 0.500912,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0400583);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526304,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530945,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473313,-99) , 
3, 124.786, 1, 0, 0.512847,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537443,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4848,-99) , 
3, 197.229, 0, 0, 0.489905,-99) , 
2, 2.10707, 1, 0, 0.494208,-99) , 
3, 258.785, 0, 0, 0.495961,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0226169);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539005,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531584,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495927,-99) , 
2, 3.83141, 0, 0, 0.499232,-99) , 
3, 213.062, 0, 0, 0.50349,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477381,-99) , 
2, 1.58229, 0, 0, 0.500954,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.026781);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533381,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508985,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483085,-99) , 
3, 61.0842, 0, 0, 0.503838,-99) , 
3, 213.062, 0, 0, 0.506999,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483026,-99) , 
2, 1.58229, 0, 0, 0.504671,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.0497201);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 83.7769, 0, 1, 0.533444,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525169,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494463,-99) , 
3, 148.004, 0, 0, 0.498481,-99) , 
2, 2.10707, 1, 0, 0.505318,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.567013,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477221,-99) , 
3, 206.972, 0, 0, 0.526711,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.366597,-99) , 
2, 2.37906, 0, 0, 0.486956,-99) , 
3, 172.624, 1, 0, 0.501422,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.0619144);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52139,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478522,-99) , 
0, 169.687, 1, 0, 0.516637,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506598,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472119,-99) , 
2, 2.60179, 1, 0, 0.4843,-99) , 
1, 150.657, 0, 0, 0.510276,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.557956,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466815,-99) , 
0, 108.473, 0, 0, 0.525499,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.378217,-99) , 
2, 2.37906, 0, 0, 0.489048,-99) , 
3, 172.624, 1, 0, 0.505781,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.0239484);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535596,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524713,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495775,-99) , 
2, 3.80638, 0, 0, 0.498878,-99) , 
3, 213.062, 0, 0, 0.502817,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506086,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496073,-99) , 
2, 1.70716, 1, 0, 0.501997,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443093,-99) , 
3, 131.865, 1, 0, 0.482577,-99) , 
2, 2.10707, 0, 0, 0.498959,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.0255994);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 163.112, 0, 1, 0.513993,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500838,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475031,-99) , 
3, 169.855, 1, 0, 0.494532,-99) , 
1, 198.708, 1, 0, 0.506375,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505573,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496576,-99) , 
3, 70.5033, 1, 0, 0.5009,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44901,-99) , 
3, 131.865, 1, 0, 0.483807,-99) , 
2, 2.10707, 0, 0, 0.502074,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0285303);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.556099,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45592,-99) , 
3, 74.5167, 0, 0, 0.517602,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500886,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473523,-99) , 
1, 142.212, 0, 0, 0.496749,-99) , 
2, 3.38161, 0, 0, 0.500582,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477157,-99) , 
2, 1.58229, 0, 0, 0.498318,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0244658);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.551726,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498471,-99) , 
0, 163.112, 0, 0, 0.504566,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502112,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468839,-99) , 
1, 227.574, 0, 0, 0.484763,-99) , 
1, 192.005, 1, 0, 0.496556,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476105,-99) , 
1, 316.494, 1, 0, 0.495063,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0353829);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527969,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503432,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482609,-99) , 
2, 3.15663, 1, 0, 0.497673,-99) , 
3, 184.927, 0, 0, 0.499988,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.579398,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.393471,-99) , 
2, 2.87694, 0, 0, 0.482917,-99) , 
3, 215.704, 1, 0, 0.49821,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.0288672);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517522,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531817,-99) , 
NN(
0, 
0, 
-1, 215.946, 1, -1, 0.487728,-99) , 
2, 3.33134, 0, 0, 0.491831,-99) , 
2, 3.6814, 0, 0, 0.494366,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.0349339);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549757,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505343,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485078,-99) , 
1, 199.065, 1, 0, 0.497587,-99) , 
3, 213.062, 0, 0, 0.503295,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517635,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48992,-99) , 
3, 83.8563, 0, 0, 0.505234,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.433541,-99) , 
3, 173.969, 1, 0, 0.491723,-99) , 
2, 2.63185, 0, 0, 0.498947,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.0160181);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509276,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522264,-99) , 
NN(
0, 
0, 
-1, 215.946, 1, -1, 0.493604,-99) , 
2, 3.33134, 0, 0, 0.496266,-99) , 
2, 3.6814, 0, 0, 0.497549,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.0180001);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528685,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504308,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485289,-99) , 
2, 3.15663, 1, 0, 0.499055,-99) , 
3, 184.927, 0, 0, 0.501318,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489481,-99) , 
3, 215.704, 1, 0, 0.500093,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.0285581);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547656,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519301,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49273,-99) , 
2, 3.83136, 0, 0, 0.4963,-99) , 
3, 213.062, 0, 0, 0.501917,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524681,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497589,-99) , 
0, 96.3734, 1, 0, 0.503823,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44643,-99) , 
3, 173.969, 1, 0, 0.49304,-99) , 
2, 2.63185, 0, 0, 0.498583,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.0254993);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540572,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505181,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48588,-99) , 
3, 61.0842, 0, 0, 0.501521,-99) , 
3, 213.062, 0, 0, 0.505788,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516326,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498161,-99) , 
2, 2.13203, 1, 0, 0.507678,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453498,-99) , 
3, 173.969, 1, 0, 0.497509,-99) , 
2, 2.63185, 0, 0, 0.502679,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.0354786);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516466,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484288,-99) , 
0, 127.347, 1, 0, 0.507115,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473586,-99) , 
0, 169.992, 1, 0, 0.503502,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532378,-99) , 
NN(
0, 
0, 
-1, 106.962, 0, -1, 0.485592,-99) , 
2, 3.17308, 0, 0, 0.49576,-99) , 
3, 129.543, 1, 0, 0.5004,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.0340008);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544242,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499758,-99) , 
0, 150.314, 0, 0, 0.51134,-99) , 
NN(
0, 
0, 
-1, 129.572, 1, -1, 0.481501,-99) , 
1, 236.083, 1, 0, 0.504716,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520613,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511173,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463198,-99) , 
0, 90.5392, 0, 0, 0.485797,-99) , 
1, 227.787, 0, 0, 0.494396,-99) , 
0, 106.962, 0, 0, 0.500996,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.0424261);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520693,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47536,-99) , 
1, 276.903, 1, 0, 0.515202,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503716,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464433,-99) , 
2, 1.4073, 0, 0, 0.487955,-99) , 
2, 2.10707, 0, 0, 0.509776,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546488,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47798,-99) , 
0, 61.6206, 0, 0, 0.515323,-99) , 
NN(
0, 
0, 
-1, 89.1057, 0, -1, 0.482614,-99) , 
0, 78.1102, 1, 0, 0.492661,-99) , 
0, 106.962, 0, 0, 0.503609,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.0182043);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517564,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520283,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513448,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494417,-99) , 
1, 229.353, 0, 0, 0.498906,-99) , 
2, 1.58229, 1, 0, 0.500895,-99) , 
3, 258.785, 0, 0, 0.501769,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.0144691);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52758,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532256,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499185,-99) , 
3, 182.65, 0, 0, 0.501957,-99) , 
3, 213.062, 0, 0, 0.504683,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511956,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493385,-99) , 
2, 1.84049, 1, 0, 0.504153,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482113,-99) , 
2, 1.30735, 0, 0, 0.496856,-99) , 
2, 2.10707, 0, 0, 0.503196,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.0282886);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 230.997, 0, 1, 0.511528,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532478,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479191,-99) , 
2, 3.90631, 0, 0, 0.493645,-99) , 
2, 3.15663, 1, 0, 0.50666,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492634,-99) , 
3, 215.704, 1, 0, 0.505218,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.0136062);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530479,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524941,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499204,-99) , 
3, 182.65, 0, 0, 0.50136,-99) , 
3, 213.062, 0, 0, 0.50446,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504621,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489807,-99) , 
0, 122.697, 1, 0, 0.497873,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480522,-99) , 
2, 1.30735, 0, 0, 0.492132,-99) , 
2, 2.10707, 0, 0, 0.502118,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.0146316);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 213.062, 0, 1, 0.506629,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50474,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490197,-99) , 
2, 1.60721, 1, 0, 0.497694,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483441,-99) , 
3, 131.865, 1, 0, 0.493054,-99) , 
2, 2.10707, 0, 0, 0.50405,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.0109546);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52344,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517895,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498948,-99) , 
3, 182.65, 0, 0, 0.500534,-99) , 
3, 213.062, 0, 0, 0.502971,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503845,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494235,-99) , 
2, 1.84049, 1, 0, 0.499806,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482761,-99) , 
2, 1.30735, 0, 0, 0.494167,-99) , 
2, 2.10707, 0, 0, 0.501299,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.0240843);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532933,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504595,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486392,-99) , 
3, 37.4223, 0, 0, 0.502742,-99) , 
3, 156.21, 0, 0, 0.505066,-99) , 
NN(
NN(
0, 
0, 
-1, 157.664, 0, 1, 0.520655,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461072,-99) , 
1, 198.708, 1, 0, 0.494392,-99) , 
3, 172.624, 1, 0, 0.50283,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.0262847);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539746,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472841,-99) , 
3, 74.5167, 0, 0, 0.514015,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510458,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49223,-99) , 
3, 85.6925, 1, 0, 0.497203,-99) , 
2, 3.38156, 0, 0, 0.500637,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501351,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488829,-99) , 
2, 1.76435, 0, 0, 0.495442,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482152,-99) , 
2, 1.30735, 0, 0, 0.491046,-99) , 
2, 2.10707, 0, 0, 0.498815,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.0114738);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525067,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518761,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498334,-99) , 
3, 182.65, 0, 0, 0.500044,-99) , 
3, 213.062, 0, 0, 0.502704,-99) , 
NN(
0, 
0, 
-1, 1.50725, 1, -1, 0.49297,-99) , 
2, 2.10707, 0, 0, 0.500855,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.0098411);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 213.062, 0, 1, 0.504534,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502638,-99) , 
NN(
0, 
0, 
-1, 1.84995, 1, -1, 0.490129,-99) , 
2, 1.50725, 1, 0, 0.495838,-99) , 
2, 2.10707, 0, 0, 0.502882,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.0232458);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532052,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50186,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485322,-99) , 
0, 169.687, 1, 0, 0.500071,-99) , 
3, 156.21, 0, 0, 0.502533,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546955,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478076,-99) , 
3, 206.972, 0, 0, 0.515893,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466188,-99) , 
2, 2.77168, 0, 0, 0.494874,-99) , 
3, 172.624, 1, 0, 0.50093,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.0150846);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512003,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512768,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504289,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49251,-99) , 
1, 229.353, 0, 0, 0.495286,-99) , 
2, 1.58229, 1, 0, 0.496912,-99) , 
3, 258.785, 0, 0, 0.497697,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.0159259);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 163.112, 0, 1, 0.506632,-99) , 
NN(
0, 
0, 
-1, 3.38156, 1, -1, 0.490628,-99) , 
1, 198.708, 1, 0, 0.500367,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502079,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49029,-99) , 
2, 1.84049, 1, 0, 0.497124,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483293,-99) , 
2, 1.30735, 0, 0, 0.49255,-99) , 
2, 2.10707, 0, 0, 0.498883,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.0140555);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525552,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51185,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495403,-99) , 
2, 1.58229, 1, 0, 0.496971,-99) , 
3, 184.927, 0, 0, 0.499155,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491303,-99) , 
3, 215.704, 1, 0, 0.498352,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.0255736);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511135,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480899,-99) , 
1, 276.903, 1, 0, 0.507472,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505738,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477432,-99) , 
3, 128.274, 1, 0, 0.49397,-99) , 
0, 106.962, 0, 0, 0.502508,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502483,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510277,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463753,-99) , 
1, 194.112, 1, 0, 0.487804,-99) , 
2, 1.70716, 0, 0, 0.493662,-99) , 
2, 2.10707, 0, 0, 0.500828,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.0250227);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511177,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540268,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492789,-99) , 
0, 95.0473, 1, 0, 0.504045,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527305,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49021,-99) , 
0, 163.112, 0, 0, 0.494485,-99) , 
1, 229.353, 0, 0, 0.496767,-99) , 
3, 258.785, 0, 0, 0.497516,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.00900431);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518435,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520386,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499452,-99) , 
3, 182.65, 0, 0, 0.501204,-99) , 
3, 213.062, 0, 0, 0.50303,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502052,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493329,-99) , 
2, 1.76435, 0, 0, 0.497938,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487535,-99) , 
2, 1.30735, 0, 0, 0.494501,-99) , 
2, 2.10707, 0, 0, 0.50141,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.0101526);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52419,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511826,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499529,-99) , 
1, 230.997, 0, 0, 0.502324,-99) , 
3, 184.927, 0, 0, 0.503994,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491329,-99) , 
3, 215.704, 1, 0, 0.502699,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.0198679);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541051,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479742,-99) , 
1, 204.023, 1, 0, 0.515471,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505236,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493663,-99) , 
2, 3.13881, 1, 0, 0.503201,-99) , 
2, 3.38156, 0, 0, 0.505706,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502645,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493977,-99) , 
2, 1.84049, 1, 0, 0.499001,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491046,-99) , 
2, 1.30735, 0, 0, 0.496372,-99) , 
2, 2.10707, 0, 0, 0.503933,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.0109116);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520493,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510679,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498509,-99) , 
1, 230.997, 0, 0, 0.501265,-99) , 
2, 1.58229, 1, 0, 0.503069,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491948,-99) , 
3, 215.704, 1, 0, 0.501932,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.0275101);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543425,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495905,-99) , 
1, 196.383, 1, 0, 0.522626,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486798,-99) , 
3, 85.4057, 0, 0, 0.50872,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507743,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485224,-99) , 
0, 169.687, 1, 0, 0.505248,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468182,-99) , 
3, 215.946, 1, 0, 0.501195,-99) , 
2, 3.15663, 0, 0, 0.503195,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.0216538);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536134,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513438,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47838,-99) , 
3, 86.1586, 0, 0, 0.50207,-99) , 
2, 3.90631, 0, 0, 0.510871,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517364,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497132,-99) , 
3, 51.8848, 1, 0, 0.499894,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475037,-99) , 
3, 215.946, 1, 0, 0.497178,-99) , 
2, 3.15663, 0, 0, 0.500817,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.0125493);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525559,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510963,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49963,-99) , 
2, 3.38156, 0, 0, 0.502046,-99) , 
3, 213.062, 0, 0, 0.50454,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502236,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510484,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474799,-99) , 
1, 194.112, 1, 0, 0.49327,-99) , 
2, 1.70716, 0, 0, 0.496849,-99) , 
2, 2.10707, 0, 0, 0.503079,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.016052);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 170.51, 0, 1, 0.511278,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50611,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493906,-99) , 
2, 2.63307, 1, 0, 0.499805,-99) , 
2, 2.95674, 0, 0, 0.505816,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50021,-99) , 
NN(
0, 
0, 
-1, 1.84995, 0, -1, 0.491607,-99) , 
2, 1.50725, 1, 0, 0.49553,-99) , 
2, 2.10707, 0, 0, 0.503863,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.0123232);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520542,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50289,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490712,-99) , 
3, 40.8232, 0, 0, 0.501791,-99) , 
3, 213.062, 0, 0, 0.503778,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503111,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505354,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475759,-99) , 
1, 194.112, 1, 0, 0.491077,-99) , 
2, 1.70716, 0, 0, 0.495883,-99) , 
2, 2.10707, 0, 0, 0.502278,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.00911979);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517465,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510134,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498274,-99) , 
3, 182.65, 0, 0, 0.499266,-99) , 
3, 213.062, 0, 0, 0.501194,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500031,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502274,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478834,-99) , 
1, 194.112, 1, 0, 0.490967,-99) , 
2, 1.70716, 0, 0, 0.494587,-99) , 
2, 2.10707, 0, 0, 0.49994,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.01932);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512508,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496079,-99) , 
1, 205.438, 1, 0, 0.506636,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508653,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484928,-99) , 
0, 90.475, 0, 0, 0.495796,-99) , 
0, 106.962, 0, 0, 0.50265,-99) , 
NN(
0, 
0, 
-1, 1.70716, 0, -1, 0.493628,-99) , 
2, 2.10707, 0, 0, 0.500937,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.0215458);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533497,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503199,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487136,-99) , 
1, 150.657, 0, 0, 0.500078,-99) , 
3, 156.21, 0, 0, 0.502647,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52242,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481654,-99) , 
2, 2.94004, 0, 0, 0.505819,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46559,-99) , 
2, 2.37906, 0, 0, 0.496049,-99) , 
3, 172.624, 1, 0, 0.501269,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.0124195);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516383,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49026,-99) , 
1, 125.613, 0, 0, 0.505746,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501688,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485538,-99) , 
2, 1.93202, 0, 0, 0.498872,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485701,-99) , 
2, 3.6814, 1, 0, 0.4975,-99) , 
1, 142.212, 1, 0, 0.498651,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.00981596);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513281,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493364,-99) , 
1, 125.613, 0, 0, 0.505171,-99) , 
NN(
0, 
0, 
-1, 3.6814, 1, -1, 0.496012,-99) , 
1, 142.212, 1, 0, 0.49729,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.0124693);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509809,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515512,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504494,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494755,-99) , 
1, 229.353, 0, 0, 0.49705,-99) , 
2, 1.58229, 1, 0, 0.498768,-99) , 
3, 258.785, 0, 0, 0.499338,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.0140775);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513269,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4982,-99) , 
1, 125.613, 0, 0, 0.507133,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503861,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478841,-99) , 
1, 244.962, 1, 0, 0.5003,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488759,-99) , 
1, 308.196, 1, 0, 0.499215,-99) , 
1, 142.212, 1, 0, 0.50032,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.0119505);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.96316, 0, 1, 0.50648,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502916,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490707,-99) , 
0, 106.962, 0, 0, 0.498449,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501158,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486577,-99) , 
2, 1.70716, 0, 0, 0.492352,-99) , 
2, 2.10707, 0, 0, 0.497265,-99) , 
1, 142.212, 1, 0, 0.498551,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.00689923);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510046,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499061,-99) , 
2, 2.96316, 0, 0, 0.503493,-99) , 
NN(
0, 
0, 
-1, 3.6814, 1, -1, 0.496739,-99) , 
1, 142.212, 1, 0, 0.497682,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.00664275);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507092,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499072,-99) , 
1, 125.613, 0, 0, 0.503826,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501069,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490873,-99) , 
2, 1.93202, 0, 0, 0.499292,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491349,-99) , 
2, 3.6814, 1, 0, 0.498464,-99) , 
1, 142.212, 1, 0, 0.499212,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.0183553);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.96316, 0, 1, 0.503518,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506955,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493124,-99) , 
3, 107.005, 0, 0, 0.498664,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514545,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467924,-99) , 
1, 209.883, 1, 0, 0.493843,-99) , 
3, 172.651, 1, 0, 0.497668,-99) , 
1, 142.212, 1, 0, 0.498484,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.0247366);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521614,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487496,-99) , 
2, 3.15663, 1, 0, 0.511298,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474025,-99) , 
3, 172.651, 1, 0, 0.502093,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529346,-99) , 
NN(
0, 
0, 
-1, 187.856, 1, -1, 0.492909,-99) , 
0, 163.112, 0, 0, 0.497171,-99) , 
1, 229.353, 0, 0, 0.498375,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.0166491);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543553,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496344,-99) , 
0, 61.6206, 0, 0, 0.522086,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503307,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464055,-99) , 
0, 89.1078, 0, 0, 0.499921,-99) , 
0, 78.1105, 1, 0, 0.502559,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492908,-99) , 
0, 193.516, 1, 0, 0.501878,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.0243816);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.80585, 1, 1, 0.521719,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505231,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468062,-99) , 
0, 89.1057, 0, 0, 0.494738,-99) , 
0, 78.1102, 1, 0, 0.503011,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515549,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485448,-99) , 
1, 205.438, 1, 0, 0.503694,-99) , 
NN(
0, 
0, 
-1, 153.474, 0, -1, 0.492913,-99) , 
3, 129.543, 0, 0, 0.497222,-99) , 
0, 106.962, 1, 0, 0.499309,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.0213974);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510189,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492028,-99) , 
0, 127.347, 1, 0, 0.504914,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483041,-99) , 
0, 169.992, 1, 0, 0.502558,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509458,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49154,-99) , 
1, 205.438, 1, 0, 0.502401,-99) , 
NN(
0, 
0, 
-1, 86.3522, 0, -1, 0.484929,-99) , 
0, 106.962, 0, 0, 0.496108,-99) , 
3, 129.543, 1, 0, 0.499981,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.0216306);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516361,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4935,-99) , 
2, 3.15663, 1, 0, 0.509452,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486062,-99) , 
3, 172.651, 1, 0, 0.503678,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527576,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501716,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484042,-99) , 
3, 124.806, 1, 0, 0.49441,-99) , 
0, 163.112, 0, 0, 0.498287,-99) , 
1, 229.353, 0, 0, 0.499605,-99)    );
   return;
};
 
// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
